# ! [ doc = "Peripheral access API for EARLGREY microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api" ]
# ! [ deny ( const_err ) ]
# ! [ deny ( dead_code ) ]
# ! [ deny ( improper_ctypes ) ]
# ! [ deny ( legacy_directory_ownership ) ]
# ! [ deny ( missing_docs ) ]
# ! [ deny ( no_mangle_generic_items ) ]
# ! [ deny ( non_shorthand_field_patterns ) ]
# ! [ deny ( overflowing_literals ) ]
# ! [ deny ( path_statements ) ]
# ! [ deny ( patterns_in_fns_without_body ) ]
# ! [ deny ( plugin_as_library ) ]
# ! [ deny ( private_in_public ) ]
# ! [ deny ( safe_extern_statics ) ]
# ! [ deny ( unconditional_recursion ) ]
# ! [ deny ( unions_with_drop_fields ) ]
# ! [ deny ( unused_allocation ) ]
# ! [ deny ( unused_comparisons ) ]
# ! [ deny ( unused_parens ) ]
# ! [ deny ( while_true ) ]
# ! [ allow ( non_camel_case_types ) ]
# ! [ allow ( non_snake_case ) ]
# ! [ no_std ]
extern crate riscv ; # [ cfg ( feature = "rt" ) ]
extern crate riscv_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [ doc = r"Number available in the NVIC for configuring priority" ]
pub const NVIC_PRIO_BITS : u8 = 0 ; # [ doc ( hidden ) ]
pub mod interrupt { # [ doc = r"Enumeration of all the interrupts" ]
# [ derive ( Copy , Clone , Debug ) ]
# [ repr ( u8 ) ]
pub enum Interrupt { # [ doc = "0 - esc0" ]
ESC0 = 0 , # [ doc = "1 - esc1" ]
ESC1 = 1 , # [ doc = "2 - esc2" ]
ESC2 = 2 , # [ doc = "3 - esc3" ]
ESC3 = 3 , # [ doc = "4 - op_done" ]
OP_DONE = 4 , # [ doc = "5 - op_error" ]
OP_ERROR = 5 , # [ doc = "6 - rx_timeout" ]
RX_TIMEOUT = 6 , # [ doc = "7 - rx_parity_err" ]
RX_PARITY_ERR = 7 , } unsafe impl bare_metal :: Nr for Interrupt { # [ inline ( always ) ]
fn nr ( & self ) -> u8 { * self as u8 } } # [ derive ( Debug , Copy , Clone ) ]
pub struct TryFromInterruptError ( ( ) ) ; impl Interrupt { # [ inline ]
pub fn try_from ( value : u8 ) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok ( Interrupt :: ESC0 ) , 1 => Ok ( Interrupt :: ESC1 ) , 2 => Ok ( Interrupt :: ESC2 ) , 3 => Ok ( Interrupt :: ESC3 ) , 4 => Ok ( Interrupt :: OP_DONE ) , 5 => Ok ( Interrupt :: OP_ERROR ) , 6 => Ok ( Interrupt :: RX_TIMEOUT ) , 7 => Ok ( Interrupt :: RX_PARITY_ERR ) , _ => Err ( TryFromInterruptError ( ( ) ) ) , } } } # [ cfg ( feature = "rt" ) ]
# [ macro_export ]
# [ doc = r" Assigns a handler to an interrupt" ]
# [ doc = r"" ]
# [ doc = r" This macro takes two arguments: the name of an interrupt and the path to the" ]
# [ doc = r" function that will be used as the handler of that interrupt. That function" ]
# [ doc = r" must have signature `fn()`." ]
# [ doc = r"" ]
# [ doc = r" Optionally, a third argument may be used to declare interrupt local data." ]
# [ doc = r" The handler will have exclusive access to these *local* variables on each" ]
# [ doc = r" invocation. If the third argument is used then the signature of the handler" ]
# [ doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument" ]
# [ doc = r" passed to the macro." ]
# [ doc = r"" ]
# [ doc = r" # Example" ]
# [ doc = r"" ]
# [ doc = r" ``` ignore" ]
# [ doc = r" interrupt!(TIM2, periodic);" ]
# [ doc = r"" ]
# [ doc = r" fn periodic() {" ]
# [ doc = r#"     print!(".");"# ]
# [ doc = r" }" ]
# [ doc = r"" ]
# [ doc = r" interrupt!(TIM3, tick, locals: {" ]
# [ doc = r"     tick: bool = false;" ]
# [ doc = r" });" ]
# [ doc = r"" ]
# [ doc = r" fn tick(locals: &mut TIM3::Locals) {" ]
# [ doc = r"     locals.tick = !locals.tick;" ]
# [ doc = r"" ]
# [ doc = r"     if locals.tick {" ]
# [ doc = r#"         println!("Tick");"# ]
# [ doc = r"     } else {" ]
# [ doc = r#"         println!("Tock");"# ]
# [ doc = r"     }" ]
# [ doc = r" }" ]
# [ doc = r" ```" ]
macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ]
mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } } } pub use self :: interrupt :: Interrupt ; # [ allow ( unused_imports ) ]
use generic :: * ; # [ doc = r"Common register and bit access and modify traits" ]
pub mod generic { use core :: marker ; # [ doc = "This trait shows that register has `read` method" ]
# [ doc = "" ]
# [ doc = "Registers marked with `Writable` can be also `modify`'ed" ]
pub trait Readable { } # [ doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method" ]
# [ doc = "" ]
# [ doc = "Registers marked with `Readable` can be also `modify`'ed" ]
pub trait Writable { } # [ doc = "Reset value of the register" ]
# [ doc = "" ]
# [ doc = "This value is initial value for `write` method." ]
# [ doc = "It can be also directly writed to register by `reset` method." ]
pub trait ResetValue { # [ doc = "Register size" ]
type Type ; # [ doc = "Reset value of the register" ]
fn reset_value ( ) -> Self :: Type ; } # [ doc = "This structure provides volatile access to register" ]
pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [ doc = "Reads the contents of `Readable` register" ]
# [ doc = "" ]
# [ doc = "You can read the contents of a register in such way:" ]
# [ doc = "```ignore" ]
# [ doc = "let bits = periph.reg.read().bits();" ]
# [ doc = "```" ]
# [ doc = "or get the content of a particular field of a register." ]
# [ doc = "```ignore" ]
# [ doc = "let reader = periph.reg.read();" ]
# [ doc = "let bits = reader.field1().bits();" ]
# [ doc = "let flag = reader.field2().bit_is_set();" ]
# [ doc = "```" ]
# [ inline ( always ) ]
pub fn read ( & self ) -> R < U , Self > { R { bits : self . register . get ( ) , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [ doc = "Writes the reset value to `Writable` register" ]
# [ doc = "" ]
# [ doc = "Resets the register to its initial state" ]
# [ inline ( always ) ]
pub fn reset ( & self ) { self . register . set ( Self :: reset_value ( ) ) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [ doc = "Writes bits to `Writable` register" ]
# [ doc = "" ]
# [ doc = "You can write raw bits into a register:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });" ]
# [ doc = "```" ]
# [ doc = "or write only the fields you need:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.write(|w| w" ]
# [ doc = "    .field1().bits(newfield1bits)" ]
# [ doc = "    .field2().set_bit()" ]
# [ doc = "    .field3().variant(VARIANT)" ]
# [ doc = ");" ]
# [ doc = "```" ]
# [ doc = "Other fields will have reset value." ]
# [ inline ( always ) ]
pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : Self :: reset_value ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [ doc = "Writes Zero to `Writable` register" ]
# [ doc = "" ]
# [ doc = "Similar to `write`, but unused bits will contain 0." ]
# [ inline ( always ) ]
pub fn write_with_zero < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : U :: default ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [ doc = "Modifies the contents of the register" ]
# [ doc = "" ]
# [ doc = "E.g. to do a read-modify-write sequence to change parts of a register:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.modify(|r, w| unsafe { w.bits(" ]
# [ doc = "   r.bits() | 3" ]
# [ doc = ") });" ]
# [ doc = "```" ]
# [ doc = "or" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.modify(|_, w| w" ]
# [ doc = "    .field1().bits(newfield1bits)" ]
# [ doc = "    .field2().set_bit()" ]
# [ doc = "    .field3().variant(VARIANT)" ]
# [ doc = ");" ]
# [ doc = "```" ]
# [ doc = "Other fields will have value they had before call `modify`." ]
# [ inline ( always ) ]
pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R < U , Self > , & 'w mut W < U , Self > ) -> & 'w mut W < U , Self > { let bits = self . register . get ( ) ; self . register . set ( f ( & R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData } ) . bits ) ; } } # [ doc = "Register/field reader" ]
# [ doc = "" ]
# [ doc = "Result of the [`read`](Reg::read) method of a register." ]
# [ doc = "Also it can be used in the [`modify`](Reg::read) method" ]
pub struct R < U , T > { pub ( crate ) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [ doc = "Create new instance of reader" ]
# [ inline ( always ) ]
pub ( crate ) fn new ( bits : U ) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [ doc = "Read raw bits from register/field" ]
# [ inline ( always ) ]
pub fn bits ( & self ) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [ inline ( always ) ]
fn eq ( & self , other : & FI ) -> bool { self . bits . eq ( & ( * other ) . into ( ) ) } } impl < FI > R < bool , FI > { # [ doc = "Value of the field as raw bits" ]
# [ inline ( always ) ]
pub fn bit ( & self ) -> bool { self . bits } # [ doc = "Returns `true` if the bit is clear (0)" ]
# [ inline ( always ) ]
pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = "Returns `true` if the bit is set (1)" ]
# [ inline ( always ) ]
pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Register writer" ]
# [ doc = "" ]
# [ doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register" ]
pub struct W < U , REG > { # [ doc = "Writable bits" ]
pub ( crate ) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [ doc = "Writes raw bits to the register" ]
# [ inline ( always ) ]
pub unsafe fn bits ( & mut self , bits : U ) -> & mut Self { self . bits = bits ; self } } # [ doc = "Used if enumerated values cover not the whole range" ]
# [ derive ( Clone , Copy , PartialEq ) ]
pub enum Variant < U , T > { # [ doc = "Expected variant" ]
Val ( T ) , # [ doc = "Raw bits" ]
Res ( U ) , } } # [ doc = "uart" ]
pub struct UART { _marker : PhantomData < * const ( ) > } unsafe impl Send for UART { } impl UART { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const uart :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for UART { type Target = uart :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * UART :: ptr ( ) } } } # [ doc = "uart" ]
pub mod uart { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - UART control register" ]
pub ctrl : CTRL , # [ doc = "0x10 - UART live status register" ]
pub status : STATUS , # [ doc = "0x14 - UART read data" ]
pub rdata : RDATA , _reserved6 : [ u8 ; 3usize ]
, # [ doc = "0x18 - UART write data" ]
pub wdata : WDATA , _reserved7 : [ u8 ; 3usize ]
, # [ doc = "0x1c - UART FIFO control register" ]
pub fifo_ctrl : FIFO_CTRL , # [ doc = "0x20 - UART FIFO status register" ]
pub fifo_status : FIFO_STATUS , # [ doc = "0x24 - TX pin override control. Gives direct SW control over TX pin state" ]
pub ovrd : OVRD , # [ doc = "0x28 - UART oversampled values" ]
pub val : VAL , # [ doc = "0x2c - UART RX timeout control" ]
pub timeout_ctrl : TIMEOUT_CTRL , } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `tx_watermark`" ]
pub type TX_WATERMARK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `tx_watermark`" ]
pub struct TX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > TX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `rx_watermark`" ]
pub type RX_WATERMARK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_watermark`" ]
pub struct RX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > RX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `tx_empty`" ]
pub type TX_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `tx_empty`" ]
pub struct TX_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TX_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rx_overflow`" ]
pub type RX_OVERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_overflow`" ]
pub struct RX_OVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RX_OVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `rx_frame_err`" ]
pub type RX_FRAME_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_frame_err`" ]
pub struct RX_FRAME_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_FRAME_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `rx_break_err`" ]
pub type RX_BREAK_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_break_err`" ]
pub struct RX_BREAK_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_BREAK_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `rx_timeout`" ]
pub type RX_TIMEOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_timeout`" ]
pub struct RX_TIMEOUT_W < 'a > { w : & 'a mut W , } impl < 'a > RX_TIMEOUT_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `rx_parity_err`" ]
pub type RX_PARITY_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_parity_err`" ]
pub struct RX_PARITY_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_PARITY_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - raised if the transmit FIFO is past the high-water mark." ]
# [ inline ( always ) ]
pub fn tx_watermark ( & self ) -> TX_WATERMARK_R { TX_WATERMARK_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - raised if the receive FIFO is past the high-water mark." ]
# [ inline ( always ) ]
pub fn rx_watermark ( & self ) -> RX_WATERMARK_R { RX_WATERMARK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - raised if the transmit FIFO has emptied." ]
# [ inline ( always ) ]
pub fn tx_empty ( & self ) -> TX_EMPTY_R { TX_EMPTY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - raised if the receive FIFO has overflowed." ]
# [ inline ( always ) ]
pub fn rx_overflow ( & self ) -> RX_OVERFLOW_R { RX_OVERFLOW_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - raised if a framing error has been detected on receive." ]
# [ inline ( always ) ]
pub fn rx_frame_err ( & self ) -> RX_FRAME_ERR_R { RX_FRAME_ERR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - raised if break condition has been detected on receive." ]
# [ inline ( always ) ]
pub fn rx_break_err ( & self ) -> RX_BREAK_ERR_R { RX_BREAK_ERR_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - raised if RX FIFO has characters remaining in the FIFO without being retrieved for the programmed time period." ]
# [ inline ( always ) ]
pub fn rx_timeout ( & self ) -> RX_TIMEOUT_R { RX_TIMEOUT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - raised if the receiver has detected a parity error." ]
# [ inline ( always ) ]
pub fn rx_parity_err ( & self ) -> RX_PARITY_ERR_R { RX_PARITY_ERR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - raised if the transmit FIFO is past the high-water mark." ]
# [ inline ( always ) ]
pub fn tx_watermark ( & mut self ) -> TX_WATERMARK_W { TX_WATERMARK_W { w : self } } # [ doc = "Bit 1 - raised if the receive FIFO is past the high-water mark." ]
# [ inline ( always ) ]
pub fn rx_watermark ( & mut self ) -> RX_WATERMARK_W { RX_WATERMARK_W { w : self } } # [ doc = "Bit 2 - raised if the transmit FIFO has emptied." ]
# [ inline ( always ) ]
pub fn tx_empty ( & mut self ) -> TX_EMPTY_W { TX_EMPTY_W { w : self } } # [ doc = "Bit 3 - raised if the receive FIFO has overflowed." ]
# [ inline ( always ) ]
pub fn rx_overflow ( & mut self ) -> RX_OVERFLOW_W { RX_OVERFLOW_W { w : self } } # [ doc = "Bit 4 - raised if a framing error has been detected on receive." ]
# [ inline ( always ) ]
pub fn rx_frame_err ( & mut self ) -> RX_FRAME_ERR_W { RX_FRAME_ERR_W { w : self } } # [ doc = "Bit 5 - raised if break condition has been detected on receive." ]
# [ inline ( always ) ]
pub fn rx_break_err ( & mut self ) -> RX_BREAK_ERR_W { RX_BREAK_ERR_W { w : self } } # [ doc = "Bit 6 - raised if RX FIFO has characters remaining in the FIFO without being retrieved for the programmed time period." ]
# [ inline ( always ) ]
pub fn rx_timeout ( & mut self ) -> RX_TIMEOUT_W { RX_TIMEOUT_W { w : self } } # [ doc = "Bit 7 - raised if the receiver has detected a parity error." ]
# [ inline ( always ) ]
pub fn rx_parity_err ( & mut self ) -> RX_PARITY_ERR_W { RX_PARITY_ERR_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `tx_watermark`" ]
pub type TX_WATERMARK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `tx_watermark`" ]
pub struct TX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > TX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `rx_watermark`" ]
pub type RX_WATERMARK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_watermark`" ]
pub struct RX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > RX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `tx_empty`" ]
pub type TX_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `tx_empty`" ]
pub struct TX_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TX_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rx_overflow`" ]
pub type RX_OVERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_overflow`" ]
pub struct RX_OVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RX_OVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `rx_frame_err`" ]
pub type RX_FRAME_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_frame_err`" ]
pub struct RX_FRAME_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_FRAME_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `rx_break_err`" ]
pub type RX_BREAK_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_break_err`" ]
pub struct RX_BREAK_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_BREAK_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `rx_timeout`" ]
pub type RX_TIMEOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_timeout`" ]
pub struct RX_TIMEOUT_W < 'a > { w : & 'a mut W , } impl < 'a > RX_TIMEOUT_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `rx_parity_err`" ]
pub type RX_PARITY_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_parity_err`" ]
pub struct RX_PARITY_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_PARITY_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.tx_watermark is set" ]
# [ inline ( always ) ]
pub fn tx_watermark ( & self ) -> TX_WATERMARK_R { TX_WATERMARK_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.rx_watermark is set" ]
# [ inline ( always ) ]
pub fn rx_watermark ( & self ) -> RX_WATERMARK_R { RX_WATERMARK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.tx_empty is set" ]
# [ inline ( always ) ]
pub fn tx_empty ( & self ) -> TX_EMPTY_R { TX_EMPTY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rx_overflow is set" ]
# [ inline ( always ) ]
pub fn rx_overflow ( & self ) -> RX_OVERFLOW_R { RX_OVERFLOW_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.rx_frame_err is set" ]
# [ inline ( always ) ]
pub fn rx_frame_err ( & self ) -> RX_FRAME_ERR_R { RX_FRAME_ERR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.rx_break_err is set" ]
# [ inline ( always ) ]
pub fn rx_break_err ( & self ) -> RX_BREAK_ERR_R { RX_BREAK_ERR_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Enable interrupt when !!INTR_STATE.rx_timeout is set" ]
# [ inline ( always ) ]
pub fn rx_timeout ( & self ) -> RX_TIMEOUT_R { RX_TIMEOUT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Enable interrupt when !!INTR_STATE.rx_parity_err is set" ]
# [ inline ( always ) ]
pub fn rx_parity_err ( & self ) -> RX_PARITY_ERR_R { RX_PARITY_ERR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.tx_watermark is set" ]
# [ inline ( always ) ]
pub fn tx_watermark ( & mut self ) -> TX_WATERMARK_W { TX_WATERMARK_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.rx_watermark is set" ]
# [ inline ( always ) ]
pub fn rx_watermark ( & mut self ) -> RX_WATERMARK_W { RX_WATERMARK_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.tx_empty is set" ]
# [ inline ( always ) ]
pub fn tx_empty ( & mut self ) -> TX_EMPTY_W { TX_EMPTY_W { w : self } } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rx_overflow is set" ]
# [ inline ( always ) ]
pub fn rx_overflow ( & mut self ) -> RX_OVERFLOW_W { RX_OVERFLOW_W { w : self } } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.rx_frame_err is set" ]
# [ inline ( always ) ]
pub fn rx_frame_err ( & mut self ) -> RX_FRAME_ERR_W { RX_FRAME_ERR_W { w : self } } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.rx_break_err is set" ]
# [ inline ( always ) ]
pub fn rx_break_err ( & mut self ) -> RX_BREAK_ERR_W { RX_BREAK_ERR_W { w : self } } # [ doc = "Bit 6 - Enable interrupt when !!INTR_STATE.rx_timeout is set" ]
# [ inline ( always ) ]
pub fn rx_timeout ( & mut self ) -> RX_TIMEOUT_W { RX_TIMEOUT_W { w : self } } # [ doc = "Bit 7 - Enable interrupt when !!INTR_STATE.rx_parity_err is set" ]
# [ inline ( always ) ]
pub fn rx_parity_err ( & mut self ) -> RX_PARITY_ERR_W { RX_PARITY_ERR_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `tx_watermark`" ]
pub struct TX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > TX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `rx_watermark`" ]
pub struct RX_WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > RX_WATERMARK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `tx_empty`" ]
pub struct TX_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TX_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `rx_overflow`" ]
pub struct RX_OVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RX_OVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Write proxy for field `rx_frame_err`" ]
pub struct RX_FRAME_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_FRAME_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Write proxy for field `rx_break_err`" ]
pub struct RX_BREAK_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_BREAK_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Write proxy for field `rx_timeout`" ]
pub struct RX_TIMEOUT_W < 'a > { w : & 'a mut W , } impl < 'a > RX_TIMEOUT_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Write proxy for field `rx_parity_err`" ]
pub struct RX_PARITY_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > RX_PARITY_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.tx_watermark to 1" ]
# [ inline ( always ) ]
pub fn tx_watermark ( & mut self ) -> TX_WATERMARK_W { TX_WATERMARK_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.rx_watermark to 1" ]
# [ inline ( always ) ]
pub fn rx_watermark ( & mut self ) -> RX_WATERMARK_W { RX_WATERMARK_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.tx_empty to 1" ]
# [ inline ( always ) ]
pub fn tx_empty ( & mut self ) -> TX_EMPTY_W { TX_EMPTY_W { w : self } } # [ doc = "Bit 3 - Write 1 to force !!INTR_STATE.rx_overflow to 1" ]
# [ inline ( always ) ]
pub fn rx_overflow ( & mut self ) -> RX_OVERFLOW_W { RX_OVERFLOW_W { w : self } } # [ doc = "Bit 4 - Write 1 to force !!INTR_STATE.rx_frame_err to 1" ]
# [ inline ( always ) ]
pub fn rx_frame_err ( & mut self ) -> RX_FRAME_ERR_W { RX_FRAME_ERR_W { w : self } } # [ doc = "Bit 5 - Write 1 to force !!INTR_STATE.rx_break_err to 1" ]
# [ inline ( always ) ]
pub fn rx_break_err ( & mut self ) -> RX_BREAK_ERR_W { RX_BREAK_ERR_W { w : self } } # [ doc = "Bit 6 - Write 1 to force !!INTR_STATE.rx_timeout to 1" ]
# [ inline ( always ) ]
pub fn rx_timeout ( & mut self ) -> RX_TIMEOUT_W { RX_TIMEOUT_W { w : self } } # [ doc = "Bit 7 - Write 1 to force !!INTR_STATE.rx_parity_err to 1" ]
# [ inline ( always ) ]
pub fn rx_parity_err ( & mut self ) -> RX_PARITY_ERR_W { RX_PARITY_ERR_W { w : self } } } } # [ doc = "UART control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](ctrl) module" ]
pub type CTRL = crate :: Reg < u32 , _CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CTRL ; # [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ]
impl crate :: Readable for CTRL { } # [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ]
impl crate :: Writable for CTRL { } # [ doc = "UART control register" ]
pub mod ctrl { # [ doc = "Reader of register CTRL" ]
pub type R = crate :: R < u32 , super :: CTRL > ; # [ doc = "Writer for register CTRL" ]
pub type W = crate :: W < u32 , super :: CTRL > ; # [ doc = "Register CTRL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `TX`" ]
pub type TX_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TX`" ]
pub struct TX_W < 'a > { w : & 'a mut W , } impl < 'a > TX_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RX`" ]
pub type RX_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RX`" ]
pub struct RX_W < 'a > { w : & 'a mut W , } impl < 'a > RX_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `NF`" ]
pub type NF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `NF`" ]
pub struct NF_W < 'a > { w : & 'a mut W , } impl < 'a > NF_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SLPBK`" ]
pub type SLPBK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SLPBK`" ]
pub struct SLPBK_W < 'a > { w : & 'a mut W , } impl < 'a > SLPBK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `LLPBK`" ]
pub type LLPBK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LLPBK`" ]
pub struct LLPBK_W < 'a > { w : & 'a mut W , } impl < 'a > LLPBK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PARITY_EN`" ]
pub type PARITY_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PARITY_EN`" ]
pub struct PARITY_EN_W < 'a > { w : & 'a mut W , } impl < 'a > PARITY_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PARITY_ODD`" ]
pub type PARITY_ODD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PARITY_ODD`" ]
pub struct PARITY_ODD_W < 'a > { w : & 'a mut W , } impl < 'a > PARITY_ODD_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `RXBLVL`" ]
pub type RXBLVL_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `RXBLVL`" ]
pub struct RXBLVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXBLVL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `NCO`" ]
pub type NCO_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `NCO`" ]
pub struct NCO_W < 'a > { w : & 'a mut W , } impl < 'a > NCO_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - TX enable" ]
# [ inline ( always ) ]
pub fn tx ( & self ) -> TX_R { TX_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - RX enable" ]
# [ inline ( always ) ]
pub fn rx ( & self ) -> RX_R { RX_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - RX noise filter enable. If the noise filter is enabled, RX line goes through the 3-tap repetition code. It ignores single IP clock period noise." ]
# [ inline ( always ) ]
pub fn nf ( & self ) -> NF_R { NF_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - System loopback enable. If this bit is turned on, any outgoing bits to TX are received through RX. See Block Diagram. Note that the TX line goes 1 if System loopback is enabled." ]
# [ inline ( always ) ]
pub fn slpbk ( & self ) -> SLPBK_R { SLPBK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Line loopback enable. If this bit is turned on, incoming bits are forwarded to TX for testing purpose. See Block Diagram. Note that the internal design sees RX value as 1 always if line loopback is enabled." ]
# [ inline ( always ) ]
pub fn llpbk ( & self ) -> LLPBK_R { LLPBK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - If true, parity is enabled in both RX and TX directions." ]
# [ inline ( always ) ]
pub fn parity_en ( & self ) -> PARITY_EN_R { PARITY_EN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even." ]
# [ inline ( always ) ]
pub fn parity_odd ( & self ) -> PARITY_ODD_R { PARITY_ODD_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:9 - Trigger level for RX break detection. Sets the number of character times the line must be low to detect a break." ]
# [ inline ( always ) ]
pub fn rxblvl ( & self ) -> RXBLVL_R { RXBLVL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 16:31 - BAUD clock rate control." ]
# [ inline ( always ) ]
pub fn nco ( & self ) -> NCO_R { NCO_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bit 0 - TX enable" ]
# [ inline ( always ) ]
pub fn tx ( & mut self ) -> TX_W { TX_W { w : self } } # [ doc = "Bit 1 - RX enable" ]
# [ inline ( always ) ]
pub fn rx ( & mut self ) -> RX_W { RX_W { w : self } } # [ doc = "Bit 2 - RX noise filter enable. If the noise filter is enabled, RX line goes through the 3-tap repetition code. It ignores single IP clock period noise." ]
# [ inline ( always ) ]
pub fn nf ( & mut self ) -> NF_W { NF_W { w : self } } # [ doc = "Bit 4 - System loopback enable. If this bit is turned on, any outgoing bits to TX are received through RX. See Block Diagram. Note that the TX line goes 1 if System loopback is enabled." ]
# [ inline ( always ) ]
pub fn slpbk ( & mut self ) -> SLPBK_W { SLPBK_W { w : self } } # [ doc = "Bit 5 - Line loopback enable. If this bit is turned on, incoming bits are forwarded to TX for testing purpose. See Block Diagram. Note that the internal design sees RX value as 1 always if line loopback is enabled." ]
# [ inline ( always ) ]
pub fn llpbk ( & mut self ) -> LLPBK_W { LLPBK_W { w : self } } # [ doc = "Bit 6 - If true, parity is enabled in both RX and TX directions." ]
# [ inline ( always ) ]
pub fn parity_en ( & mut self ) -> PARITY_EN_W { PARITY_EN_W { w : self } } # [ doc = "Bit 7 - If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even." ]
# [ inline ( always ) ]
pub fn parity_odd ( & mut self ) -> PARITY_ODD_W { PARITY_ODD_W { w : self } } # [ doc = "Bits 8:9 - Trigger level for RX break detection. Sets the number of character times the line must be low to detect a break." ]
# [ inline ( always ) ]
pub fn rxblvl ( & mut self ) -> RXBLVL_W { RXBLVL_W { w : self } } # [ doc = "Bits 16:31 - BAUD clock rate control." ]
# [ inline ( always ) ]
pub fn nco ( & mut self ) -> NCO_W { NCO_W { w : self } } } } # [ doc = "UART live status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module" ]
pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ]
impl crate :: Readable for STATUS { } # [ doc = "UART live status register" ]
pub mod status { # [ doc = "Reader of register STATUS" ]
pub type R = crate :: R < u32 , super :: STATUS > ; # [ doc = "Reader of field `TXFULL`" ]
pub type TXFULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `RXFULL`" ]
pub type RXFULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `TXEMPTY`" ]
pub type TXEMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `TXIDLE`" ]
pub type TXIDLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `RXIDLE`" ]
pub type RXIDLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `RXEMPTY`" ]
pub type RXEMPTY_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - TX buffer is full" ]
# [ inline ( always ) ]
pub fn txfull ( & self ) -> TXFULL_R { TXFULL_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - RX buffer is full" ]
# [ inline ( always ) ]
pub fn rxfull ( & self ) -> RXFULL_R { RXFULL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - TX FIFO is empty" ]
# [ inline ( always ) ]
pub fn txempty ( & self ) -> TXEMPTY_R { TXEMPTY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - TX is idle" ]
# [ inline ( always ) ]
pub fn txidle ( & self ) -> TXIDLE_R { TXIDLE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - RX is idle" ]
# [ inline ( always ) ]
pub fn rxidle ( & self ) -> RXIDLE_R { RXIDLE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - RX FIFO is empty" ]
# [ inline ( always ) ]
pub fn rxempty ( & self ) -> RXEMPTY_R { RXEMPTY_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } } # [ doc = "UART read data\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rdata](rdata) module" ]
pub type RDATA = crate :: Reg < u8 , _RDATA > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RDATA ; # [ doc = "`read()` method returns [rdata::R](rdata::R) reader structure" ]
impl crate :: Readable for RDATA { } # [ doc = "UART read data" ]
pub mod rdata { # [ doc = "Reader of register RDATA" ]
pub type R = crate :: R < u8 , super :: RDATA > ; impl R { } } # [ doc = "UART write data\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdata](wdata) module" ]
pub type WDATA = crate :: Reg < u8 , _WDATA > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _WDATA ; # [ doc = "`write(|w| ..)` method takes [wdata::W](wdata::W) writer structure" ]
impl crate :: Writable for WDATA { } # [ doc = "UART write data" ]
pub mod wdata { # [ doc = "Writer for register WDATA" ]
pub type W = crate :: W < u8 , super :: WDATA > ; # [ doc = "Register WDATA `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: WDATA { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl W { } } # [ doc = "UART FIFO control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_ctrl](fifo_ctrl) module" ]
pub type FIFO_CTRL = crate :: Reg < u32 , _FIFO_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _FIFO_CTRL ; # [ doc = "`read()` method returns [fifo_ctrl::R](fifo_ctrl::R) reader structure" ]
impl crate :: Readable for FIFO_CTRL { } # [ doc = "`write(|w| ..)` method takes [fifo_ctrl::W](fifo_ctrl::W) writer structure" ]
impl crate :: Writable for FIFO_CTRL { } # [ doc = "UART FIFO control register" ]
pub mod fifo_ctrl { # [ doc = "Reader of register FIFO_CTRL" ]
pub type R = crate :: R < u32 , super :: FIFO_CTRL > ; # [ doc = "Writer for register FIFO_CTRL" ]
pub type W = crate :: W < u32 , super :: FIFO_CTRL > ; # [ doc = "Register FIFO_CTRL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: FIFO_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `RXRST`" ]
pub struct RXRST_W < 'a > { w : & 'a mut W , } impl < 'a > RXRST_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `TXRST`" ]
pub struct TXRST_W < 'a > { w : & 'a mut W , } impl < 'a > TXRST_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXILVL`" ]
pub type RXILVL_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `RXILVL`" ]
pub struct RXILVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXILVL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `TXILVL`" ]
pub type TXILVL_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `TXILVL`" ]
pub struct TXILVL_W < 'a > { w : & 'a mut W , } impl < 'a > TXILVL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } } impl R { # [ doc = "Bits 2:4 - Trigger level for RX interrupts. If the FIFO depth is greater than or equal to the setting, it raises rx_watermark interrupt." ]
# [ inline ( always ) ]
pub fn rxilvl ( & self ) -> RXILVL_R { RXILVL_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bits 5:6 - Trigger level for TX interrupts. If the FIFO depth is greater than or equal to the setting, it raises tx_watermark interrupt." ]
# [ inline ( always ) ]
pub fn txilvl ( & self ) -> TXILVL_R { TXILVL_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0" ]
# [ inline ( always ) ]
pub fn rxrst ( & mut self ) -> RXRST_W { RXRST_W { w : self } } # [ doc = "Bit 1 - TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0" ]
# [ inline ( always ) ]
pub fn txrst ( & mut self ) -> TXRST_W { TXRST_W { w : self } } # [ doc = "Bits 2:4 - Trigger level for RX interrupts. If the FIFO depth is greater than or equal to the setting, it raises rx_watermark interrupt." ]
# [ inline ( always ) ]
pub fn rxilvl ( & mut self ) -> RXILVL_W { RXILVL_W { w : self } } # [ doc = "Bits 5:6 - Trigger level for TX interrupts. If the FIFO depth is greater than or equal to the setting, it raises tx_watermark interrupt." ]
# [ inline ( always ) ]
pub fn txilvl ( & mut self ) -> TXILVL_W { TXILVL_W { w : self } } } } # [ doc = "UART FIFO status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_status](fifo_status) module" ]
pub type FIFO_STATUS = crate :: Reg < u32 , _FIFO_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _FIFO_STATUS ; # [ doc = "`read()` method returns [fifo_status::R](fifo_status::R) reader structure" ]
impl crate :: Readable for FIFO_STATUS { } # [ doc = "UART FIFO status register" ]
pub mod fifo_status { # [ doc = "Reader of register FIFO_STATUS" ]
pub type R = crate :: R < u32 , super :: FIFO_STATUS > ; # [ doc = "Reader of field `TXLVL`" ]
pub type TXLVL_R = crate :: R < u8 , u8 > ; # [ doc = "Reader of field `RXLVL`" ]
pub type RXLVL_R = crate :: R < u8 , u8 > ; impl R { # [ doc = "Bits 0:5 - Current fill level of TX fifo" ]
# [ inline ( always ) ]
pub fn txlvl ( & self ) -> TXLVL_R { TXLVL_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 16:21 - Current fill level of RX fifo" ]
# [ inline ( always ) ]
pub fn rxlvl ( & self ) -> RXLVL_R { RXLVL_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) } } } # [ doc = "TX pin override control. Gives direct SW control over TX pin state\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ovrd](ovrd) module" ]
pub type OVRD = crate :: Reg < u32 , _OVRD > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _OVRD ; # [ doc = "`read()` method returns [ovrd::R](ovrd::R) reader structure" ]
impl crate :: Readable for OVRD { } # [ doc = "`write(|w| ..)` method takes [ovrd::W](ovrd::W) writer structure" ]
impl crate :: Writable for OVRD { } # [ doc = "TX pin override control. Gives direct SW control over TX pin state" ]
pub mod ovrd { # [ doc = "Reader of register OVRD" ]
pub type R = crate :: R < u32 , super :: OVRD > ; # [ doc = "Writer for register OVRD" ]
pub type W = crate :: W < u32 , super :: OVRD > ; # [ doc = "Register OVRD `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: OVRD { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `TXEN`" ]
pub type TXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXEN`" ]
pub struct TXEN_W < 'a > { w : & 'a mut W , } impl < 'a > TXEN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXVAL`" ]
pub type TXVAL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXVAL`" ]
pub struct TXVAL_W < 'a > { w : & 'a mut W , } impl < 'a > TXVAL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable TX pin override control" ]
# [ inline ( always ) ]
pub fn txen ( & self ) -> TXEN_R { TXEN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Write to set the value of the TX pin" ]
# [ inline ( always ) ]
pub fn txval ( & self ) -> TXVAL_R { TXVAL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable TX pin override control" ]
# [ inline ( always ) ]
pub fn txen ( & mut self ) -> TXEN_W { TXEN_W { w : self } } # [ doc = "Bit 1 - Write to set the value of the TX pin" ]
# [ inline ( always ) ]
pub fn txval ( & mut self ) -> TXVAL_W { TXVAL_W { w : self } } } } # [ doc = "UART oversampled values\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [val](val) module" ]
pub type VAL = crate :: Reg < u32 , _VAL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _VAL ; # [ doc = "`read()` method returns [val::R](val::R) reader structure" ]
impl crate :: Readable for VAL { } # [ doc = "UART oversampled values" ]
pub mod val { # [ doc = "Reader of register VAL" ]
pub type R = crate :: R < u32 , super :: VAL > ; # [ doc = "Reader of field `RX`" ]
pub type RX_R = crate :: R < u16 , u16 > ; impl R { # [ doc = "Bits 0:15 - Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15." ]
# [ inline ( always ) ]
pub fn rx ( & self ) -> RX_R { RX_R :: new ( ( self . bits & 0xffff ) as u16 ) } } } # [ doc = "UART RX timeout control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timeout_ctrl](timeout_ctrl) module" ]
pub type TIMEOUT_CTRL = crate :: Reg < u32 , _TIMEOUT_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TIMEOUT_CTRL ; # [ doc = "`read()` method returns [timeout_ctrl::R](timeout_ctrl::R) reader structure" ]
impl crate :: Readable for TIMEOUT_CTRL { } # [ doc = "`write(|w| ..)` method takes [timeout_ctrl::W](timeout_ctrl::W) writer structure" ]
impl crate :: Writable for TIMEOUT_CTRL { } # [ doc = "UART RX timeout control" ]
pub mod timeout_ctrl { # [ doc = "Reader of register TIMEOUT_CTRL" ]
pub type R = crate :: R < u32 , super :: TIMEOUT_CTRL > ; # [ doc = "Writer for register TIMEOUT_CTRL" ]
pub type W = crate :: W < u32 , super :: TIMEOUT_CTRL > ; # [ doc = "Register TIMEOUT_CTRL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: TIMEOUT_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `VAL`" ]
pub type VAL_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `VAL`" ]
pub struct VAL_W < 'a > { w : & 'a mut W , } impl < 'a > VAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } } # [ doc = "Reader of field `EN`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } } impl R { # [ doc = "Bits 0:23 - RX timeout value in UART bit times" ]
# [ inline ( always ) ]
pub fn val ( & self ) -> VAL_R { VAL_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) } # [ doc = "Bit 31 - Enable RX timeout feature" ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:23 - RX timeout value in UART bit times" ]
# [ inline ( always ) ]
pub fn val ( & mut self ) -> VAL_W { VAL_W { w : self } } # [ doc = "Bit 31 - Enable RX timeout feature" ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } } } } # [ doc = "gpio" ]
pub struct GPIO { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO { } impl GPIO { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const gpio :: RegisterBlock { 0x4001_0000 as * const _ } } impl Deref for GPIO { type Target = gpio :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * GPIO :: ptr ( ) } } } # [ doc = "gpio" ]
pub mod gpio { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - GPIO Input data read value" ]
pub data_in : DATA_IN , # [ doc = "0x10 - GPIO direct output data write value" ]
pub direct_out : DIRECT_OUT , # [ doc = "0x14 - GPIO write data lower with mask. Masked write for DATA_OUT\\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[15:0\\]." ]
pub masked_out_lower : MASKED_OUT_LOWER , # [ doc = "0x18 - GPIO write data upper with mask. Masked write for DATA_OUT\\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[31:16\\]." ]
pub masked_out_upper : MASKED_OUT_UPPER , # [ doc = "0x1c - GPIO Output Enable. Setting direct_oe\\[i\\]
to 1 enables output mode for GPIO\\[i\\]" ]
pub direct_oe : DIRECT_OE , # [ doc = "0x20 - GPIO write Output Enable lower with mask. Masked write for DATA_OE\\[15:0\\], the register that controls output mode for GPIO pins \\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[15:0\\]." ]
pub masked_oe_lower : MASKED_OE_LOWER , # [ doc = "0x24 - GPIO write Output Enable upper with mask. Masked write for DATA_OE\\[31:16\\], the register that controls output mode for GPIO pins \\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[31:16\\]." ]
pub masked_oe_upper : MASKED_OE_UPPER , # [ doc = "0x28 - GPIO interrupt enable for GPIO, rising edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_RISING\\[i\\]
enables rising-edge interrupt detection on GPIO\\[i\\]." ]
pub intr_ctrl_en_rising : INTR_CTRL_EN_RISING , # [ doc = "0x2c - GPIO interrupt enable for GPIO, falling edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_FALLING\\[i\\]
enables falling-edge interrupt detection on GPIO\\[i\\]." ]
pub intr_ctrl_en_falling : INTR_CTRL_EN_FALLING , # [ doc = "0x30 - GPIO interrupt enable for GPIO, level high. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLHIGH\\[i\\]
enables level high interrupt detection on GPIO\\[i\\]." ]
pub intr_ctrl_en_lvlhigh : INTR_CTRL_EN_LVLHIGH , # [ doc = "0x34 - GPIO interrupt enable for GPIO, level low. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLLOW\\[i\\]
enables level low interrupt detection on GPIO\\[i\\]." ]
pub intr_ctrl_en_lvllow : INTR_CTRL_EN_LVLLOW , # [ doc = "0x38 - filter enable for GPIO input bits. If !!CTRL_EN_INPUT_FILTER\\[i\\]
is true, a value of input bit \\[i\\]
must be stable for 16 cycles before transitioning." ]
pub ctrl_en_input_filter : CTRL_EN_INPUT_FILTER , } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `gpio`" ]
pub type GPIO_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `gpio`" ]
pub struct GPIO_W < 'a > { w : & 'a mut W , } impl < 'a > GPIO_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - raised if any of GPIO pin detects configured interrupt mode" ]
# [ inline ( always ) ]
pub fn gpio ( & self ) -> GPIO_R { GPIO_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - raised if any of GPIO pin detects configured interrupt mode" ]
# [ inline ( always ) ]
pub fn gpio ( & mut self ) -> GPIO_W { GPIO_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `gpio`" ]
pub type GPIO_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `gpio`" ]
pub struct GPIO_W < 'a > { w : & 'a mut W , } impl < 'a > GPIO_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Enable interrupt when corresponding bit in !!INTR_STATE.gpio is set" ]
# [ inline ( always ) ]
pub fn gpio ( & self ) -> GPIO_R { GPIO_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Enable interrupt when corresponding bit in !!INTR_STATE.gpio is set" ]
# [ inline ( always ) ]
pub fn gpio ( & mut self ) -> GPIO_W { GPIO_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `gpio`" ]
pub struct GPIO_W < 'a > { w : & 'a mut W , } impl < 'a > GPIO_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Write 1 to force corresponding bit in !!INTR_STATE.gpio to 1" ]
# [ inline ( always ) ]
pub fn gpio ( & mut self ) -> GPIO_W { GPIO_W { w : self } } } } # [ doc = "GPIO Input data read value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in](data_in) module" ]
pub type DATA_IN = crate :: Reg < u32 , _DATA_IN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_IN ; # [ doc = "`read()` method returns [data_in::R](data_in::R) reader structure" ]
impl crate :: Readable for DATA_IN { } # [ doc = "GPIO Input data read value" ]
pub mod data_in { # [ doc = "Reader of register DATA_IN" ]
pub type R = crate :: R < u32 , super :: DATA_IN > ; impl R { } } # [ doc = "GPIO direct output data write value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [direct_out](direct_out) module" ]
pub type DIRECT_OUT = crate :: Reg < u32 , _DIRECT_OUT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIRECT_OUT ; # [ doc = "`read()` method returns [direct_out::R](direct_out::R) reader structure" ]
impl crate :: Readable for DIRECT_OUT { } # [ doc = "`write(|w| ..)` method takes [direct_out::W](direct_out::W) writer structure" ]
impl crate :: Writable for DIRECT_OUT { } # [ doc = "GPIO direct output data write value" ]
pub mod direct_out { # [ doc = "Reader of register DIRECT_OUT" ]
pub type R = crate :: R < u32 , super :: DIRECT_OUT > ; # [ doc = "Writer for register DIRECT_OUT" ]
pub type W = crate :: W < u32 , super :: DIRECT_OUT > ; # [ doc = "Register DIRECT_OUT `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DIRECT_OUT { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "GPIO write data lower with mask. Masked write for DATA_OUT\\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[15:0\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [masked_out_lower](masked_out_lower) module" ]
pub type MASKED_OUT_LOWER = crate :: Reg < u32 , _MASKED_OUT_LOWER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MASKED_OUT_LOWER ; # [ doc = "`read()` method returns [masked_out_lower::R](masked_out_lower::R) reader structure" ]
impl crate :: Readable for MASKED_OUT_LOWER { } # [ doc = "`write(|w| ..)` method takes [masked_out_lower::W](masked_out_lower::W) writer structure" ]
impl crate :: Writable for MASKED_OUT_LOWER { } # [ doc = "GPIO write data lower with mask. Masked write for DATA_OUT\\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[15:0\\]." ]
pub mod masked_out_lower { # [ doc = "Reader of register MASKED_OUT_LOWER" ]
pub type R = crate :: R < u32 , super :: MASKED_OUT_LOWER > ; # [ doc = "Writer for register MASKED_OUT_LOWER" ]
pub type W = crate :: W < u32 , super :: MASKED_OUT_LOWER > ; # [ doc = "Register MASKED_OUT_LOWER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MASKED_OUT_LOWER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `data`" ]
pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `data`" ]
pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Write proxy for field `mask`" ]
pub struct MASK_W < 'a > { w : & 'a mut W , } impl < 'a > MASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Write data value\\[15:0\\]. Value to write into DATA_OUT\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Write data value\\[15:0\\]. Value to write into DATA_OUT\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } # [ doc = "Bits 16:31 - Write data mask\\[15:0\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OUT\\[i\\], 0 <= i <= 15" ]
# [ inline ( always ) ]
pub fn mask ( & mut self ) -> MASK_W { MASK_W { w : self } } } } # [ doc = "GPIO write data upper with mask. Masked write for DATA_OUT\\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[31:16\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [masked_out_upper](masked_out_upper) module" ]
pub type MASKED_OUT_UPPER = crate :: Reg < u32 , _MASKED_OUT_UPPER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MASKED_OUT_UPPER ; # [ doc = "`read()` method returns [masked_out_upper::R](masked_out_upper::R) reader structure" ]
impl crate :: Readable for MASKED_OUT_UPPER { } # [ doc = "`write(|w| ..)` method takes [masked_out_upper::W](masked_out_upper::W) writer structure" ]
impl crate :: Writable for MASKED_OUT_UPPER { } # [ doc = "GPIO write data upper with mask. Masked write for DATA_OUT\\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OUT\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OUT\\[31:16\\]." ]
pub mod masked_out_upper { # [ doc = "Reader of register MASKED_OUT_UPPER" ]
pub type R = crate :: R < u32 , super :: MASKED_OUT_UPPER > ; # [ doc = "Writer for register MASKED_OUT_UPPER" ]
pub type W = crate :: W < u32 , super :: MASKED_OUT_UPPER > ; # [ doc = "Register MASKED_OUT_UPPER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MASKED_OUT_UPPER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `data`" ]
pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `data`" ]
pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Write proxy for field `mask`" ]
pub struct MASK_W < 'a > { w : & 'a mut W , } impl < 'a > MASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Write data value\\[31:16\\]. Value to write into DATA_OUT\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Write data value\\[31:16\\]. Value to write into DATA_OUT\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } # [ doc = "Bits 16:31 - Write data mask\\[31:16\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OUT\\[i\\], 16 <= i <= 31" ]
# [ inline ( always ) ]
pub fn mask ( & mut self ) -> MASK_W { MASK_W { w : self } } } } # [ doc = "GPIO Output Enable. Setting direct_oe\\[i\\]
to 1 enables output mode for GPIO\\[i\\]\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [direct_oe](direct_oe) module" ]
pub type DIRECT_OE = crate :: Reg < u32 , _DIRECT_OE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIRECT_OE ; # [ doc = "`read()` method returns [direct_oe::R](direct_oe::R) reader structure" ]
impl crate :: Readable for DIRECT_OE { } # [ doc = "`write(|w| ..)` method takes [direct_oe::W](direct_oe::W) writer structure" ]
impl crate :: Writable for DIRECT_OE { } # [ doc = "GPIO Output Enable. Setting direct_oe\\[i\\]
to 1 enables output mode for GPIO\\[i\\]" ]
pub mod direct_oe { # [ doc = "Reader of register DIRECT_OE" ]
pub type R = crate :: R < u32 , super :: DIRECT_OE > ; # [ doc = "Writer for register DIRECT_OE" ]
pub type W = crate :: W < u32 , super :: DIRECT_OE > ; # [ doc = "Register DIRECT_OE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DIRECT_OE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "GPIO write Output Enable lower with mask. Masked write for DATA_OE\\[15:0\\], the register that controls output mode for GPIO pins \\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[15:0\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [masked_oe_lower](masked_oe_lower) module" ]
pub type MASKED_OE_LOWER = crate :: Reg < u32 , _MASKED_OE_LOWER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MASKED_OE_LOWER ; # [ doc = "`read()` method returns [masked_oe_lower::R](masked_oe_lower::R) reader structure" ]
impl crate :: Readable for MASKED_OE_LOWER { } # [ doc = "`write(|w| ..)` method takes [masked_oe_lower::W](masked_oe_lower::W) writer structure" ]
impl crate :: Writable for MASKED_OE_LOWER { } # [ doc = "GPIO write Output Enable lower with mask. Masked write for DATA_OE\\[15:0\\], the register that controls output mode for GPIO pins \\[15:0\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[15:0\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[15:0\\]." ]
pub mod masked_oe_lower { # [ doc = "Reader of register MASKED_OE_LOWER" ]
pub type R = crate :: R < u32 , super :: MASKED_OE_LOWER > ; # [ doc = "Writer for register MASKED_OE_LOWER" ]
pub type W = crate :: W < u32 , super :: MASKED_OE_LOWER > ; # [ doc = "Register MASKED_OE_LOWER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MASKED_OE_LOWER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `data`" ]
pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `data`" ]
pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `mask`" ]
pub type MASK_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `mask`" ]
pub struct MASK_W < 'a > { w : & 'a mut W , } impl < 'a > MASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Write OE value\\[15:0\\]. Value to write into DATA_OE\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Write OE mask\\[15:0\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OE\\[i\\], 0 <= i <= 15" ]
# [ inline ( always ) ]
pub fn mask ( & self ) -> MASK_R { MASK_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Write OE value\\[15:0\\]. Value to write into DATA_OE\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } # [ doc = "Bits 16:31 - Write OE mask\\[15:0\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OE\\[i\\], 0 <= i <= 15" ]
# [ inline ( always ) ]
pub fn mask ( & mut self ) -> MASK_W { MASK_W { w : self } } } } # [ doc = "GPIO write Output Enable upper with mask. Masked write for DATA_OE\\[31:16\\], the register that controls output mode for GPIO pins \\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[31:16\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [masked_oe_upper](masked_oe_upper) module" ]
pub type MASKED_OE_UPPER = crate :: Reg < u32 , _MASKED_OE_UPPER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MASKED_OE_UPPER ; # [ doc = "`read()` method returns [masked_oe_upper::R](masked_oe_upper::R) reader structure" ]
impl crate :: Readable for MASKED_OE_UPPER { } # [ doc = "`write(|w| ..)` method takes [masked_oe_upper::W](masked_oe_upper::W) writer structure" ]
impl crate :: Writable for MASKED_OE_UPPER { } # [ doc = "GPIO write Output Enable upper with mask. Masked write for DATA_OE\\[31:16\\], the register that controls output mode for GPIO pins \\[31:16\\]. Upper 16 bits of this register are used as mask. Writing lower 16 bits of the register changes DATA_OE\\[31:16\\]
value if mask bits are set. Read-back of this register returns upper 16 bits as zero and lower 16 bits as DATA_OE\\[31:16\\]." ]
pub mod masked_oe_upper { # [ doc = "Reader of register MASKED_OE_UPPER" ]
pub type R = crate :: R < u32 , super :: MASKED_OE_UPPER > ; # [ doc = "Writer for register MASKED_OE_UPPER" ]
pub type W = crate :: W < u32 , super :: MASKED_OE_UPPER > ; # [ doc = "Register MASKED_OE_UPPER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MASKED_OE_UPPER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `data`" ]
pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `data`" ]
pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `mask`" ]
pub type MASK_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `mask`" ]
pub struct MASK_W < 'a > { w : & 'a mut W , } impl < 'a > MASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Write OE value\\[31:16\\]. Value to write into DATA_OE\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Write OE mask\\[31:16\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OE\\[i\\], 16 <= i <= 31" ]
# [ inline ( always ) ]
pub fn mask ( & self ) -> MASK_R { MASK_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Write OE value\\[31:16\\]. Value to write into DATA_OE\\[i\\], valid in the presence of mask\\[i\\]==1" ]
# [ inline ( always ) ]
pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } # [ doc = "Bits 16:31 - Write OE mask\\[31:16\\]. A value of 1 in mask\\[i\\]
allows the updating of DATA_OE\\[i\\], 16 <= i <= 31" ]
# [ inline ( always ) ]
pub fn mask ( & mut self ) -> MASK_W { MASK_W { w : self } } } } # [ doc = "GPIO interrupt enable for GPIO, rising edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_RISING\\[i\\]
enables rising-edge interrupt detection on GPIO\\[i\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_ctrl_en_rising](intr_ctrl_en_rising) module" ]
pub type INTR_CTRL_EN_RISING = crate :: Reg < u32 , _INTR_CTRL_EN_RISING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_CTRL_EN_RISING ; # [ doc = "`read()` method returns [intr_ctrl_en_rising::R](intr_ctrl_en_rising::R) reader structure" ]
impl crate :: Readable for INTR_CTRL_EN_RISING { } # [ doc = "`write(|w| ..)` method takes [intr_ctrl_en_rising::W](intr_ctrl_en_rising::W) writer structure" ]
impl crate :: Writable for INTR_CTRL_EN_RISING { } # [ doc = "GPIO interrupt enable for GPIO, rising edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_RISING\\[i\\]
enables rising-edge interrupt detection on GPIO\\[i\\]." ]
pub mod intr_ctrl_en_rising { # [ doc = "Reader of register INTR_CTRL_EN_RISING" ]
pub type R = crate :: R < u32 , super :: INTR_CTRL_EN_RISING > ; # [ doc = "Writer for register INTR_CTRL_EN_RISING" ]
pub type W = crate :: W < u32 , super :: INTR_CTRL_EN_RISING > ; # [ doc = "Register INTR_CTRL_EN_RISING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_CTRL_EN_RISING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "GPIO interrupt enable for GPIO, falling edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_FALLING\\[i\\]
enables falling-edge interrupt detection on GPIO\\[i\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_ctrl_en_falling](intr_ctrl_en_falling) module" ]
pub type INTR_CTRL_EN_FALLING = crate :: Reg < u32 , _INTR_CTRL_EN_FALLING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_CTRL_EN_FALLING ; # [ doc = "`read()` method returns [intr_ctrl_en_falling::R](intr_ctrl_en_falling::R) reader structure" ]
impl crate :: Readable for INTR_CTRL_EN_FALLING { } # [ doc = "`write(|w| ..)` method takes [intr_ctrl_en_falling::W](intr_ctrl_en_falling::W) writer structure" ]
impl crate :: Writable for INTR_CTRL_EN_FALLING { } # [ doc = "GPIO interrupt enable for GPIO, falling edge. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_FALLING\\[i\\]
enables falling-edge interrupt detection on GPIO\\[i\\]." ]
pub mod intr_ctrl_en_falling { # [ doc = "Reader of register INTR_CTRL_EN_FALLING" ]
pub type R = crate :: R < u32 , super :: INTR_CTRL_EN_FALLING > ; # [ doc = "Writer for register INTR_CTRL_EN_FALLING" ]
pub type W = crate :: W < u32 , super :: INTR_CTRL_EN_FALLING > ; # [ doc = "Register INTR_CTRL_EN_FALLING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_CTRL_EN_FALLING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "GPIO interrupt enable for GPIO, level high. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLHIGH\\[i\\]
enables level high interrupt detection on GPIO\\[i\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_ctrl_en_lvlhigh](intr_ctrl_en_lvlhigh) module" ]
pub type INTR_CTRL_EN_LVLHIGH = crate :: Reg < u32 , _INTR_CTRL_EN_LVLHIGH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_CTRL_EN_LVLHIGH ; # [ doc = "`read()` method returns [intr_ctrl_en_lvlhigh::R](intr_ctrl_en_lvlhigh::R) reader structure" ]
impl crate :: Readable for INTR_CTRL_EN_LVLHIGH { } # [ doc = "`write(|w| ..)` method takes [intr_ctrl_en_lvlhigh::W](intr_ctrl_en_lvlhigh::W) writer structure" ]
impl crate :: Writable for INTR_CTRL_EN_LVLHIGH { } # [ doc = "GPIO interrupt enable for GPIO, level high. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLHIGH\\[i\\]
enables level high interrupt detection on GPIO\\[i\\]." ]
pub mod intr_ctrl_en_lvlhigh { # [ doc = "Reader of register INTR_CTRL_EN_LVLHIGH" ]
pub type R = crate :: R < u32 , super :: INTR_CTRL_EN_LVLHIGH > ; # [ doc = "Writer for register INTR_CTRL_EN_LVLHIGH" ]
pub type W = crate :: W < u32 , super :: INTR_CTRL_EN_LVLHIGH > ; # [ doc = "Register INTR_CTRL_EN_LVLHIGH `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_CTRL_EN_LVLHIGH { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "GPIO interrupt enable for GPIO, level low. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLLOW\\[i\\]
enables level low interrupt detection on GPIO\\[i\\].\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_ctrl_en_lvllow](intr_ctrl_en_lvllow) module" ]
pub type INTR_CTRL_EN_LVLLOW = crate :: Reg < u32 , _INTR_CTRL_EN_LVLLOW > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_CTRL_EN_LVLLOW ; # [ doc = "`read()` method returns [intr_ctrl_en_lvllow::R](intr_ctrl_en_lvllow::R) reader structure" ]
impl crate :: Readable for INTR_CTRL_EN_LVLLOW { } # [ doc = "`write(|w| ..)` method takes [intr_ctrl_en_lvllow::W](intr_ctrl_en_lvllow::W) writer structure" ]
impl crate :: Writable for INTR_CTRL_EN_LVLLOW { } # [ doc = "GPIO interrupt enable for GPIO, level low. If !!INTR_ENABLE\\[i\\]
is true, a value of 1 on !!INTR_CTRL_EN_LVLLOW\\[i\\]
enables level low interrupt detection on GPIO\\[i\\]." ]
pub mod intr_ctrl_en_lvllow { # [ doc = "Reader of register INTR_CTRL_EN_LVLLOW" ]
pub type R = crate :: R < u32 , super :: INTR_CTRL_EN_LVLLOW > ; # [ doc = "Writer for register INTR_CTRL_EN_LVLLOW" ]
pub type W = crate :: W < u32 , super :: INTR_CTRL_EN_LVLLOW > ; # [ doc = "Register INTR_CTRL_EN_LVLLOW `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_CTRL_EN_LVLLOW { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "filter enable for GPIO input bits. If !!CTRL_EN_INPUT_FILTER\\[i\\]
is true, a value of input bit \\[i\\]
must be stable for 16 cycles before transitioning.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl_en_input_filter](ctrl_en_input_filter) module" ]
pub type CTRL_EN_INPUT_FILTER = crate :: Reg < u32 , _CTRL_EN_INPUT_FILTER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CTRL_EN_INPUT_FILTER ; # [ doc = "`read()` method returns [ctrl_en_input_filter::R](ctrl_en_input_filter::R) reader structure" ]
impl crate :: Readable for CTRL_EN_INPUT_FILTER { } # [ doc = "`write(|w| ..)` method takes [ctrl_en_input_filter::W](ctrl_en_input_filter::W) writer structure" ]
impl crate :: Writable for CTRL_EN_INPUT_FILTER { } # [ doc = "filter enable for GPIO input bits. If !!CTRL_EN_INPUT_FILTER\\[i\\]
is true, a value of input bit \\[i\\]
must be stable for 16 cycles before transitioning." ]
pub mod ctrl_en_input_filter { # [ doc = "Reader of register CTRL_EN_INPUT_FILTER" ]
pub type R = crate :: R < u32 , super :: CTRL_EN_INPUT_FILTER > ; # [ doc = "Writer for register CTRL_EN_INPUT_FILTER" ]
pub type W = crate :: W < u32 , super :: CTRL_EN_INPUT_FILTER > ; # [ doc = "Register CTRL_EN_INPUT_FILTER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CTRL_EN_INPUT_FILTER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } } # [ doc = "spi_device" ]
pub struct SPI_DEVICE { _marker : PhantomData < * const ( ) > } unsafe impl Send for SPI_DEVICE { } impl SPI_DEVICE { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const spi_device :: RegisterBlock { 0x4002_0000 as * const _ } } impl Deref for SPI_DEVICE { type Target = spi_device :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * SPI_DEVICE :: ptr ( ) } } } # [ doc = "spi_device" ]
pub mod spi_device { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - Control register" ]
pub control : CONTROL , # [ doc = "0x10 - Configuration Register" ]
pub cfg : CFG , # [ doc = "0x14 - RX/ TX FIFO levels." ]
pub fifo_level : FIFO_LEVEL , # [ doc = "0x18 - RX/ TX Async FIFO levels between main clk and spi clock" ]
pub async_fifo_level : ASYNC_FIFO_LEVEL , # [ doc = "0x1c - SPI Device status register" ]
pub status : STATUS , # [ doc = "0x20 - Receiver FIFO (SRAM) pointers" ]
pub rxf_ptr : RXF_PTR , # [ doc = "0x24 - Transmitter FIFO (SRAM) pointers" ]
pub txf_ptr : TXF_PTR , # [ doc = "0x28 - Receiver FIFO (SRAM) Addresses" ]
pub rxf_addr : RXF_ADDR , # [ doc = "0x2c - Transmitter FIFO (SRAM) Addresses" ]
pub txf_addr : TXF_ADDR , _reserved12 : [ u8 ; 2000usize ]
, # [ doc = "0x800 - SPI internal 2kB buffer. This buffer is shared by RX and TX circular buffer together." ]
pub buffer : [ BUFFER ; 512 ]
, } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `rxf`" ]
pub type RXF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxf`" ]
pub struct RXF_W < 'a > { w : & 'a mut W , } impl < 'a > RXF_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `rxlvl`" ]
pub type RXLVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxlvl`" ]
pub struct RXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `txlvl`" ]
pub type TXLVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `txlvl`" ]
pub struct TXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > TXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rxerr`" ]
pub type RXERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxerr`" ]
pub struct RXERR_W < 'a > { w : & 'a mut W , } impl < 'a > RXERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `rxoverflow`" ]
pub type RXOVERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxoverflow`" ]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `txunderflow`" ]
pub type TXUNDERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `txunderflow`" ]
pub struct TXUNDERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXUNDERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - RX SRAM FIFO Full" ]
# [ inline ( always ) ]
pub fn rxf ( & self ) -> RXF_R { RXF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - RX SRAM FIFO is above the level" ]
# [ inline ( always ) ]
pub fn rxlvl ( & self ) -> RXLVL_R { RXLVL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - TX SRAM FIFO is under the level" ]
# [ inline ( always ) ]
pub fn txlvl ( & self ) -> TXLVL_R { TXLVL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - MOSI in FwMode has error" ]
# [ inline ( always ) ]
pub fn rxerr ( & self ) -> RXERR_R { RXERR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - RX Async FIFO overflow" ]
# [ inline ( always ) ]
pub fn rxoverflow ( & self ) -> RXOVERFLOW_R { RXOVERFLOW_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - TX Async FIFO underflow" ]
# [ inline ( always ) ]
pub fn txunderflow ( & self ) -> TXUNDERFLOW_R { TXUNDERFLOW_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - RX SRAM FIFO Full" ]
# [ inline ( always ) ]
pub fn rxf ( & mut self ) -> RXF_W { RXF_W { w : self } } # [ doc = "Bit 1 - RX SRAM FIFO is above the level" ]
# [ inline ( always ) ]
pub fn rxlvl ( & mut self ) -> RXLVL_W { RXLVL_W { w : self } } # [ doc = "Bit 2 - TX SRAM FIFO is under the level" ]
# [ inline ( always ) ]
pub fn txlvl ( & mut self ) -> TXLVL_W { TXLVL_W { w : self } } # [ doc = "Bit 3 - MOSI in FwMode has error" ]
# [ inline ( always ) ]
pub fn rxerr ( & mut self ) -> RXERR_W { RXERR_W { w : self } } # [ doc = "Bit 4 - RX Async FIFO overflow" ]
# [ inline ( always ) ]
pub fn rxoverflow ( & mut self ) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [ doc = "Bit 5 - TX Async FIFO underflow" ]
# [ inline ( always ) ]
pub fn txunderflow ( & mut self ) -> TXUNDERFLOW_W { TXUNDERFLOW_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `rxf`" ]
pub type RXF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxf`" ]
pub struct RXF_W < 'a > { w : & 'a mut W , } impl < 'a > RXF_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `rxlvl`" ]
pub type RXLVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxlvl`" ]
pub struct RXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `txlvl`" ]
pub type TXLVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `txlvl`" ]
pub struct TXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > TXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rxerr`" ]
pub type RXERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxerr`" ]
pub struct RXERR_W < 'a > { w : & 'a mut W , } impl < 'a > RXERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `rxoverflow`" ]
pub type RXOVERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rxoverflow`" ]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `txunderflow`" ]
pub type TXUNDERFLOW_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `txunderflow`" ]
pub struct TXUNDERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXUNDERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.rxf is set" ]
# [ inline ( always ) ]
pub fn rxf ( & self ) -> RXF_R { RXF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.rxlvl is set" ]
# [ inline ( always ) ]
pub fn rxlvl ( & self ) -> RXLVL_R { RXLVL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.txlvl is set" ]
# [ inline ( always ) ]
pub fn txlvl ( & self ) -> TXLVL_R { TXLVL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rxerr is set" ]
# [ inline ( always ) ]
pub fn rxerr ( & self ) -> RXERR_R { RXERR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.rxoverflow is set" ]
# [ inline ( always ) ]
pub fn rxoverflow ( & self ) -> RXOVERFLOW_R { RXOVERFLOW_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.txunderflow is set" ]
# [ inline ( always ) ]
pub fn txunderflow ( & self ) -> TXUNDERFLOW_R { TXUNDERFLOW_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.rxf is set" ]
# [ inline ( always ) ]
pub fn rxf ( & mut self ) -> RXF_W { RXF_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.rxlvl is set" ]
# [ inline ( always ) ]
pub fn rxlvl ( & mut self ) -> RXLVL_W { RXLVL_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.txlvl is set" ]
# [ inline ( always ) ]
pub fn txlvl ( & mut self ) -> TXLVL_W { TXLVL_W { w : self } } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rxerr is set" ]
# [ inline ( always ) ]
pub fn rxerr ( & mut self ) -> RXERR_W { RXERR_W { w : self } } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.rxoverflow is set" ]
# [ inline ( always ) ]
pub fn rxoverflow ( & mut self ) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.txunderflow is set" ]
# [ inline ( always ) ]
pub fn txunderflow ( & mut self ) -> TXUNDERFLOW_W { TXUNDERFLOW_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `rxf`" ]
pub struct RXF_W < 'a > { w : & 'a mut W , } impl < 'a > RXF_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `rxlvl`" ]
pub struct RXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `txlvl`" ]
pub struct TXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > TXLVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `rxerr`" ]
pub struct RXERR_W < 'a > { w : & 'a mut W , } impl < 'a > RXERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Write proxy for field `rxoverflow`" ]
pub struct RXOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RXOVERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Write proxy for field `txunderflow`" ]
pub struct TXUNDERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > TXUNDERFLOW_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.rxf to 1" ]
# [ inline ( always ) ]
pub fn rxf ( & mut self ) -> RXF_W { RXF_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.rxlvl to 1" ]
# [ inline ( always ) ]
pub fn rxlvl ( & mut self ) -> RXLVL_W { RXLVL_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.txlvl to 1" ]
# [ inline ( always ) ]
pub fn txlvl ( & mut self ) -> TXLVL_W { TXLVL_W { w : self } } # [ doc = "Bit 3 - Write 1 to force !!INTR_STATE.rxerr to 1" ]
# [ inline ( always ) ]
pub fn rxerr ( & mut self ) -> RXERR_W { RXERR_W { w : self } } # [ doc = "Bit 4 - Write 1 to force !!INTR_STATE.rxoverflow to 1" ]
# [ inline ( always ) ]
pub fn rxoverflow ( & mut self ) -> RXOVERFLOW_W { RXOVERFLOW_W { w : self } } # [ doc = "Bit 5 - Write 1 to force !!INTR_STATE.txunderflow to 1" ]
# [ inline ( always ) ]
pub fn txunderflow ( & mut self ) -> TXUNDERFLOW_W { TXUNDERFLOW_W { w : self } } } } # [ doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](control) module" ]
pub type CONTROL = crate :: Reg < u32 , _CONTROL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CONTROL ; # [ doc = "`read()` method returns [control::R](control::R) reader structure" ]
impl crate :: Readable for CONTROL { } # [ doc = "`write(|w| ..)` method takes [control::W](control::W) writer structure" ]
impl crate :: Writable for CONTROL { } # [ doc = "Control register" ]
pub mod control { # [ doc = "Reader of register CONTROL" ]
pub type R = crate :: R < u32 , super :: CONTROL > ; # [ doc = "Writer for register CONTROL" ]
pub type W = crate :: W < u32 , super :: CONTROL > ; # [ doc = "Register CONTROL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CONTROL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `ABORT`" ]
pub type ABORT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ABORT`" ]
pub struct ABORT_W < 'a > { w : & 'a mut W , } impl < 'a > ABORT_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `MODE`" ]
pub type MODE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MODE`" ]
pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `rst_txfifo`" ]
pub type RST_TXFIFO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rst_txfifo`" ]
pub struct RST_TXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RST_TXFIFO_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `rst_rxfifo`" ]
pub type RST_RXFIFO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rst_rxfifo`" ]
pub struct RST_RXFIFO_W < 'a > { w : & 'a mut W , } impl < 'a > RST_RXFIFO_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } impl R { # [ doc = "Bit 0 - Abort pending jobs. If TX_FIFO (async) is full, this command can let TXF Control logic back to Idle state" ]
# [ inline ( always ) ]
pub fn abort ( & self ) -> ABORT_R { ABORT_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bits 4:5 - SPI Device operation mode. Currently only FwMode is supported." ]
# [ inline ( always ) ]
pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 16 - Reset Async TX_FIFO. This only resets asynchronous fifo. If firmware wants to reset SRAM FIFO, it should write 0 into read/write pointers. _Note_: This value should be controlled only when SPI interface is in Idle state as this reset signal doesn't have reset synchronizer." ]
# [ inline ( always ) ]
pub fn rst_txfifo ( & self ) -> RST_TXFIFO_R { RST_TXFIFO_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Reset Async RX_FIFO. This only resets asynchronous fifo. If firmware wants to reset SRAM FIFO, it should write 0 into read pointer and write pointer. _Note_: This value should be controlled only when SPI interface is in Idle state as this reset signal doesn't have reset synchronizer." ]
# [ inline ( always ) ]
pub fn rst_rxfifo ( & self ) -> RST_RXFIFO_R { RST_RXFIFO_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Abort pending jobs. If TX_FIFO (async) is full, this command can let TXF Control logic back to Idle state" ]
# [ inline ( always ) ]
pub fn abort ( & mut self ) -> ABORT_W { ABORT_W { w : self } } # [ doc = "Bits 4:5 - SPI Device operation mode. Currently only FwMode is supported." ]
# [ inline ( always ) ]
pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 16 - Reset Async TX_FIFO. This only resets asynchronous fifo. If firmware wants to reset SRAM FIFO, it should write 0 into read/write pointers. _Note_: This value should be controlled only when SPI interface is in Idle state as this reset signal doesn't have reset synchronizer." ]
# [ inline ( always ) ]
pub fn rst_txfifo ( & mut self ) -> RST_TXFIFO_W { RST_TXFIFO_W { w : self } } # [ doc = "Bit 17 - Reset Async RX_FIFO. This only resets asynchronous fifo. If firmware wants to reset SRAM FIFO, it should write 0 into read pointer and write pointer. _Note_: This value should be controlled only when SPI interface is in Idle state as this reset signal doesn't have reset synchronizer." ]
# [ inline ( always ) ]
pub fn rst_rxfifo ( & mut self ) -> RST_RXFIFO_W { RST_RXFIFO_W { w : self } } } } # [ doc = "Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api)." ]
pub type CFG = crate :: Reg < u32 , _CFG > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CFG ; # [ doc = "`read()` method returns [cfg::R](cfg::R) reader structure" ]
impl crate :: Readable for CFG { } # [ doc = "`write(|w| ..)` method takes [cfg::W](cfg::W) writer structure" ]
impl crate :: Writable for CFG { } # [ doc = "Configuration Register" ]
pub mod cfg { # [ doc = "Reader of register CFG" ]
pub type R = crate :: R < u32 , super :: CFG > ; # [ doc = "Writer for register CFG" ]
pub type W = crate :: W < u32 , super :: CFG > ; # [ doc = "Register CFG `reset()`'s with value 0x7f00" ]
impl crate :: ResetValue for super :: CFG { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x7f00 } } # [ doc = "Reader of field `CPOL`" ]
pub type CPOL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CPOL`" ]
pub struct CPOL_W < 'a > { w : & 'a mut W , } impl < 'a > CPOL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `CPHA`" ]
pub type CPHA_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CPHA`" ]
pub struct CPHA_W < 'a > { w : & 'a mut W , } impl < 'a > CPHA_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `tx_order`" ]
pub type TX_ORDER_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `tx_order`" ]
pub struct TX_ORDER_W < 'a > { w : & 'a mut W , } impl < 'a > TX_ORDER_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rx_order`" ]
pub type RX_ORDER_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rx_order`" ]
pub struct RX_ORDER_W < 'a > { w : & 'a mut W , } impl < 'a > RX_ORDER_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `timer_v`" ]
pub type TIMER_V_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `timer_v`" ]
pub struct TIMER_V_W < 'a > { w : & 'a mut W , } impl < 'a > TIMER_V_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u32 ) & 0xff ) << 8 ) ; self . w } } impl R { # [ doc = "Bit 0 - Clock polarity. 0 for normal SPI, 1 for negative edge latch" ]
# [ inline ( always ) ]
pub fn cpol ( & self ) -> CPOL_R { CPOL_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Data phase. 0 for negative edge change, 1 for positive edge change" ]
# [ inline ( always ) ]
pub fn cpha ( & self ) -> CPHA_R { CPHA_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - TX bit order on MISO. 0 for MSB to LSB, 1 for LSB to MSB" ]
# [ inline ( always ) ]
pub fn tx_order ( & self ) -> TX_ORDER_R { TX_ORDER_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - RX bit order on MOSI. Module stores bitstream from MSB to LSB if value is 0." ]
# [ inline ( always ) ]
pub fn rx_order ( & self ) -> RX_ORDER_R { RX_ORDER_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:15 - number of clocks for RXF to wait. To reduce traffic to SRAM, RXF control module waits given clock cycle if it doesn't fill SRAM data width even if Async RX FIFO is empty." ]
# [ inline ( always ) ]
pub fn timer_v ( & self ) -> TIMER_V_R { TIMER_V_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bit 0 - Clock polarity. 0 for normal SPI, 1 for negative edge latch" ]
# [ inline ( always ) ]
pub fn cpol ( & mut self ) -> CPOL_W { CPOL_W { w : self } } # [ doc = "Bit 1 - Data phase. 0 for negative edge change, 1 for positive edge change" ]
# [ inline ( always ) ]
pub fn cpha ( & mut self ) -> CPHA_W { CPHA_W { w : self } } # [ doc = "Bit 2 - TX bit order on MISO. 0 for MSB to LSB, 1 for LSB to MSB" ]
# [ inline ( always ) ]
pub fn tx_order ( & mut self ) -> TX_ORDER_W { TX_ORDER_W { w : self } } # [ doc = "Bit 3 - RX bit order on MOSI. Module stores bitstream from MSB to LSB if value is 0." ]
# [ inline ( always ) ]
pub fn rx_order ( & mut self ) -> RX_ORDER_W { RX_ORDER_W { w : self } } # [ doc = "Bits 8:15 - number of clocks for RXF to wait. To reduce traffic to SRAM, RXF control module waits given clock cycle if it doesn't fill SRAM data width even if Async RX FIFO is empty." ]
# [ inline ( always ) ]
pub fn timer_v ( & mut self ) -> TIMER_V_W { TIMER_V_W { w : self } } } } # [ doc = "RX/ TX FIFO levels.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_level](fifo_level) module" ]
pub type FIFO_LEVEL = crate :: Reg < u32 , _FIFO_LEVEL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _FIFO_LEVEL ; # [ doc = "`read()` method returns [fifo_level::R](fifo_level::R) reader structure" ]
impl crate :: Readable for FIFO_LEVEL { } # [ doc = "`write(|w| ..)` method takes [fifo_level::W](fifo_level::W) writer structure" ]
impl crate :: Writable for FIFO_LEVEL { } # [ doc = "RX/ TX FIFO levels." ]
pub mod fifo_level { # [ doc = "Reader of register FIFO_LEVEL" ]
pub type R = crate :: R < u32 , super :: FIFO_LEVEL > ; # [ doc = "Writer for register FIFO_LEVEL" ]
pub type W = crate :: W < u32 , super :: FIFO_LEVEL > ; # [ doc = "Register FIFO_LEVEL `reset()`'s with value 0x80" ]
impl crate :: ResetValue for super :: FIFO_LEVEL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x80 } } # [ doc = "Reader of field `rxlvl`" ]
pub type RXLVL_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `rxlvl`" ]
pub struct RXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > RXLVL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `txlvl`" ]
pub type TXLVL_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `txlvl`" ]
pub struct TXLVL_W < 'a > { w : & 'a mut W , } impl < 'a > TXLVL_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - RX FIFO level. If RX SRAM FIFO level exceeds this value, it triggers interrupt." ]
# [ inline ( always ) ]
pub fn rxlvl ( & self ) -> RXLVL_R { RXLVL_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - TX FIFO level. If TX SRAM FIFO level drops below this value, it triggers interrupt." ]
# [ inline ( always ) ]
pub fn txlvl ( & self ) -> TXLVL_R { TXLVL_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - RX FIFO level. If RX SRAM FIFO level exceeds this value, it triggers interrupt." ]
# [ inline ( always ) ]
pub fn rxlvl ( & mut self ) -> RXLVL_W { RXLVL_W { w : self } } # [ doc = "Bits 16:31 - TX FIFO level. If TX SRAM FIFO level drops below this value, it triggers interrupt." ]
# [ inline ( always ) ]
pub fn txlvl ( & mut self ) -> TXLVL_W { TXLVL_W { w : self } } } } # [ doc = "RX/ TX Async FIFO levels between main clk and spi clock\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [async_fifo_level](async_fifo_level) module" ]
pub type ASYNC_FIFO_LEVEL = crate :: Reg < u32 , _ASYNC_FIFO_LEVEL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ASYNC_FIFO_LEVEL ; # [ doc = "`read()` method returns [async_fifo_level::R](async_fifo_level::R) reader structure" ]
impl crate :: Readable for ASYNC_FIFO_LEVEL { } # [ doc = "RX/ TX Async FIFO levels between main clk and spi clock" ]
pub mod async_fifo_level { # [ doc = "Reader of register ASYNC_FIFO_LEVEL" ]
pub type R = crate :: R < u32 , super :: ASYNC_FIFO_LEVEL > ; # [ doc = "Reader of field `rxlvl`" ]
pub type RXLVL_R = crate :: R < u8 , u8 > ; # [ doc = "Reader of field `txlvl`" ]
pub type TXLVL_R = crate :: R < u8 , u8 > ; impl R { # [ doc = "Bits 0:7 - RX Async FIFO level. This value shows the number of available entry in RX Async FIFO." ]
# [ inline ( always ) ]
pub fn rxlvl ( & self ) -> RXLVL_R { RXLVL_R :: new ( ( self . bits & 0xff ) as u8 ) } # [ doc = "Bits 16:23 - TX Async FIFO level. This value shows the number of available entry in TX Async FIFO. If the software writes message into SRAM FIFO and update FIFO write pointer but no clock from the host is given, the data stuck at this async fifo waiting host toggles SCK. This value represents the number of bytes." ]
# [ inline ( always ) ]
pub fn txlvl ( & self ) -> TXLVL_R { TXLVL_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } } } # [ doc = "SPI Device status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module" ]
pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ]
impl crate :: Readable for STATUS { } # [ doc = "SPI Device status register" ]
pub mod status { # [ doc = "Reader of register STATUS" ]
pub type R = crate :: R < u32 , super :: STATUS > ; # [ doc = "Reader of field `rxf_full`" ]
pub type RXF_FULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `rxf_empty`" ]
pub type RXF_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `txf_full`" ]
pub type TXF_FULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `txf_empty`" ]
pub type TXF_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `abort_done`" ]
pub type ABORT_DONE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `csb`" ]
pub type CSB_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - RX FIFO full" ]
# [ inline ( always ) ]
pub fn rxf_full ( & self ) -> RXF_FULL_R { RXF_FULL_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - RX FIFO empty" ]
# [ inline ( always ) ]
pub fn rxf_empty ( & self ) -> RXF_EMPTY_R { RXF_EMPTY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - TX FIFO full" ]
# [ inline ( always ) ]
pub fn txf_full ( & self ) -> TXF_FULL_R { TXF_FULL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - TX FIFO empty" ]
# [ inline ( always ) ]
pub fn txf_empty ( & self ) -> TXF_EMPTY_R { TXF_EMPTY_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Abort process is completed" ]
# [ inline ( always ) ]
pub fn abort_done ( & self ) -> ABORT_DONE_R { ABORT_DONE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Direct input of CSb signal" ]
# [ inline ( always ) ]
pub fn csb ( & self ) -> CSB_R { CSB_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } } # [ doc = "Receiver FIFO (SRAM) pointers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxf_ptr](rxf_ptr) module" ]
pub type RXF_PTR = crate :: Reg < u32 , _RXF_PTR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RXF_PTR ; # [ doc = "`read()` method returns [rxf_ptr::R](rxf_ptr::R) reader structure" ]
impl crate :: Readable for RXF_PTR { } # [ doc = "`write(|w| ..)` method takes [rxf_ptr::W](rxf_ptr::W) writer structure" ]
impl crate :: Writable for RXF_PTR { } # [ doc = "Receiver FIFO (SRAM) pointers" ]
pub mod rxf_ptr { # [ doc = "Reader of register RXF_PTR" ]
pub type R = crate :: R < u32 , super :: RXF_PTR > ; # [ doc = "Writer for register RXF_PTR" ]
pub type W = crate :: W < u32 , super :: RXF_PTR > ; # [ doc = "Register RXF_PTR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: RXF_PTR { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `RPTR`" ]
pub type RPTR_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `RPTR`" ]
pub struct RPTR_W < 'a > { w : & 'a mut W , } impl < 'a > RPTR_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `WPTR`" ]
pub type WPTR_R = crate :: R < u16 , u16 > ; impl R { # [ doc = "Bits 0:15 - Read pointer. bit x is for phase bit. check circular fifo description" ]
# [ inline ( always ) ]
pub fn rptr ( & self ) -> RPTR_R { RPTR_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Write pointer. Bit x is phase bit." ]
# [ inline ( always ) ]
pub fn wptr ( & self ) -> WPTR_R { WPTR_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Read pointer. bit x is for phase bit. check circular fifo description" ]
# [ inline ( always ) ]
pub fn rptr ( & mut self ) -> RPTR_W { RPTR_W { w : self } } } } # [ doc = "Transmitter FIFO (SRAM) pointers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txf_ptr](txf_ptr) module" ]
pub type TXF_PTR = crate :: Reg < u32 , _TXF_PTR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TXF_PTR ; # [ doc = "`read()` method returns [txf_ptr::R](txf_ptr::R) reader structure" ]
impl crate :: Readable for TXF_PTR { } # [ doc = "`write(|w| ..)` method takes [txf_ptr::W](txf_ptr::W) writer structure" ]
impl crate :: Writable for TXF_PTR { } # [ doc = "Transmitter FIFO (SRAM) pointers" ]
pub mod txf_ptr { # [ doc = "Reader of register TXF_PTR" ]
pub type R = crate :: R < u32 , super :: TXF_PTR > ; # [ doc = "Writer for register TXF_PTR" ]
pub type W = crate :: W < u32 , super :: TXF_PTR > ; # [ doc = "Register TXF_PTR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: TXF_PTR { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `RPTR`" ]
pub type RPTR_R = crate :: R < u16 , u16 > ; # [ doc = "Reader of field `WPTR`" ]
pub type WPTR_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `WPTR`" ]
pub struct WPTR_W < 'a > { w : & 'a mut W , } impl < 'a > WPTR_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Read pointer. bit x is for phase bit. check circular fifo description" ]
# [ inline ( always ) ]
pub fn rptr ( & self ) -> RPTR_R { RPTR_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Write pointer. Bit x is phase bit." ]
# [ inline ( always ) ]
pub fn wptr ( & self ) -> WPTR_R { WPTR_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 16:31 - Write pointer. Bit x is phase bit." ]
# [ inline ( always ) ]
pub fn wptr ( & mut self ) -> WPTR_W { WPTR_W { w : self } } } } # [ doc = "Receiver FIFO (SRAM) Addresses\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxf_addr](rxf_addr) module" ]
pub type RXF_ADDR = crate :: Reg < u32 , _RXF_ADDR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RXF_ADDR ; # [ doc = "`read()` method returns [rxf_addr::R](rxf_addr::R) reader structure" ]
impl crate :: Readable for RXF_ADDR { } # [ doc = "`write(|w| ..)` method takes [rxf_addr::W](rxf_addr::W) writer structure" ]
impl crate :: Writable for RXF_ADDR { } # [ doc = "Receiver FIFO (SRAM) Addresses" ]
pub mod rxf_addr { # [ doc = "Reader of register RXF_ADDR" ]
pub type R = crate :: R < u32 , super :: RXF_ADDR > ; # [ doc = "Writer for register RXF_ADDR" ]
pub type W = crate :: W < u32 , super :: RXF_ADDR > ; # [ doc = "Register RXF_ADDR `reset()`'s with value 0x01fc_0000" ]
impl crate :: ResetValue for super :: RXF_ADDR { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01fc_0000 } } # [ doc = "Reader of field `base`" ]
pub type BASE_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `base`" ]
pub struct BASE_W < 'a > { w : & 'a mut W , } impl < 'a > BASE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `limit`" ]
pub type LIMIT_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `limit`" ]
pub struct LIMIT_W < 'a > { w : & 'a mut W , } impl < 'a > LIMIT_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Base offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn base ( & self ) -> BASE_R { BASE_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Limit offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn limit ( & self ) -> LIMIT_R { LIMIT_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Base offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn base ( & mut self ) -> BASE_W { BASE_W { w : self } } # [ doc = "Bits 16:31 - Limit offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn limit ( & mut self ) -> LIMIT_W { LIMIT_W { w : self } } } } # [ doc = "Transmitter FIFO (SRAM) Addresses\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txf_addr](txf_addr) module" ]
pub type TXF_ADDR = crate :: Reg < u32 , _TXF_ADDR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TXF_ADDR ; # [ doc = "`read()` method returns [txf_addr::R](txf_addr::R) reader structure" ]
impl crate :: Readable for TXF_ADDR { } # [ doc = "`write(|w| ..)` method takes [txf_addr::W](txf_addr::W) writer structure" ]
impl crate :: Writable for TXF_ADDR { } # [ doc = "Transmitter FIFO (SRAM) Addresses" ]
pub mod txf_addr { # [ doc = "Reader of register TXF_ADDR" ]
pub type R = crate :: R < u32 , super :: TXF_ADDR > ; # [ doc = "Writer for register TXF_ADDR" ]
pub type W = crate :: W < u32 , super :: TXF_ADDR > ; # [ doc = "Register TXF_ADDR `reset()`'s with value 0x03fc_0200" ]
impl crate :: ResetValue for super :: TXF_ADDR { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x03fc_0200 } } # [ doc = "Reader of field `base`" ]
pub type BASE_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `base`" ]
pub struct BASE_W < 'a > { w : & 'a mut W , } impl < 'a > BASE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Reader of field `limit`" ]
pub type LIMIT_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `limit`" ]
pub struct LIMIT_W < 'a > { w : & 'a mut W , } impl < 'a > LIMIT_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Base offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn base ( & self ) -> BASE_R { BASE_R :: new ( ( self . bits & 0xffff ) as u16 ) } # [ doc = "Bits 16:31 - Limit offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn limit ( & self ) -> LIMIT_R { LIMIT_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Base offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn base ( & mut self ) -> BASE_W { BASE_W { w : self } } # [ doc = "Bits 16:31 - Limit offset in bytes in the SRAM. Lower 2 bits are ignored." ]
# [ inline ( always ) ]
pub fn limit ( & mut self ) -> LIMIT_W { LIMIT_W { w : self } } } } # [ doc = "SPI internal 2kB buffer. This buffer is shared by RX and TX circular buffer together.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [buffer](buffer) module" ]
pub type BUFFER = crate :: Reg < u32 , _BUFFER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _BUFFER ; # [ doc = "`read()` method returns [buffer::R](buffer::R) reader structure" ]
impl crate :: Readable for BUFFER { } # [ doc = "`write(|w| ..)` method takes [buffer::W](buffer::W) writer structure" ]
impl crate :: Writable for BUFFER { } # [ doc = "SPI internal 2kB buffer. This buffer is shared by RX and TX circular buffer together." ]
pub mod buffer { # [ doc = "Reader of register buffer%s" ]
pub type R = crate :: R < u32 , super :: BUFFER > ; # [ doc = "Writer for register buffer%s" ]
pub type W = crate :: W < u32 , super :: BUFFER > ; impl R { } impl W { } } } # [ doc = "flash_ctrl" ]
pub struct FLASH_CTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for FLASH_CTRL { } impl FLASH_CTRL { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const flash_ctrl :: RegisterBlock { 0x4003_0000 as * const _ } } impl Deref for FLASH_CTRL { type Target = flash_ctrl :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * FLASH_CTRL :: ptr ( ) } } } # [ doc = "flash_ctrl" ]
pub mod flash_ctrl { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - Control register" ]
pub control : CONTROL , # [ doc = "0x10 - Address for flash operation" ]
pub addr : ADDR , # [ doc = "0x14 - Memory region registers configuration enable." ]
pub region_cfg_regwen : REGION_CFG_REGWEN , # [ doc = "0x18 - Memory protection configuration" ]
pub mp_region_cfg : MP_REGION_CFG , # [ doc = "0x38 - Default region permissions" ]
pub default_region : DEFAULT_REGION , # [ doc = "0x3c - Bank configuration registers configuration enable." ]
pub bank_cfg_regwen : BANK_CFG_REGWEN , # [ doc = "0x40 - Memory protect bank configuration" ]
pub mp_bank_cfg : MP_BANK_CFG , # [ doc = "0x44 - Flash Operation Status" ]
pub op_status : OP_STATUS , # [ doc = "0x48 - Flash Controller Status" ]
pub status : STATUS , # [ doc = "0x4c - Flash Controller Scratch" ]
pub scratch : SCRATCH , # [ doc = "0x50 - Programmable depth where fifos should generate interrupts" ]
pub fifo_lvl : FIFO_LVL , # [ doc = "0x54 - Flash program fifo. The fifo is 16 entries of 4B flash words" ]
pub prog_fifo : [ PROG_FIFO ; 1 ]
, # [ doc = "0x58 - Flash read fifo. The fifo is 16 entries of 4B flash words" ]
pub rd_fifo : [ RD_FIFO ; 1 ]
, } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct MP_REGION_CFG { # [ doc = "0x00 - Memory protection configuration" ]
pub mp_region_cfg0 : self :: mp_region_cfg :: MP_REGION_CFG0 , # [ doc = "0x04 - Memory protection configuration" ]
pub mp_region_cfg1 : self :: mp_region_cfg :: MP_REGION_CFG1 , # [ doc = "0x08 - Memory protection configuration" ]
pub mp_region_cfg2 : self :: mp_region_cfg :: MP_REGION_CFG2 , # [ doc = "0x0c - Memory protection configuration" ]
pub mp_region_cfg3 : self :: mp_region_cfg :: MP_REGION_CFG3 , # [ doc = "0x10 - Memory protection configuration" ]
pub mp_region_cfg4 : self :: mp_region_cfg :: MP_REGION_CFG4 , # [ doc = "0x14 - Memory protection configuration" ]
pub mp_region_cfg5 : self :: mp_region_cfg :: MP_REGION_CFG5 , # [ doc = "0x18 - Memory protection configuration" ]
pub mp_region_cfg6 : self :: mp_region_cfg :: MP_REGION_CFG6 , # [ doc = "0x1c - Memory protection configuration" ]
pub mp_region_cfg7 : self :: mp_region_cfg :: MP_REGION_CFG7 , } # [ doc = r"Register block" ]
# [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg { # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg0](mp_region_cfg0) module" ]
pub type MP_REGION_CFG0 = crate :: Reg < u32 , _MP_REGION_CFG0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG0 ; # [ doc = "`read()` method returns [mp_region_cfg0::R](mp_region_cfg0::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG0 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg0::W](mp_region_cfg0::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG0 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg0 { # [ doc = "Reader of register MP_REGION_CFG0" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG0 > ; # [ doc = "Writer for register MP_REGION_CFG0" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG0 > ; # [ doc = "Register MP_REGION_CFG0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN0`" ]
pub type EN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN0`" ]
pub struct EN0_W < 'a > { w : & 'a mut W , } impl < 'a > EN0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN0`" ]
pub type RD_EN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN0`" ]
pub struct RD_EN0_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN0`" ]
pub type PROG_EN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN0`" ]
pub struct PROG_EN0_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN0`" ]
pub type ERASE_EN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN0`" ]
pub struct ERASE_EN0_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE0`" ]
pub type BASE0_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE0`" ]
pub struct BASE0_W < 'a > { w : & 'a mut W , } impl < 'a > BASE0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE0`" ]
pub type SIZE0_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE0`" ]
pub struct SIZE0_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn en0 ( & self ) -> EN0_R { EN0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn rd_en0 ( & self ) -> RD_EN0_R { RD_EN0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn prog_en0 ( & self ) -> PROG_EN0_R { PROG_EN0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn erase_en0 ( & self ) -> ERASE_EN0_R { ERASE_EN0_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn base0 ( & self ) -> BASE0_R { BASE0_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn size0 ( & self ) -> SIZE0_R { SIZE0_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn en0 ( & mut self ) -> EN0_W { EN0_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn rd_en0 ( & mut self ) -> RD_EN0_W { RD_EN0_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn prog_en0 ( & mut self ) -> PROG_EN0_W { PROG_EN0_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn erase_en0 ( & mut self ) -> ERASE_EN0_W { ERASE_EN0_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn base0 ( & mut self ) -> BASE0_W { BASE0_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn size0 ( & mut self ) -> SIZE0_W { SIZE0_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg1](mp_region_cfg1) module" ]
pub type MP_REGION_CFG1 = crate :: Reg < u32 , _MP_REGION_CFG1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG1 ; # [ doc = "`read()` method returns [mp_region_cfg1::R](mp_region_cfg1::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG1 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg1::W](mp_region_cfg1::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG1 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg1 { # [ doc = "Reader of register MP_REGION_CFG1" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG1 > ; # [ doc = "Writer for register MP_REGION_CFG1" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG1 > ; # [ doc = "Register MP_REGION_CFG1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN1`" ]
pub type EN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN1`" ]
pub struct EN1_W < 'a > { w : & 'a mut W , } impl < 'a > EN1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN1`" ]
pub type RD_EN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN1`" ]
pub struct RD_EN1_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN1`" ]
pub type PROG_EN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN1`" ]
pub struct PROG_EN1_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN1`" ]
pub type ERASE_EN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN1`" ]
pub struct ERASE_EN1_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE1`" ]
pub type BASE1_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE1`" ]
pub struct BASE1_W < 'a > { w : & 'a mut W , } impl < 'a > BASE1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE1`" ]
pub type SIZE1_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE1`" ]
pub struct SIZE1_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn en1 ( & self ) -> EN1_R { EN1_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn rd_en1 ( & self ) -> RD_EN1_R { RD_EN1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn prog_en1 ( & self ) -> PROG_EN1_R { PROG_EN1_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn erase_en1 ( & self ) -> ERASE_EN1_R { ERASE_EN1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn base1 ( & self ) -> BASE1_R { BASE1_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn size1 ( & self ) -> SIZE1_R { SIZE1_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn en1 ( & mut self ) -> EN1_W { EN1_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn rd_en1 ( & mut self ) -> RD_EN1_W { RD_EN1_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn prog_en1 ( & mut self ) -> PROG_EN1_W { PROG_EN1_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn erase_en1 ( & mut self ) -> ERASE_EN1_W { ERASE_EN1_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn base1 ( & mut self ) -> BASE1_W { BASE1_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn size1 ( & mut self ) -> SIZE1_W { SIZE1_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg2](mp_region_cfg2) module" ]
pub type MP_REGION_CFG2 = crate :: Reg < u32 , _MP_REGION_CFG2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG2 ; # [ doc = "`read()` method returns [mp_region_cfg2::R](mp_region_cfg2::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG2 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg2::W](mp_region_cfg2::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG2 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg2 { # [ doc = "Reader of register MP_REGION_CFG2" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG2 > ; # [ doc = "Writer for register MP_REGION_CFG2" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG2 > ; # [ doc = "Register MP_REGION_CFG2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN2`" ]
pub type EN2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN2`" ]
pub struct EN2_W < 'a > { w : & 'a mut W , } impl < 'a > EN2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN2`" ]
pub type RD_EN2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN2`" ]
pub struct RD_EN2_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN2`" ]
pub type PROG_EN2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN2`" ]
pub struct PROG_EN2_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN2`" ]
pub type ERASE_EN2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN2`" ]
pub struct ERASE_EN2_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE2`" ]
pub type BASE2_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE2`" ]
pub struct BASE2_W < 'a > { w : & 'a mut W , } impl < 'a > BASE2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE2`" ]
pub type SIZE2_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE2`" ]
pub struct SIZE2_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn en2 ( & self ) -> EN2_R { EN2_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn rd_en2 ( & self ) -> RD_EN2_R { RD_EN2_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn prog_en2 ( & self ) -> PROG_EN2_R { PROG_EN2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn erase_en2 ( & self ) -> ERASE_EN2_R { ERASE_EN2_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn base2 ( & self ) -> BASE2_R { BASE2_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn size2 ( & self ) -> SIZE2_R { SIZE2_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn en2 ( & mut self ) -> EN2_W { EN2_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn rd_en2 ( & mut self ) -> RD_EN2_W { RD_EN2_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn prog_en2 ( & mut self ) -> PROG_EN2_W { PROG_EN2_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn erase_en2 ( & mut self ) -> ERASE_EN2_W { ERASE_EN2_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn base2 ( & mut self ) -> BASE2_W { BASE2_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn size2 ( & mut self ) -> SIZE2_W { SIZE2_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg3](mp_region_cfg3) module" ]
pub type MP_REGION_CFG3 = crate :: Reg < u32 , _MP_REGION_CFG3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG3 ; # [ doc = "`read()` method returns [mp_region_cfg3::R](mp_region_cfg3::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG3 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg3::W](mp_region_cfg3::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG3 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg3 { # [ doc = "Reader of register MP_REGION_CFG3" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG3 > ; # [ doc = "Writer for register MP_REGION_CFG3" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG3 > ; # [ doc = "Register MP_REGION_CFG3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN3`" ]
pub type EN3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN3`" ]
pub struct EN3_W < 'a > { w : & 'a mut W , } impl < 'a > EN3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN3`" ]
pub type RD_EN3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN3`" ]
pub struct RD_EN3_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN3`" ]
pub type PROG_EN3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN3`" ]
pub struct PROG_EN3_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN3`" ]
pub type ERASE_EN3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN3`" ]
pub struct ERASE_EN3_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE3`" ]
pub type BASE3_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE3`" ]
pub struct BASE3_W < 'a > { w : & 'a mut W , } impl < 'a > BASE3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE3`" ]
pub type SIZE3_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE3`" ]
pub struct SIZE3_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn en3 ( & self ) -> EN3_R { EN3_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn rd_en3 ( & self ) -> RD_EN3_R { RD_EN3_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn prog_en3 ( & self ) -> PROG_EN3_R { PROG_EN3_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn erase_en3 ( & self ) -> ERASE_EN3_R { ERASE_EN3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn base3 ( & self ) -> BASE3_R { BASE3_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn size3 ( & self ) -> SIZE3_R { SIZE3_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn en3 ( & mut self ) -> EN3_W { EN3_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn rd_en3 ( & mut self ) -> RD_EN3_W { RD_EN3_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn prog_en3 ( & mut self ) -> PROG_EN3_W { PROG_EN3_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn erase_en3 ( & mut self ) -> ERASE_EN3_W { ERASE_EN3_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn base3 ( & mut self ) -> BASE3_W { BASE3_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn size3 ( & mut self ) -> SIZE3_W { SIZE3_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg4](mp_region_cfg4) module" ]
pub type MP_REGION_CFG4 = crate :: Reg < u32 , _MP_REGION_CFG4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG4 ; # [ doc = "`read()` method returns [mp_region_cfg4::R](mp_region_cfg4::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG4 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg4::W](mp_region_cfg4::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG4 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg4 { # [ doc = "Reader of register MP_REGION_CFG4" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG4 > ; # [ doc = "Writer for register MP_REGION_CFG4" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG4 > ; # [ doc = "Register MP_REGION_CFG4 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG4 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN4`" ]
pub type EN4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN4`" ]
pub struct EN4_W < 'a > { w : & 'a mut W , } impl < 'a > EN4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN4`" ]
pub type RD_EN4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN4`" ]
pub struct RD_EN4_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN4`" ]
pub type PROG_EN4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN4`" ]
pub struct PROG_EN4_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN4`" ]
pub type ERASE_EN4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN4`" ]
pub struct ERASE_EN4_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE4`" ]
pub type BASE4_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE4`" ]
pub struct BASE4_W < 'a > { w : & 'a mut W , } impl < 'a > BASE4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE4`" ]
pub type SIZE4_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE4`" ]
pub struct SIZE4_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn en4 ( & self ) -> EN4_R { EN4_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn rd_en4 ( & self ) -> RD_EN4_R { RD_EN4_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn prog_en4 ( & self ) -> PROG_EN4_R { PROG_EN4_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn erase_en4 ( & self ) -> ERASE_EN4_R { ERASE_EN4_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn base4 ( & self ) -> BASE4_R { BASE4_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn size4 ( & self ) -> SIZE4_R { SIZE4_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn en4 ( & mut self ) -> EN4_W { EN4_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn rd_en4 ( & mut self ) -> RD_EN4_W { RD_EN4_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn prog_en4 ( & mut self ) -> PROG_EN4_W { PROG_EN4_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn erase_en4 ( & mut self ) -> ERASE_EN4_W { ERASE_EN4_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn base4 ( & mut self ) -> BASE4_W { BASE4_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn size4 ( & mut self ) -> SIZE4_W { SIZE4_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg5](mp_region_cfg5) module" ]
pub type MP_REGION_CFG5 = crate :: Reg < u32 , _MP_REGION_CFG5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG5 ; # [ doc = "`read()` method returns [mp_region_cfg5::R](mp_region_cfg5::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG5 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg5::W](mp_region_cfg5::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG5 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg5 { # [ doc = "Reader of register MP_REGION_CFG5" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG5 > ; # [ doc = "Writer for register MP_REGION_CFG5" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG5 > ; # [ doc = "Register MP_REGION_CFG5 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG5 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN5`" ]
pub type EN5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN5`" ]
pub struct EN5_W < 'a > { w : & 'a mut W , } impl < 'a > EN5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN5`" ]
pub type RD_EN5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN5`" ]
pub struct RD_EN5_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN5`" ]
pub type PROG_EN5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN5`" ]
pub struct PROG_EN5_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN5`" ]
pub type ERASE_EN5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN5`" ]
pub struct ERASE_EN5_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE5`" ]
pub type BASE5_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE5`" ]
pub struct BASE5_W < 'a > { w : & 'a mut W , } impl < 'a > BASE5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE5`" ]
pub type SIZE5_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE5`" ]
pub struct SIZE5_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn en5 ( & self ) -> EN5_R { EN5_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn rd_en5 ( & self ) -> RD_EN5_R { RD_EN5_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn prog_en5 ( & self ) -> PROG_EN5_R { PROG_EN5_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn erase_en5 ( & self ) -> ERASE_EN5_R { ERASE_EN5_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn base5 ( & self ) -> BASE5_R { BASE5_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn size5 ( & self ) -> SIZE5_R { SIZE5_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn en5 ( & mut self ) -> EN5_W { EN5_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn rd_en5 ( & mut self ) -> RD_EN5_W { RD_EN5_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn prog_en5 ( & mut self ) -> PROG_EN5_W { PROG_EN5_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn erase_en5 ( & mut self ) -> ERASE_EN5_W { ERASE_EN5_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn base5 ( & mut self ) -> BASE5_W { BASE5_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn size5 ( & mut self ) -> SIZE5_W { SIZE5_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg6](mp_region_cfg6) module" ]
pub type MP_REGION_CFG6 = crate :: Reg < u32 , _MP_REGION_CFG6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG6 ; # [ doc = "`read()` method returns [mp_region_cfg6::R](mp_region_cfg6::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG6 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg6::W](mp_region_cfg6::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG6 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg6 { # [ doc = "Reader of register MP_REGION_CFG6" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG6 > ; # [ doc = "Writer for register MP_REGION_CFG6" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG6 > ; # [ doc = "Register MP_REGION_CFG6 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG6 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN6`" ]
pub type EN6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN6`" ]
pub struct EN6_W < 'a > { w : & 'a mut W , } impl < 'a > EN6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN6`" ]
pub type RD_EN6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN6`" ]
pub struct RD_EN6_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN6`" ]
pub type PROG_EN6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN6`" ]
pub struct PROG_EN6_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN6`" ]
pub type ERASE_EN6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN6`" ]
pub struct ERASE_EN6_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE6`" ]
pub type BASE6_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE6`" ]
pub struct BASE6_W < 'a > { w : & 'a mut W , } impl < 'a > BASE6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE6`" ]
pub type SIZE6_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE6`" ]
pub struct SIZE6_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn en6 ( & self ) -> EN6_R { EN6_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn rd_en6 ( & self ) -> RD_EN6_R { RD_EN6_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn prog_en6 ( & self ) -> PROG_EN6_R { PROG_EN6_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn erase_en6 ( & self ) -> ERASE_EN6_R { ERASE_EN6_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn base6 ( & self ) -> BASE6_R { BASE6_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn size6 ( & self ) -> SIZE6_R { SIZE6_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn en6 ( & mut self ) -> EN6_W { EN6_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn rd_en6 ( & mut self ) -> RD_EN6_W { RD_EN6_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn prog_en6 ( & mut self ) -> PROG_EN6_W { PROG_EN6_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn erase_en6 ( & mut self ) -> ERASE_EN6_W { ERASE_EN6_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn base6 ( & mut self ) -> BASE6_W { BASE6_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn size6 ( & mut self ) -> SIZE6_W { SIZE6_W { w : self } } } } # [ doc = "Memory protection configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_region_cfg7](mp_region_cfg7) module" ]
pub type MP_REGION_CFG7 = crate :: Reg < u32 , _MP_REGION_CFG7 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_REGION_CFG7 ; # [ doc = "`read()` method returns [mp_region_cfg7::R](mp_region_cfg7::R) reader structure" ]
impl crate :: Readable for MP_REGION_CFG7 { } # [ doc = "`write(|w| ..)` method takes [mp_region_cfg7::W](mp_region_cfg7::W) writer structure" ]
impl crate :: Writable for MP_REGION_CFG7 { } # [ doc = "Memory protection configuration" ]
pub mod mp_region_cfg7 { # [ doc = "Reader of register MP_REGION_CFG7" ]
pub type R = crate :: R < u32 , super :: MP_REGION_CFG7 > ; # [ doc = "Writer for register MP_REGION_CFG7" ]
pub type W = crate :: W < u32 , super :: MP_REGION_CFG7 > ; # [ doc = "Register MP_REGION_CFG7 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_REGION_CFG7 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN7`" ]
pub type EN7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN7`" ]
pub struct EN7_W < 'a > { w : & 'a mut W , } impl < 'a > EN7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `RD_EN7`" ]
pub type RD_EN7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN7`" ]
pub struct RD_EN7_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PROG_EN7`" ]
pub type PROG_EN7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN7`" ]
pub struct PROG_EN7_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN7`" ]
pub type ERASE_EN7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN7`" ]
pub struct ERASE_EN7_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `BASE7`" ]
pub type BASE7_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BASE7`" ]
pub struct BASE7_W < 'a > { w : & 'a mut W , } impl < 'a > BASE7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 4 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 4 ) ; self . w } } # [ doc = "Reader of field `SIZE7`" ]
pub type SIZE7_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `SIZE7`" ]
pub struct SIZE7_W < 'a > { w : & 'a mut W , } impl < 'a > SIZE7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn en7 ( & self ) -> EN7_R { EN7_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn rd_en7 ( & self ) -> RD_EN7_R { RD_EN7_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn prog_en7 ( & self ) -> PROG_EN7_R { PROG_EN7_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn erase_en7 ( & self ) -> ERASE_EN7_R { ERASE_EN7_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn base7 ( & self ) -> BASE7_R { BASE7_R :: new ( ( ( self . bits >> 4 ) & 0x01ff ) as u16 ) } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn size7 ( & self ) -> SIZE7_R { SIZE7_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Region enabled, following fields apply for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn en7 ( & mut self ) -> EN7_W { EN7_W { w : self } } # [ doc = "Bit 1 - Region can be read for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn rd_en7 ( & mut self ) -> RD_EN7_W { RD_EN7_W { w : self } } # [ doc = "Bit 2 - Region can be programmed for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn prog_en7 ( & mut self ) -> PROG_EN7_W { PROG_EN7_W { w : self } } # [ doc = "Bit 3 - Region can be erased for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn erase_en7 ( & mut self ) -> ERASE_EN7_W { ERASE_EN7_W { w : self } } # [ doc = "Bits 4:12 - Region base page. Note the granularity is page, not byte or word for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn base7 ( & mut self ) -> BASE7_W { BASE7_W { w : self } } # [ doc = "Bits 16:24 - Region size in number of pages for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn size7 ( & mut self ) -> SIZE7_W { SIZE7_W { w : self } } } } } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `prog_empty`" ]
pub type PROG_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `prog_empty`" ]
pub struct PROG_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `prog_lvl`" ]
pub type PROG_LVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `prog_lvl`" ]
pub struct PROG_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `rd_full`" ]
pub type RD_FULL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rd_full`" ]
pub struct RD_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rd_lvl`" ]
pub type RD_LVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rd_lvl`" ]
pub struct RD_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `op_done`" ]
pub type OP_DONE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `op_done`" ]
pub struct OP_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > OP_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `op_error`" ]
pub type OP_ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `op_error`" ]
pub struct OP_ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > OP_ERROR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Program FIFO empty" ]
# [ inline ( always ) ]
pub fn prog_empty ( & self ) -> PROG_EMPTY_R { PROG_EMPTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Program FIFO drained to level" ]
# [ inline ( always ) ]
pub fn prog_lvl ( & self ) -> PROG_LVL_R { PROG_LVL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Read FIFO full" ]
# [ inline ( always ) ]
pub fn rd_full ( & self ) -> RD_FULL_R { RD_FULL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Read FIFO filled to level" ]
# [ inline ( always ) ]
pub fn rd_lvl ( & self ) -> RD_LVL_R { RD_LVL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Operation complete" ]
# [ inline ( always ) ]
pub fn op_done ( & self ) -> OP_DONE_R { OP_DONE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Operation failed with error" ]
# [ inline ( always ) ]
pub fn op_error ( & self ) -> OP_ERROR_R { OP_ERROR_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Program FIFO empty" ]
# [ inline ( always ) ]
pub fn prog_empty ( & mut self ) -> PROG_EMPTY_W { PROG_EMPTY_W { w : self } } # [ doc = "Bit 1 - Program FIFO drained to level" ]
# [ inline ( always ) ]
pub fn prog_lvl ( & mut self ) -> PROG_LVL_W { PROG_LVL_W { w : self } } # [ doc = "Bit 2 - Read FIFO full" ]
# [ inline ( always ) ]
pub fn rd_full ( & mut self ) -> RD_FULL_W { RD_FULL_W { w : self } } # [ doc = "Bit 3 - Read FIFO filled to level" ]
# [ inline ( always ) ]
pub fn rd_lvl ( & mut self ) -> RD_LVL_W { RD_LVL_W { w : self } } # [ doc = "Bit 4 - Operation complete" ]
# [ inline ( always ) ]
pub fn op_done ( & mut self ) -> OP_DONE_W { OP_DONE_W { w : self } } # [ doc = "Bit 5 - Operation failed with error" ]
# [ inline ( always ) ]
pub fn op_error ( & mut self ) -> OP_ERROR_W { OP_ERROR_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `prog_empty`" ]
pub type PROG_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `prog_empty`" ]
pub struct PROG_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `prog_lvl`" ]
pub type PROG_LVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `prog_lvl`" ]
pub struct PROG_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `rd_full`" ]
pub type RD_FULL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rd_full`" ]
pub struct RD_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `rd_lvl`" ]
pub type RD_LVL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `rd_lvl`" ]
pub struct RD_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `op_done`" ]
pub type OP_DONE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `op_done`" ]
pub struct OP_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > OP_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `op_error`" ]
pub type OP_ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `op_error`" ]
pub struct OP_ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > OP_ERROR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.prog_empty is set" ]
# [ inline ( always ) ]
pub fn prog_empty ( & self ) -> PROG_EMPTY_R { PROG_EMPTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.prog_lvl is set" ]
# [ inline ( always ) ]
pub fn prog_lvl ( & self ) -> PROG_LVL_R { PROG_LVL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.rd_full is set" ]
# [ inline ( always ) ]
pub fn rd_full ( & self ) -> RD_FULL_R { RD_FULL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rd_lvl is set" ]
# [ inline ( always ) ]
pub fn rd_lvl ( & self ) -> RD_LVL_R { RD_LVL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.op_done is set" ]
# [ inline ( always ) ]
pub fn op_done ( & self ) -> OP_DONE_R { OP_DONE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.op_error is set" ]
# [ inline ( always ) ]
pub fn op_error ( & self ) -> OP_ERROR_R { OP_ERROR_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.prog_empty is set" ]
# [ inline ( always ) ]
pub fn prog_empty ( & mut self ) -> PROG_EMPTY_W { PROG_EMPTY_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.prog_lvl is set" ]
# [ inline ( always ) ]
pub fn prog_lvl ( & mut self ) -> PROG_LVL_W { PROG_LVL_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.rd_full is set" ]
# [ inline ( always ) ]
pub fn rd_full ( & mut self ) -> RD_FULL_W { RD_FULL_W { w : self } } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.rd_lvl is set" ]
# [ inline ( always ) ]
pub fn rd_lvl ( & mut self ) -> RD_LVL_W { RD_LVL_W { w : self } } # [ doc = "Bit 4 - Enable interrupt when !!INTR_STATE.op_done is set" ]
# [ inline ( always ) ]
pub fn op_done ( & mut self ) -> OP_DONE_W { OP_DONE_W { w : self } } # [ doc = "Bit 5 - Enable interrupt when !!INTR_STATE.op_error is set" ]
# [ inline ( always ) ]
pub fn op_error ( & mut self ) -> OP_ERROR_W { OP_ERROR_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `prog_empty`" ]
pub struct PROG_EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `prog_lvl`" ]
pub struct PROG_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `rd_full`" ]
pub struct RD_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `rd_lvl`" ]
pub struct RD_LVL_W < 'a > { w : & 'a mut W , } impl < 'a > RD_LVL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Write proxy for field `op_done`" ]
pub struct OP_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > OP_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Write proxy for field `op_error`" ]
pub struct OP_ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > OP_ERROR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.prog_empty to 1" ]
# [ inline ( always ) ]
pub fn prog_empty ( & mut self ) -> PROG_EMPTY_W { PROG_EMPTY_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.prog_lvl to 1" ]
# [ inline ( always ) ]
pub fn prog_lvl ( & mut self ) -> PROG_LVL_W { PROG_LVL_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.rd_full to 1" ]
# [ inline ( always ) ]
pub fn rd_full ( & mut self ) -> RD_FULL_W { RD_FULL_W { w : self } } # [ doc = "Bit 3 - Write 1 to force !!INTR_STATE.rd_lvl to 1" ]
# [ inline ( always ) ]
pub fn rd_lvl ( & mut self ) -> RD_LVL_W { RD_LVL_W { w : self } } # [ doc = "Bit 4 - Write 1 to force !!INTR_STATE.op_done to 1" ]
# [ inline ( always ) ]
pub fn op_done ( & mut self ) -> OP_DONE_W { OP_DONE_W { w : self } } # [ doc = "Bit 5 - Write 1 to force !!INTR_STATE.op_error to 1" ]
# [ inline ( always ) ]
pub fn op_error ( & mut self ) -> OP_ERROR_W { OP_ERROR_W { w : self } } } } # [ doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](control) module" ]
pub type CONTROL = crate :: Reg < u32 , _CONTROL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CONTROL ; # [ doc = "`read()` method returns [control::R](control::R) reader structure" ]
impl crate :: Readable for CONTROL { } # [ doc = "`write(|w| ..)` method takes [control::W](control::W) writer structure" ]
impl crate :: Writable for CONTROL { } # [ doc = "Control register" ]
pub mod control { # [ doc = "Reader of register CONTROL" ]
pub type R = crate :: R < u32 , super :: CONTROL > ; # [ doc = "Writer for register CONTROL" ]
pub type W = crate :: W < u32 , super :: CONTROL > ; # [ doc = "Register CONTROL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CONTROL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `START`" ]
pub type START_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `START`" ]
pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `OP`" ]
pub type OP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OP`" ]
pub struct OP_W < 'a > { w : & 'a mut W , } impl < 'a > OP_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `ERASE_SEL`" ]
pub type ERASE_SEL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_SEL`" ]
pub struct ERASE_SEL_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_SEL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `FIFO_RST`" ]
pub type FIFO_RST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `FIFO_RST`" ]
pub struct FIFO_RST_W < 'a > { w : & 'a mut W , } impl < 'a > FIFO_RST_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `NUM`" ]
pub type NUM_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `NUM`" ]
pub struct NUM_W < 'a > { w : & 'a mut W , } impl < 'a > NUM_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0fff << 16 ) ) | ( ( ( value as u32 ) & 0x0fff ) << 16 ) ; self . w } } impl R { # [ doc = "Bit 0 - Start flash transaction. This bit shall only be set after the other fields of the CONTROL register and ADDR have been programmed" ]
# [ inline ( always ) ]
pub fn start ( & self ) -> START_R { START_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bits 4:5 - Flash operation selection" ]
# [ inline ( always ) ]
pub fn op ( & self ) -> OP_R { OP_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - Flash operation selection" ]
# [ inline ( always ) ]
pub fn erase_sel ( & self ) -> ERASE_SEL_R { ERASE_SEL_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - RST FIFOs" ]
# [ inline ( always ) ]
pub fn fifo_rst ( & self ) -> FIFO_RST_R { FIFO_RST_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:27 - Number of flash words the flash operation should read or program." ]
# [ inline ( always ) ]
pub fn num ( & self ) -> NUM_R { NUM_R :: new ( ( ( self . bits >> 16 ) & 0x0fff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Start flash transaction. This bit shall only be set after the other fields of the CONTROL register and ADDR have been programmed" ]
# [ inline ( always ) ]
pub fn start ( & mut self ) -> START_W { START_W { w : self } } # [ doc = "Bits 4:5 - Flash operation selection" ]
# [ inline ( always ) ]
pub fn op ( & mut self ) -> OP_W { OP_W { w : self } } # [ doc = "Bit 6 - Flash operation selection" ]
# [ inline ( always ) ]
pub fn erase_sel ( & mut self ) -> ERASE_SEL_W { ERASE_SEL_W { w : self } } # [ doc = "Bit 7 - RST FIFOs" ]
# [ inline ( always ) ]
pub fn fifo_rst ( & mut self ) -> FIFO_RST_W { FIFO_RST_W { w : self } } # [ doc = "Bits 16:27 - Number of flash words the flash operation should read or program." ]
# [ inline ( always ) ]
pub fn num ( & mut self ) -> NUM_W { NUM_W { w : self } } } } # [ doc = "Address for flash operation\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](addr) module" ]
pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ADDR ; # [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ]
impl crate :: Readable for ADDR { } # [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ]
impl crate :: Writable for ADDR { } # [ doc = "Address for flash operation" ]
pub mod addr { # [ doc = "Reader of register ADDR" ]
pub type R = crate :: R < u32 , super :: ADDR > ; # [ doc = "Writer for register ADDR" ]
pub type W = crate :: W < u32 , super :: ADDR > ; # [ doc = "Register ADDR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `START`" ]
pub type START_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `START`" ]
pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Start address of a flash transaction. Software should supply the full byte address. The flash controller will then truncate the address as needed. For read operations, the flash controller will truncate to the closest, lower word aligned address. For example, if 0x13 is supplied, the controller will perform a read at address 0x10. Program operations behave similarly, the controller does not have read modified write support. For page erases, the controller will truncate to the closest lower page aligned address. Similarly for bank erases, the controller will truncate to the closest lower bank aligned address." ]
# [ inline ( always ) ]
pub fn start ( & self ) -> START_R { START_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Start address of a flash transaction. Software should supply the full byte address. The flash controller will then truncate the address as needed. For read operations, the flash controller will truncate to the closest, lower word aligned address. For example, if 0x13 is supplied, the controller will perform a read at address 0x10. Program operations behave similarly, the controller does not have read modified write support. For page erases, the controller will truncate to the closest lower page aligned address. Similarly for bank erases, the controller will truncate to the closest lower bank aligned address." ]
# [ inline ( always ) ]
pub fn start ( & mut self ) -> START_W { START_W { w : self } } } } # [ doc = "Memory region registers configuration enable.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [region_cfg_regwen](region_cfg_regwen) module" ]
pub type REGION_CFG_REGWEN = crate :: Reg < u32 , _REGION_CFG_REGWEN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _REGION_CFG_REGWEN ; # [ doc = "`read()` method returns [region_cfg_regwen::R](region_cfg_regwen::R) reader structure" ]
impl crate :: Readable for REGION_CFG_REGWEN { } # [ doc = "`write(|w| ..)` method takes [region_cfg_regwen::W](region_cfg_regwen::W) writer structure" ]
impl crate :: Writable for REGION_CFG_REGWEN { } # [ doc = "Memory region registers configuration enable." ]
pub mod region_cfg_regwen { # [ doc = "Reader of register REGION_CFG_REGWEN" ]
pub type R = crate :: R < u32 , super :: REGION_CFG_REGWEN > ; # [ doc = "Writer for register REGION_CFG_REGWEN" ]
pub type W = crate :: W < u32 , super :: REGION_CFG_REGWEN > ; # [ doc = "Register REGION_CFG_REGWEN `reset()`'s with value 0xff" ]
impl crate :: ResetValue for super :: REGION_CFG_REGWEN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0xff } } # [ doc = "Reader of field `REGION0`" ]
pub type REGION0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION0`" ]
pub struct REGION0_W < 'a > { w : & 'a mut W , } impl < 'a > REGION0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `REGION1`" ]
pub type REGION1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION1`" ]
pub struct REGION1_W < 'a > { w : & 'a mut W , } impl < 'a > REGION1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `REGION2`" ]
pub type REGION2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION2`" ]
pub struct REGION2_W < 'a > { w : & 'a mut W , } impl < 'a > REGION2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `REGION3`" ]
pub type REGION3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION3`" ]
pub struct REGION3_W < 'a > { w : & 'a mut W , } impl < 'a > REGION3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `REGION4`" ]
pub type REGION4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION4`" ]
pub struct REGION4_W < 'a > { w : & 'a mut W , } impl < 'a > REGION4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `REGION5`" ]
pub type REGION5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION5`" ]
pub struct REGION5_W < 'a > { w : & 'a mut W , } impl < 'a > REGION5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `REGION6`" ]
pub type REGION6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION6`" ]
pub struct REGION6_W < 'a > { w : & 'a mut W , } impl < 'a > REGION6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `REGION7`" ]
pub type REGION7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `REGION7`" ]
pub struct REGION7_W < 'a > { w : & 'a mut W , } impl < 'a > REGION7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region register write enable. Once set to 0, it can longer be configured to 1 for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn region0 ( & self ) -> REGION0_R { REGION0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn region1 ( & self ) -> REGION1_R { REGION1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn region2 ( & self ) -> REGION2_R { REGION2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn region3 ( & self ) -> REGION3_R { REGION3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn region4 ( & self ) -> REGION4_R { REGION4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn region5 ( & self ) -> REGION5_R { REGION5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn region6 ( & self ) -> REGION6_R { REGION6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn region7 ( & self ) -> REGION7_R { REGION7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Region register write enable. Once set to 0, it can longer be configured to 1 for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn region0 ( & mut self ) -> REGION0_W { REGION0_W { w : self } } # [ doc = "Bit 1 - for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn region1 ( & mut self ) -> REGION1_W { REGION1_W { w : self } } # [ doc = "Bit 2 - for FLASH_CTRL2" ]
# [ inline ( always ) ]
pub fn region2 ( & mut self ) -> REGION2_W { REGION2_W { w : self } } # [ doc = "Bit 3 - for FLASH_CTRL3" ]
# [ inline ( always ) ]
pub fn region3 ( & mut self ) -> REGION3_W { REGION3_W { w : self } } # [ doc = "Bit 4 - for FLASH_CTRL4" ]
# [ inline ( always ) ]
pub fn region4 ( & mut self ) -> REGION4_W { REGION4_W { w : self } } # [ doc = "Bit 5 - for FLASH_CTRL5" ]
# [ inline ( always ) ]
pub fn region5 ( & mut self ) -> REGION5_W { REGION5_W { w : self } } # [ doc = "Bit 6 - for FLASH_CTRL6" ]
# [ inline ( always ) ]
pub fn region6 ( & mut self ) -> REGION6_W { REGION6_W { w : self } } # [ doc = "Bit 7 - for FLASH_CTRL7" ]
# [ inline ( always ) ]
pub fn region7 ( & mut self ) -> REGION7_W { REGION7_W { w : self } } } } # [ doc = "Default region permissions\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [default_region](default_region) module" ]
pub type DEFAULT_REGION = crate :: Reg < u32 , _DEFAULT_REGION > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DEFAULT_REGION ; # [ doc = "`read()` method returns [default_region::R](default_region::R) reader structure" ]
impl crate :: Readable for DEFAULT_REGION { } # [ doc = "`write(|w| ..)` method takes [default_region::W](default_region::W) writer structure" ]
impl crate :: Writable for DEFAULT_REGION { } # [ doc = "Default region permissions" ]
pub mod default_region { # [ doc = "Reader of register DEFAULT_REGION" ]
pub type R = crate :: R < u32 , super :: DEFAULT_REGION > ; # [ doc = "Writer for register DEFAULT_REGION" ]
pub type W = crate :: W < u32 , super :: DEFAULT_REGION > ; # [ doc = "Register DEFAULT_REGION `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DEFAULT_REGION { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `RD_EN`" ]
pub type RD_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RD_EN`" ]
pub struct RD_EN_W < 'a > { w : & 'a mut W , } impl < 'a > RD_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PROG_EN`" ]
pub type PROG_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PROG_EN`" ]
pub struct PROG_EN_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN`" ]
pub type ERASE_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN`" ]
pub struct ERASE_EN_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } impl R { # [ doc = "Bit 0 - Region can be read" ]
# [ inline ( always ) ]
pub fn rd_en ( & self ) -> RD_EN_R { RD_EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Region can be programmed" ]
# [ inline ( always ) ]
pub fn prog_en ( & self ) -> PROG_EN_R { PROG_EN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Region can be erased" ]
# [ inline ( always ) ]
pub fn erase_en ( & self ) -> ERASE_EN_R { ERASE_EN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Region can be read" ]
# [ inline ( always ) ]
pub fn rd_en ( & mut self ) -> RD_EN_W { RD_EN_W { w : self } } # [ doc = "Bit 1 - Region can be programmed" ]
# [ inline ( always ) ]
pub fn prog_en ( & mut self ) -> PROG_EN_W { PROG_EN_W { w : self } } # [ doc = "Bit 2 - Region can be erased" ]
# [ inline ( always ) ]
pub fn erase_en ( & mut self ) -> ERASE_EN_W { ERASE_EN_W { w : self } } } } # [ doc = "Bank configuration registers configuration enable.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bank_cfg_regwen](bank_cfg_regwen) module" ]
pub type BANK_CFG_REGWEN = crate :: Reg < u32 , _BANK_CFG_REGWEN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _BANK_CFG_REGWEN ; # [ doc = "`read()` method returns [bank_cfg_regwen::R](bank_cfg_regwen::R) reader structure" ]
impl crate :: Readable for BANK_CFG_REGWEN { } # [ doc = "`write(|w| ..)` method takes [bank_cfg_regwen::W](bank_cfg_regwen::W) writer structure" ]
impl crate :: Writable for BANK_CFG_REGWEN { } # [ doc = "Bank configuration registers configuration enable." ]
pub mod bank_cfg_regwen { # [ doc = "Reader of register BANK_CFG_REGWEN" ]
pub type R = crate :: R < u32 , super :: BANK_CFG_REGWEN > ; # [ doc = "Writer for register BANK_CFG_REGWEN" ]
pub type W = crate :: W < u32 , super :: BANK_CFG_REGWEN > ; # [ doc = "Register BANK_CFG_REGWEN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: BANK_CFG_REGWEN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } # [ doc = "Reader of field `BANK`" ]
pub type BANK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BANK`" ]
pub struct BANK_W < 'a > { w : & 'a mut W , } impl < 'a > BANK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Bank register write enable. Once set to 0, it can longer be configured to 1" ]
# [ inline ( always ) ]
pub fn bank ( & self ) -> BANK_R { BANK_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Bank register write enable. Once set to 0, it can longer be configured to 1" ]
# [ inline ( always ) ]
pub fn bank ( & mut self ) -> BANK_W { BANK_W { w : self } } } } # [ doc = "Memory protect bank configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mp_bank_cfg](mp_bank_cfg) module" ]
pub type MP_BANK_CFG = crate :: Reg < u32 , _MP_BANK_CFG > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MP_BANK_CFG ; # [ doc = "`read()` method returns [mp_bank_cfg::R](mp_bank_cfg::R) reader structure" ]
impl crate :: Readable for MP_BANK_CFG { } # [ doc = "`write(|w| ..)` method takes [mp_bank_cfg::W](mp_bank_cfg::W) writer structure" ]
impl crate :: Writable for MP_BANK_CFG { } # [ doc = "Memory protect bank configuration" ]
pub mod mp_bank_cfg { # [ doc = "Reader of register MP_BANK_CFG" ]
pub type R = crate :: R < u32 , super :: MP_BANK_CFG > ; # [ doc = "Writer for register MP_BANK_CFG" ]
pub type W = crate :: W < u32 , super :: MP_BANK_CFG > ; # [ doc = "Register MP_BANK_CFG `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MP_BANK_CFG { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `ERASE_EN0`" ]
pub type ERASE_EN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN0`" ]
pub struct ERASE_EN0_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERASE_EN1`" ]
pub type ERASE_EN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERASE_EN1`" ]
pub struct ERASE_EN1_W < 'a > { w : & 'a mut W , } impl < 'a > ERASE_EN1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Bank wide erase enable for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn erase_en0 ( & self ) -> ERASE_EN0_R { ERASE_EN0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn erase_en1 ( & self ) -> ERASE_EN1_R { ERASE_EN1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Bank wide erase enable for FLASH_CTRL0" ]
# [ inline ( always ) ]
pub fn erase_en0 ( & mut self ) -> ERASE_EN0_W { ERASE_EN0_W { w : self } } # [ doc = "Bit 1 - for FLASH_CTRL1" ]
# [ inline ( always ) ]
pub fn erase_en1 ( & mut self ) -> ERASE_EN1_W { ERASE_EN1_W { w : self } } } } # [ doc = "Flash Operation Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op_status](op_status) module" ]
pub type OP_STATUS = crate :: Reg < u32 , _OP_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _OP_STATUS ; # [ doc = "`read()` method returns [op_status::R](op_status::R) reader structure" ]
impl crate :: Readable for OP_STATUS { } # [ doc = "`write(|w| ..)` method takes [op_status::W](op_status::W) writer structure" ]
impl crate :: Writable for OP_STATUS { } # [ doc = "Flash Operation Status" ]
pub mod op_status { # [ doc = "Reader of register OP_STATUS" ]
pub type R = crate :: R < u32 , super :: OP_STATUS > ; # [ doc = "Writer for register OP_STATUS" ]
pub type W = crate :: W < u32 , super :: OP_STATUS > ; # [ doc = "Register OP_STATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: OP_STATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `done`" ]
pub type DONE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `done`" ]
pub struct DONE_W < 'a > { w : & 'a mut W , } impl < 'a > DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `err`" ]
pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `err`" ]
pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Flash operation done. Set by HW, cleared by SW" ]
# [ inline ( always ) ]
pub fn done ( & self ) -> DONE_R { DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Flash operation error. Set by HW, cleared by SW" ]
# [ inline ( always ) ]
pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Flash operation done. Set by HW, cleared by SW" ]
# [ inline ( always ) ]
pub fn done ( & mut self ) -> DONE_W { DONE_W { w : self } } # [ doc = "Bit 1 - Flash operation error. Set by HW, cleared by SW" ]
# [ inline ( always ) ]
pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } } } # [ doc = "Flash Controller Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module" ]
pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ]
impl crate :: Readable for STATUS { } # [ doc = "Flash Controller Status" ]
pub mod status { # [ doc = "Reader of register STATUS" ]
pub type R = crate :: R < u32 , super :: STATUS > ; # [ doc = "Reader of field `rd_full`" ]
pub type RD_FULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `rd_empty`" ]
pub type RD_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `prog_full`" ]
pub type PROG_FULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `prog_empty`" ]
pub type PROG_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `init_wip`" ]
pub type INIT_WIP_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `error_page`" ]
pub type ERROR_PAGE_R = crate :: R < u16 , u16 > ; # [ doc = "Reader of field `error_bank`" ]
pub type ERROR_BANK_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Flash read fifo full, software must consume data" ]
# [ inline ( always ) ]
pub fn rd_full ( & self ) -> RD_FULL_R { RD_FULL_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Flash read fifo empty" ]
# [ inline ( always ) ]
pub fn rd_empty ( & self ) -> RD_EMPTY_R { RD_EMPTY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Flash program fifo full" ]
# [ inline ( always ) ]
pub fn prog_full ( & self ) -> PROG_FULL_R { PROG_FULL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Flash program fifo empty, software must provide data" ]
# [ inline ( always ) ]
pub fn prog_empty ( & self ) -> PROG_EMPTY_R { PROG_EMPTY_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Flash controller undergoing init" ]
# [ inline ( always ) ]
pub fn init_wip ( & self ) -> INIT_WIP_R { INIT_WIP_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:16 - Flash controller error page." ]
# [ inline ( always ) ]
pub fn error_page ( & self ) -> ERROR_PAGE_R { ERROR_PAGE_R :: new ( ( ( self . bits >> 8 ) & 0x01ff ) as u16 ) } # [ doc = "Bit 17 - Flash controller error bank." ]
# [ inline ( always ) ]
pub fn error_bank ( & self ) -> ERROR_BANK_R { ERROR_BANK_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } } } # [ doc = "Flash Controller Scratch\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scratch](scratch) module" ]
pub type SCRATCH = crate :: Reg < u32 , _SCRATCH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _SCRATCH ; # [ doc = "`read()` method returns [scratch::R](scratch::R) reader structure" ]
impl crate :: Readable for SCRATCH { } # [ doc = "`write(|w| ..)` method takes [scratch::W](scratch::W) writer structure" ]
impl crate :: Writable for SCRATCH { } # [ doc = "Flash Controller Scratch" ]
pub mod scratch { # [ doc = "Reader of register Scratch" ]
pub type R = crate :: R < u32 , super :: SCRATCH > ; # [ doc = "Writer for register Scratch" ]
pub type W = crate :: W < u32 , super :: SCRATCH > ; # [ doc = "Register Scratch `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: SCRATCH { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `data`" ]
pub type DATA_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `data`" ]
pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Flash ctrl scratch register" ]
# [ inline ( always ) ]
pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Flash ctrl scratch register" ]
# [ inline ( always ) ]
pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "Programmable depth where fifos should generate interrupts\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_lvl](fifo_lvl) module" ]
pub type FIFO_LVL = crate :: Reg < u32 , _FIFO_LVL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _FIFO_LVL ; # [ doc = "`read()` method returns [fifo_lvl::R](fifo_lvl::R) reader structure" ]
impl crate :: Readable for FIFO_LVL { } # [ doc = "`write(|w| ..)` method takes [fifo_lvl::W](fifo_lvl::W) writer structure" ]
impl crate :: Writable for FIFO_LVL { } # [ doc = "Programmable depth where fifos should generate interrupts" ]
pub mod fifo_lvl { # [ doc = "Reader of register FIFO_LVL" ]
pub type R = crate :: R < u32 , super :: FIFO_LVL > ; # [ doc = "Writer for register FIFO_LVL" ]
pub type W = crate :: W < u32 , super :: FIFO_LVL > ; # [ doc = "Register FIFO_LVL `reset()`'s with value 0x0f0f" ]
impl crate :: ResetValue for super :: FIFO_LVL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0f0f } } # [ doc = "Reader of field `PROG`" ]
pub type PROG_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PROG`" ]
pub struct PROG_W < 'a > { w : & 'a mut W , } impl < 'a > PROG_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } } # [ doc = "Reader of field `RD`" ]
pub type RD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `RD`" ]
pub struct RD_W < 'a > { w : & 'a mut W , } impl < 'a > RD_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 8 ) ) | ( ( ( value as u32 ) & 0x1f ) << 8 ) ; self . w } } impl R { # [ doc = "Bits 0:4 - When the program fifo drains to this level, trigger an interrupt. Default value is set such that interrupt does not trigger at reset." ]
# [ inline ( always ) ]
pub fn prog ( & self ) -> PROG_R { PROG_R :: new ( ( self . bits & 0x1f ) as u8 ) } # [ doc = "Bits 8:12 - When the read fifo fills to this level, trigger an interrupt. Default value is set such that interrupt does not trigger at reset." ]
# [ inline ( always ) ]
pub fn rd ( & self ) -> RD_R { RD_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) } } impl W { # [ doc = "Bits 0:4 - When the program fifo drains to this level, trigger an interrupt. Default value is set such that interrupt does not trigger at reset." ]
# [ inline ( always ) ]
pub fn prog ( & mut self ) -> PROG_W { PROG_W { w : self } } # [ doc = "Bits 8:12 - When the read fifo fills to this level, trigger an interrupt. Default value is set such that interrupt does not trigger at reset." ]
# [ inline ( always ) ]
pub fn rd ( & mut self ) -> RD_W { RD_W { w : self } } } } # [ doc = "Flash program fifo. The fifo is 16 entries of 4B flash words\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prog_fifo](prog_fifo) module" ]
pub type PROG_FIFO = crate :: Reg < u32 , _PROG_FIFO > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PROG_FIFO ; # [ doc = "`write(|w| ..)` method takes [prog_fifo::W](prog_fifo::W) writer structure" ]
impl crate :: Writable for PROG_FIFO { } # [ doc = "Flash program fifo. The fifo is 16 entries of 4B flash words" ]
pub mod prog_fifo { # [ doc = "Writer for register prog_fifo%s" ]
pub type W = crate :: W < u32 , super :: PROG_FIFO > ; impl W { } } # [ doc = "Flash read fifo. The fifo is 16 entries of 4B flash words\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rd_fifo](rd_fifo) module" ]
pub type RD_FIFO = crate :: Reg < u32 , _RD_FIFO > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RD_FIFO ; # [ doc = "`read()` method returns [rd_fifo::R](rd_fifo::R) reader structure" ]
impl crate :: Readable for RD_FIFO { } # [ doc = "Flash read fifo. The fifo is 16 entries of 4B flash words" ]
pub mod rd_fifo { # [ doc = "Reader of register rd_fifo%s" ]
pub type R = crate :: R < u32 , super :: RD_FIFO > ; impl R { } } } # [ doc = "rv_timer" ]
pub struct RV_TIMER { _marker : PhantomData < * const ( ) > } unsafe impl Send for RV_TIMER { } impl RV_TIMER { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const rv_timer :: RegisterBlock { 0x4008_0000 as * const _ } } impl Deref for RV_TIMER { type Target = rv_timer :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * RV_TIMER :: ptr ( ) } } } # [ doc = "rv_timer" ]
pub mod rv_timer { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Control register" ]
pub ctrl : CTRL , _reserved1 : [ u8 ; 252usize ]
, # [ doc = "0x100 - Configuration for Hart 0" ]
pub cfg0 : CFG0 , # [ doc = "0x104 - Timer value Lower" ]
pub timer_v_lower0 : TIMER_V_LOWER0 , # [ doc = "0x108 - Timer value Upper" ]
pub timer_v_upper0 : TIMER_V_UPPER0 , # [ doc = "0x10c - Timer value Lower" ]
pub compare_lower0_0 : COMPARE_LOWER0_0 , # [ doc = "0x110 - Timer value Upper" ]
pub compare_upper0_0 : COMPARE_UPPER0_0 , # [ doc = "0x114 - Interrupt Enable" ]
pub intr_enable0 : INTR_ENABLE0 , # [ doc = "0x118 - Interrupt Status" ]
pub intr_state0 : INTR_STATE0 , # [ doc = "0x11c - Interrupt test register" ]
pub intr_test0 : INTR_TEST0 , } # [ doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](ctrl) module" ]
pub type CTRL = crate :: Reg < u32 , _CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CTRL ; # [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ]
impl crate :: Readable for CTRL { } # [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ]
impl crate :: Writable for CTRL { } # [ doc = "Control register" ]
pub mod ctrl { # [ doc = "Reader of register CTRL" ]
pub type R = crate :: R < u32 , super :: CTRL > ; # [ doc = "Writer for register CTRL" ]
pub type W = crate :: W < u32 , super :: CTRL > ; # [ doc = "Register CTRL `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `active0`" ]
pub type ACTIVE0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `active0`" ]
pub struct ACTIVE0_W < 'a > { w : & 'a mut W , } impl < 'a > ACTIVE0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - If 1, timer operates for TIMER0" ]
# [ inline ( always ) ]
pub fn active0 ( & self ) -> ACTIVE0_R { ACTIVE0_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - If 1, timer operates for TIMER0" ]
# [ inline ( always ) ]
pub fn active0 ( & mut self ) -> ACTIVE0_W { ACTIVE0_W { w : self } } } } # [ doc = "Configuration for Hart 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfg0](cfg0) module" ]
pub type CFG0 = crate :: Reg < u32 , _CFG0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CFG0 ; # [ doc = "`read()` method returns [cfg0::R](cfg0::R) reader structure" ]
impl crate :: Readable for CFG0 { } # [ doc = "`write(|w| ..)` method takes [cfg0::W](cfg0::W) writer structure" ]
impl crate :: Writable for CFG0 { } # [ doc = "Configuration for Hart 0" ]
pub mod cfg0 { # [ doc = "Reader of register CFG0" ]
pub type R = crate :: R < u32 , super :: CFG0 > ; # [ doc = "Writer for register CFG0" ]
pub type W = crate :: W < u32 , super :: CFG0 > ; # [ doc = "Register CFG0 `reset()`'s with value 0x0001_0000" ]
impl crate :: ResetValue for super :: CFG0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0001_0000 } } # [ doc = "Reader of field `prescale`" ]
pub type PRESCALE_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `prescale`" ]
pub struct PRESCALE_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u32 ) & 0x0fff ) ; self . w } } # [ doc = "Reader of field `step`" ]
pub type STEP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `step`" ]
pub struct STEP_W < 'a > { w : & 'a mut W , } impl < 'a > STEP_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:11 - Prescaler to generate tick" ]
# [ inline ( always ) ]
pub fn prescale ( & self ) -> PRESCALE_R { PRESCALE_R :: new ( ( self . bits & 0x0fff ) as u16 ) } # [ doc = "Bits 16:23 - Incremental value for each tick" ]
# [ inline ( always ) ]
pub fn step ( & self ) -> STEP_R { STEP_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:11 - Prescaler to generate tick" ]
# [ inline ( always ) ]
pub fn prescale ( & mut self ) -> PRESCALE_W { PRESCALE_W { w : self } } # [ doc = "Bits 16:23 - Incremental value for each tick" ]
# [ inline ( always ) ]
pub fn step ( & mut self ) -> STEP_W { STEP_W { w : self } } } } # [ doc = "Timer value Lower\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timer_v_lower0](timer_v_lower0) module" ]
pub type TIMER_V_LOWER0 = crate :: Reg < u32 , _TIMER_V_LOWER0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TIMER_V_LOWER0 ; # [ doc = "`read()` method returns [timer_v_lower0::R](timer_v_lower0::R) reader structure" ]
impl crate :: Readable for TIMER_V_LOWER0 { } # [ doc = "`write(|w| ..)` method takes [timer_v_lower0::W](timer_v_lower0::W) writer structure" ]
impl crate :: Writable for TIMER_V_LOWER0 { } # [ doc = "Timer value Lower" ]
pub mod timer_v_lower0 { # [ doc = "Reader of register TIMER_V_LOWER0" ]
pub type R = crate :: R < u32 , super :: TIMER_V_LOWER0 > ; # [ doc = "Writer for register TIMER_V_LOWER0" ]
pub type W = crate :: W < u32 , super :: TIMER_V_LOWER0 > ; # [ doc = "Register TIMER_V_LOWER0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: TIMER_V_LOWER0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `v`" ]
pub struct V_W < 'a > { w : & 'a mut W , } impl < 'a > V_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Timer value \\[31:0\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Timer value \\[31:0\\]" ]
# [ inline ( always ) ]
pub fn v ( & mut self ) -> V_W { V_W { w : self } } } } # [ doc = "Timer value Upper\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timer_v_upper0](timer_v_upper0) module" ]
pub type TIMER_V_UPPER0 = crate :: Reg < u32 , _TIMER_V_UPPER0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TIMER_V_UPPER0 ; # [ doc = "`read()` method returns [timer_v_upper0::R](timer_v_upper0::R) reader structure" ]
impl crate :: Readable for TIMER_V_UPPER0 { } # [ doc = "`write(|w| ..)` method takes [timer_v_upper0::W](timer_v_upper0::W) writer structure" ]
impl crate :: Writable for TIMER_V_UPPER0 { } # [ doc = "Timer value Upper" ]
pub mod timer_v_upper0 { # [ doc = "Reader of register TIMER_V_UPPER0" ]
pub type R = crate :: R < u32 , super :: TIMER_V_UPPER0 > ; # [ doc = "Writer for register TIMER_V_UPPER0" ]
pub type W = crate :: W < u32 , super :: TIMER_V_UPPER0 > ; # [ doc = "Register TIMER_V_UPPER0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: TIMER_V_UPPER0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `v`" ]
pub struct V_W < 'a > { w : & 'a mut W , } impl < 'a > V_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Timer value \\[63:32\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Timer value \\[63:32\\]" ]
# [ inline ( always ) ]
pub fn v ( & mut self ) -> V_W { V_W { w : self } } } } # [ doc = "Timer value Lower\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [compare_lower0_0](compare_lower0_0) module" ]
pub type COMPARE_LOWER0_0 = crate :: Reg < u32 , _COMPARE_LOWER0_0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _COMPARE_LOWER0_0 ; # [ doc = "`read()` method returns [compare_lower0_0::R](compare_lower0_0::R) reader structure" ]
impl crate :: Readable for COMPARE_LOWER0_0 { } # [ doc = "`write(|w| ..)` method takes [compare_lower0_0::W](compare_lower0_0::W) writer structure" ]
impl crate :: Writable for COMPARE_LOWER0_0 { } # [ doc = "Timer value Lower" ]
pub mod compare_lower0_0 { # [ doc = "Reader of register COMPARE_LOWER0_0" ]
pub type R = crate :: R < u32 , super :: COMPARE_LOWER0_0 > ; # [ doc = "Writer for register COMPARE_LOWER0_0" ]
pub type W = crate :: W < u32 , super :: COMPARE_LOWER0_0 > ; # [ doc = "Register COMPARE_LOWER0_0 `reset()`'s with value 0xffff_ffff" ]
impl crate :: ResetValue for super :: COMPARE_LOWER0_0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0xffff_ffff } } # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `v`" ]
pub struct V_W < 'a > { w : & 'a mut W , } impl < 'a > V_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Timer compare value \\[31:0\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Timer compare value \\[31:0\\]" ]
# [ inline ( always ) ]
pub fn v ( & mut self ) -> V_W { V_W { w : self } } } } # [ doc = "Timer value Upper\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [compare_upper0_0](compare_upper0_0) module" ]
pub type COMPARE_UPPER0_0 = crate :: Reg < u32 , _COMPARE_UPPER0_0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _COMPARE_UPPER0_0 ; # [ doc = "`read()` method returns [compare_upper0_0::R](compare_upper0_0::R) reader structure" ]
impl crate :: Readable for COMPARE_UPPER0_0 { } # [ doc = "`write(|w| ..)` method takes [compare_upper0_0::W](compare_upper0_0::W) writer structure" ]
impl crate :: Writable for COMPARE_UPPER0_0 { } # [ doc = "Timer value Upper" ]
pub mod compare_upper0_0 { # [ doc = "Reader of register COMPARE_UPPER0_0" ]
pub type R = crate :: R < u32 , super :: COMPARE_UPPER0_0 > ; # [ doc = "Writer for register COMPARE_UPPER0_0" ]
pub type W = crate :: W < u32 , super :: COMPARE_UPPER0_0 > ; # [ doc = "Register COMPARE_UPPER0_0 `reset()`'s with value 0xffff_ffff" ]
impl crate :: ResetValue for super :: COMPARE_UPPER0_0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0xffff_ffff } } # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `v`" ]
pub struct V_W < 'a > { w : & 'a mut W , } impl < 'a > V_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Timer compare value \\[63:32\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Timer compare value \\[63:32\\]" ]
# [ inline ( always ) ]
pub fn v ( & mut self ) -> V_W { V_W { w : self } } } } # [ doc = "Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable0](intr_enable0) module" ]
pub type INTR_ENABLE0 = crate :: Reg < u32 , _INTR_ENABLE0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE0 ; # [ doc = "`read()` method returns [intr_enable0::R](intr_enable0::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE0 { } # [ doc = "`write(|w| ..)` method takes [intr_enable0::W](intr_enable0::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE0 { } # [ doc = "Interrupt Enable" ]
pub mod intr_enable0 { # [ doc = "Reader of register INTR_ENABLE0" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE0 > ; # [ doc = "Writer for register INTR_ENABLE0" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE0 > ; # [ doc = "Register INTR_ENABLE0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IE0`" ]
pub type IE0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IE0`" ]
pub struct IE0_W < 'a > { w : & 'a mut W , } impl < 'a > IE0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Interrupt Enable for timer for TIMER0" ]
# [ inline ( always ) ]
pub fn ie0 ( & self ) -> IE0_R { IE0_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Interrupt Enable for timer for TIMER0" ]
# [ inline ( always ) ]
pub fn ie0 ( & mut self ) -> IE0_W { IE0_W { w : self } } } } # [ doc = "Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state0](intr_state0) module" ]
pub type INTR_STATE0 = crate :: Reg < u32 , _INTR_STATE0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE0 ; # [ doc = "`read()` method returns [intr_state0::R](intr_state0::R) reader structure" ]
impl crate :: Readable for INTR_STATE0 { } # [ doc = "`write(|w| ..)` method takes [intr_state0::W](intr_state0::W) writer structure" ]
impl crate :: Writable for INTR_STATE0 { } # [ doc = "Interrupt Status" ]
pub mod intr_state0 { # [ doc = "Reader of register INTR_STATE0" ]
pub type R = crate :: R < u32 , super :: INTR_STATE0 > ; # [ doc = "Writer for register INTR_STATE0" ]
pub type W = crate :: W < u32 , super :: INTR_STATE0 > ; # [ doc = "Register INTR_STATE0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IS0`" ]
pub type IS0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IS0`" ]
pub struct IS0_W < 'a > { w : & 'a mut W , } impl < 'a > IS0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Interrupt status for timer for TIMER0" ]
# [ inline ( always ) ]
pub fn is0 ( & self ) -> IS0_R { IS0_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Interrupt status for timer for TIMER0" ]
# [ inline ( always ) ]
pub fn is0 ( & mut self ) -> IS0_W { IS0_W { w : self } } } } # [ doc = "Interrupt test register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test0](intr_test0) module" ]
pub type INTR_TEST0 = crate :: Reg < u32 , _INTR_TEST0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST0 ; # [ doc = "`write(|w| ..)` method takes [intr_test0::W](intr_test0::W) writer structure" ]
impl crate :: Writable for INTR_TEST0 { } # [ doc = "Interrupt test register" ]
pub mod intr_test0 { # [ doc = "Writer for register INTR_TEST0" ]
pub type W = crate :: W < u32 , super :: INTR_TEST0 > ; # [ doc = "Register INTR_TEST0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `T0`" ]
pub struct T0_W < 'a > { w : & 'a mut W , } impl < 'a > T0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl W { # [ doc = "Bit 0 - Interrupt test for timer for TIMER0" ]
# [ inline ( always ) ]
pub fn t0 ( & mut self ) -> T0_W { T0_W { w : self } } } } } # [ doc = "aes" ]
pub struct AES { _marker : PhantomData < * const ( ) > } unsafe impl Send for AES { } impl AES { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const aes :: RegisterBlock { 0x4011_0000 as * const _ } } impl Deref for AES { type Target = aes :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * AES :: ptr ( ) } } } # [ doc = "aes" ]
pub mod aes { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key : KEY , # [ doc = "0x20 - Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub data_in : DATA_IN , # [ doc = "0x30 - Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub data_out : DATA_OUT , # [ doc = "0x40 - Control Register. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to this register are ignored." ]
pub ctrl : CTRL , # [ doc = "0x44 - Trigger Register" ]
pub trigger : TRIGGER , # [ doc = "0x48 - Status Register" ]
pub status : STATUS , } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct KEY { # [ doc = "0x00 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key0 : self :: key :: KEY0 , # [ doc = "0x04 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key1 : self :: key :: KEY1 , # [ doc = "0x08 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key2 : self :: key :: KEY2 , # [ doc = "0x0c - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key3 : self :: key :: KEY3 , # [ doc = "0x10 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key4 : self :: key :: KEY4 , # [ doc = "0x14 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key5 : self :: key :: KEY5 , # [ doc = "0x18 - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key6 : self :: key :: KEY6 , # [ doc = "0x1c - Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub key7 : self :: key :: KEY7 , } # [ doc = r"Register block" ]
# [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key { # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key0](key0) module" ]
pub type KEY0 = crate :: Reg < u32 , _KEY0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY0 ; # [ doc = "`write(|w| ..)` method takes [key0::W](key0::W) writer structure" ]
impl crate :: Writable for KEY0 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key0 { # [ doc = "Writer for register KEY0" ]
pub type W = crate :: W < u32 , super :: KEY0 > ; # [ doc = "Register KEY0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key0`" ]
pub struct KEY0_W < 'a > { w : & 'a mut W , } impl < 'a > KEY0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY0" ]
# [ inline ( always ) ]
pub fn key0 ( & mut self ) -> KEY0_W { KEY0_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key1](key1) module" ]
pub type KEY1 = crate :: Reg < u32 , _KEY1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY1 ; # [ doc = "`write(|w| ..)` method takes [key1::W](key1::W) writer structure" ]
impl crate :: Writable for KEY1 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key1 { # [ doc = "Writer for register KEY1" ]
pub type W = crate :: W < u32 , super :: KEY1 > ; # [ doc = "Register KEY1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key1`" ]
pub struct KEY1_W < 'a > { w : & 'a mut W , } impl < 'a > KEY1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY1" ]
# [ inline ( always ) ]
pub fn key1 ( & mut self ) -> KEY1_W { KEY1_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key2](key2) module" ]
pub type KEY2 = crate :: Reg < u32 , _KEY2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY2 ; # [ doc = "`write(|w| ..)` method takes [key2::W](key2::W) writer structure" ]
impl crate :: Writable for KEY2 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key2 { # [ doc = "Writer for register KEY2" ]
pub type W = crate :: W < u32 , super :: KEY2 > ; # [ doc = "Register KEY2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key2`" ]
pub struct KEY2_W < 'a > { w : & 'a mut W , } impl < 'a > KEY2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY2" ]
# [ inline ( always ) ]
pub fn key2 ( & mut self ) -> KEY2_W { KEY2_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key3](key3) module" ]
pub type KEY3 = crate :: Reg < u32 , _KEY3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY3 ; # [ doc = "`write(|w| ..)` method takes [key3::W](key3::W) writer structure" ]
impl crate :: Writable for KEY3 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key3 { # [ doc = "Writer for register KEY3" ]
pub type W = crate :: W < u32 , super :: KEY3 > ; # [ doc = "Register KEY3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key3`" ]
pub struct KEY3_W < 'a > { w : & 'a mut W , } impl < 'a > KEY3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY3" ]
# [ inline ( always ) ]
pub fn key3 ( & mut self ) -> KEY3_W { KEY3_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key4](key4) module" ]
pub type KEY4 = crate :: Reg < u32 , _KEY4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY4 ; # [ doc = "`write(|w| ..)` method takes [key4::W](key4::W) writer structure" ]
impl crate :: Writable for KEY4 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key4 { # [ doc = "Writer for register KEY4" ]
pub type W = crate :: W < u32 , super :: KEY4 > ; # [ doc = "Register KEY4 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY4 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key4`" ]
pub struct KEY4_W < 'a > { w : & 'a mut W , } impl < 'a > KEY4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY4" ]
# [ inline ( always ) ]
pub fn key4 ( & mut self ) -> KEY4_W { KEY4_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key5](key5) module" ]
pub type KEY5 = crate :: Reg < u32 , _KEY5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY5 ; # [ doc = "`write(|w| ..)` method takes [key5::W](key5::W) writer structure" ]
impl crate :: Writable for KEY5 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key5 { # [ doc = "Writer for register KEY5" ]
pub type W = crate :: W < u32 , super :: KEY5 > ; # [ doc = "Register KEY5 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY5 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key5`" ]
pub struct KEY5_W < 'a > { w : & 'a mut W , } impl < 'a > KEY5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY5" ]
# [ inline ( always ) ]
pub fn key5 ( & mut self ) -> KEY5_W { KEY5_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key6](key6) module" ]
pub type KEY6 = crate :: Reg < u32 , _KEY6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY6 ; # [ doc = "`write(|w| ..)` method takes [key6::W](key6::W) writer structure" ]
impl crate :: Writable for KEY6 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key6 { # [ doc = "Writer for register KEY6" ]
pub type W = crate :: W < u32 , super :: KEY6 > ; # [ doc = "Register KEY6 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY6 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key6`" ]
pub struct KEY6_W < 'a > { w : & 'a mut W , } impl < 'a > KEY6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY6" ]
# [ inline ( always ) ]
pub fn key6 ( & mut self ) -> KEY6_W { KEY6_W { w : self } } } } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key7](key7) module" ]
pub type KEY7 = crate :: Reg < u32 , _KEY7 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY7 ; # [ doc = "`write(|w| ..)` method takes [key7::W](key7::W) writer structure" ]
impl crate :: Writable for KEY7 { } # [ doc = "Initial Key Registers. Loaded into the internal Full Key register upon starting encryption/decryption of the next block. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to these registers are ignored. All key registers must be updated when the key is changed, regardless of key length (write 0 for unusued bits). The order in which the registers are updated does not matter." ]
pub mod key7 { # [ doc = "Writer for register KEY7" ]
pub type W = crate :: W < u32 , super :: KEY7 > ; # [ doc = "Register KEY7 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY7 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key7`" ]
pub struct KEY7_W < 'a > { w : & 'a mut W , } impl < 'a > KEY7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Initial Key for KEY7" ]
# [ inline ( always ) ]
pub fn key7 ( & mut self ) -> KEY7_W { KEY7_W { w : self } } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct DATA_IN { # [ doc = "0x00 - Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub data_in0 : self :: data_in :: DATA_IN0 , # [ doc = "0x04 - Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub data_in1 : self :: data_in :: DATA_IN1 , # [ doc = "0x08 - Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub data_in2 : self :: data_in :: DATA_IN2 , # [ doc = "0x0c - Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub data_in3 : self :: data_in :: DATA_IN3 , } # [ doc = r"Register block" ]
# [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub mod data_in { # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in0](data_in0) module" ]
pub type DATA_IN0 = crate :: Reg < u32 , _DATA_IN0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_IN0 ; # [ doc = "`write(|w| ..)` method takes [data_in0::W](data_in0::W) writer structure" ]
impl crate :: Writable for DATA_IN0 { } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub mod data_in0 { # [ doc = "Writer for register DATA_IN0" ]
pub type W = crate :: W < u32 , super :: DATA_IN0 > ; # [ doc = "Register DATA_IN0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DATA_IN0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `data_in0`" ]
pub struct DATA_IN0_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_IN0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Input Data for DATA_IN0" ]
# [ inline ( always ) ]
pub fn data_in0 ( & mut self ) -> DATA_IN0_W { DATA_IN0_W { w : self } } } } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in1](data_in1) module" ]
pub type DATA_IN1 = crate :: Reg < u32 , _DATA_IN1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_IN1 ; # [ doc = "`write(|w| ..)` method takes [data_in1::W](data_in1::W) writer structure" ]
impl crate :: Writable for DATA_IN1 { } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub mod data_in1 { # [ doc = "Writer for register DATA_IN1" ]
pub type W = crate :: W < u32 , super :: DATA_IN1 > ; # [ doc = "Register DATA_IN1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DATA_IN1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `data_in1`" ]
pub struct DATA_IN1_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_IN1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Input Data for DATA_IN1" ]
# [ inline ( always ) ]
pub fn data_in1 ( & mut self ) -> DATA_IN1_W { DATA_IN1_W { w : self } } } } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in2](data_in2) module" ]
pub type DATA_IN2 = crate :: Reg < u32 , _DATA_IN2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_IN2 ; # [ doc = "`write(|w| ..)` method takes [data_in2::W](data_in2::W) writer structure" ]
impl crate :: Writable for DATA_IN2 { } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub mod data_in2 { # [ doc = "Writer for register DATA_IN2" ]
pub type W = crate :: W < u32 , super :: DATA_IN2 > ; # [ doc = "Register DATA_IN2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DATA_IN2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `data_in2`" ]
pub struct DATA_IN2_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_IN2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Input Data for DATA_IN2" ]
# [ inline ( always ) ]
pub fn data_in2 ( & mut self ) -> DATA_IN2_W { DATA_IN2_W { w : self } } } } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in3](data_in3) module" ]
pub type DATA_IN3 = crate :: Reg < u32 , _DATA_IN3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_IN3 ; # [ doc = "`write(|w| ..)` method takes [data_in3::W](data_in3::W) writer structure" ]
impl crate :: Writable for DATA_IN3 { } # [ doc = "Input Data Registers. Loaded into the internal State register upon starting encryption/decryption of the next block. After that, the processor can update the Input Data Register. The order in which the registers are written does not matter." ]
pub mod data_in3 { # [ doc = "Writer for register DATA_IN3" ]
pub type W = crate :: W < u32 , super :: DATA_IN3 > ; # [ doc = "Register DATA_IN3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: DATA_IN3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `data_in3`" ]
pub struct DATA_IN3_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_IN3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Input Data for DATA_IN3" ]
# [ inline ( always ) ]
pub fn data_in3 ( & mut self ) -> DATA_IN3_W { DATA_IN3_W { w : self } } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct DATA_OUT { # [ doc = "0x00 - Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub data_out0 : self :: data_out :: DATA_OUT0 , # [ doc = "0x04 - Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub data_out1 : self :: data_out :: DATA_OUT1 , # [ doc = "0x08 - Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub data_out2 : self :: data_out :: DATA_OUT2 , # [ doc = "0x0c - Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub data_out3 : self :: data_out :: DATA_OUT3 , } # [ doc = r"Register block" ]
# [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub mod data_out { # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_out0](data_out0) module" ]
pub type DATA_OUT0 = crate :: Reg < u32 , _DATA_OUT0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_OUT0 ; # [ doc = "`read()` method returns [data_out0::R](data_out0::R) reader structure" ]
impl crate :: Readable for DATA_OUT0 { } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub mod data_out0 { # [ doc = "Reader of register DATA_OUT0" ]
pub type R = crate :: R < u32 , super :: DATA_OUT0 > ; # [ doc = "Reader of field `data_out0`" ]
pub type DATA_OUT0_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Output Data for DATA_OUT0" ]
# [ inline ( always ) ]
pub fn data_out0 ( & self ) -> DATA_OUT0_R { DATA_OUT0_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_out1](data_out1) module" ]
pub type DATA_OUT1 = crate :: Reg < u32 , _DATA_OUT1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_OUT1 ; # [ doc = "`read()` method returns [data_out1::R](data_out1::R) reader structure" ]
impl crate :: Readable for DATA_OUT1 { } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub mod data_out1 { # [ doc = "Reader of register DATA_OUT1" ]
pub type R = crate :: R < u32 , super :: DATA_OUT1 > ; # [ doc = "Reader of field `data_out1`" ]
pub type DATA_OUT1_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Output Data for DATA_OUT1" ]
# [ inline ( always ) ]
pub fn data_out1 ( & self ) -> DATA_OUT1_R { DATA_OUT1_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_out2](data_out2) module" ]
pub type DATA_OUT2 = crate :: Reg < u32 , _DATA_OUT2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_OUT2 ; # [ doc = "`read()` method returns [data_out2::R](data_out2::R) reader structure" ]
impl crate :: Readable for DATA_OUT2 { } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub mod data_out2 { # [ doc = "Reader of register DATA_OUT2" ]
pub type R = crate :: R < u32 , super :: DATA_OUT2 > ; # [ doc = "Reader of field `data_out2`" ]
pub type DATA_OUT2_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Output Data for DATA_OUT2" ]
# [ inline ( always ) ]
pub fn data_out2 ( & self ) -> DATA_OUT2_R { DATA_OUT2_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_out3](data_out3) module" ]
pub type DATA_OUT3 = crate :: Reg < u32 , _DATA_OUT3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DATA_OUT3 ; # [ doc = "`read()` method returns [data_out3::R](data_out3::R) reader structure" ]
impl crate :: Readable for DATA_OUT3 { } # [ doc = "Output Data Register. Holds the output data produced by the AES unit during the last encryption/decryption operation. If FORCE_DATA_OVERWRITE=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten. The order in which the registers are read does not matter." ]
pub mod data_out3 { # [ doc = "Reader of register DATA_OUT3" ]
pub type R = crate :: R < u32 , super :: DATA_OUT3 > ; # [ doc = "Reader of field `data_out3`" ]
pub type DATA_OUT3_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Output Data for DATA_OUT3" ]
# [ inline ( always ) ]
pub fn data_out3 ( & self ) -> DATA_OUT3_R { DATA_OUT3_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } } # [ doc = "Control Register. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to this register are ignored.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](ctrl) module" ]
pub type CTRL = crate :: Reg < u32 , _CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CTRL ; # [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ]
impl crate :: Readable for CTRL { } # [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ]
impl crate :: Writable for CTRL { } # [ doc = "Control Register. Can only be updated when the AES unit is idle. If the AES unit is non-idle, writes to this register are ignored." ]
pub mod ctrl { # [ doc = "Reader of register CTRL" ]
pub type R = crate :: R < u32 , super :: CTRL > ; # [ doc = "Writer for register CTRL" ]
pub type W = crate :: W < u32 , super :: CTRL > ; # [ doc = "Register CTRL `reset()`'s with value 0x02" ]
impl crate :: ResetValue for super :: CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x02 } } # [ doc = "Reader of field `MODE`" ]
pub type MODE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MODE`" ]
pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `KEY_LEN`" ]
pub type KEY_LEN_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `KEY_LEN`" ]
pub struct KEY_LEN_W < 'a > { w : & 'a mut W , } impl < 'a > KEY_LEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 1 ) ) | ( ( ( value as u32 ) & 0x07 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MANUAL_START_TRIGGER`" ]
pub type MANUAL_START_TRIGGER_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MANUAL_START_TRIGGER`" ]
pub struct MANUAL_START_TRIGGER_W < 'a > { w : & 'a mut W , } impl < 'a > MANUAL_START_TRIGGER_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `FORCE_DATA_OVERWRITE`" ]
pub type FORCE_DATA_OVERWRITE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `FORCE_DATA_OVERWRITE`" ]
pub struct FORCE_DATA_OVERWRITE_W < 'a > { w : & 'a mut W , } impl < 'a > FORCE_DATA_OVERWRITE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Select encryption(0) or decryption(1) operating mode of AES unit." ]
# [ inline ( always ) ]
pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bits 1:3 - 3-bit one-hot field to select AES key length: 128 bit (3'b001), 192 bit (3'b010) or 256 bit (3'b100). Invalid input values, i.e., value with multiple bits set, value 3'b000, and value 3'b010 in case 192-bit keys are not supported (because disabled at compile time) are mapped to 3'b001." ]
# [ inline ( always ) ]
pub fn key_len ( & self ) -> KEY_LEN_R { KEY_LEN_R :: new ( ( ( self . bits >> 1 ) & 0x07 ) as u8 ) } # [ doc = "Bit 4 - Controls whether the AES unit should automatically start to encrypt/decrypt when it receives new input data (0) or wait for separate trigger signal before starting (1) (see Trigger Register)." ]
# [ inline ( always ) ]
pub fn manual_start_trigger ( & self ) -> MANUAL_START_TRIGGER_R { MANUAL_START_TRIGGER_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Control whether the AES unit is stalled during the last encryption/decryption cycle if the previous output data has not yet been read (0) or finishes the operation and overwrites the previous output data (1)." ]
# [ inline ( always ) ]
pub fn force_data_overwrite ( & self ) -> FORCE_DATA_OVERWRITE_R { FORCE_DATA_OVERWRITE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Select encryption(0) or decryption(1) operating mode of AES unit." ]
# [ inline ( always ) ]
pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bits 1:3 - 3-bit one-hot field to select AES key length: 128 bit (3'b001), 192 bit (3'b010) or 256 bit (3'b100). Invalid input values, i.e., value with multiple bits set, value 3'b000, and value 3'b010 in case 192-bit keys are not supported (because disabled at compile time) are mapped to 3'b001." ]
# [ inline ( always ) ]
pub fn key_len ( & mut self ) -> KEY_LEN_W { KEY_LEN_W { w : self } } # [ doc = "Bit 4 - Controls whether the AES unit should automatically start to encrypt/decrypt when it receives new input data (0) or wait for separate trigger signal before starting (1) (see Trigger Register)." ]
# [ inline ( always ) ]
pub fn manual_start_trigger ( & mut self ) -> MANUAL_START_TRIGGER_W { MANUAL_START_TRIGGER_W { w : self } } # [ doc = "Bit 5 - Control whether the AES unit is stalled during the last encryption/decryption cycle if the previous output data has not yet been read (0) or finishes the operation and overwrites the previous output data (1)." ]
# [ inline ( always ) ]
pub fn force_data_overwrite ( & mut self ) -> FORCE_DATA_OVERWRITE_W { FORCE_DATA_OVERWRITE_W { w : self } } } } # [ doc = "Trigger Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trigger](trigger) module" ]
pub type TRIGGER = crate :: Reg < u32 , _TRIGGER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TRIGGER ; # [ doc = "`write(|w| ..)` method takes [trigger::W](trigger::W) writer structure" ]
impl crate :: Writable for TRIGGER { } # [ doc = "Trigger Register" ]
pub mod trigger { # [ doc = "Writer for register TRIGGER" ]
pub type W = crate :: W < u32 , super :: TRIGGER > ; # [ doc = "Register TRIGGER `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: TRIGGER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `START`" ]
pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `KEY_CLEAR`" ]
pub struct KEY_CLEAR_W < 'a > { w : & 'a mut W , } impl < 'a > KEY_CLEAR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `DATA_IN_CLEAR`" ]
pub struct DATA_IN_CLEAR_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_IN_CLEAR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `DATA_OUT_CLEAR`" ]
pub struct DATA_OUT_CLEAR_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_OUT_CLEAR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl W { # [ doc = "Bit 0 - Keep AES unit paused (0) or trigger the encryption/decryption of one data block (1)." ]
# [ inline ( always ) ]
pub fn start ( & mut self ) -> START_W { START_W { w : self } } # [ doc = "Bit 1 - Keep current values in Initial Key, internal Full Key and Decryption Key registers (0) or clear those registers (1)." ]
# [ inline ( always ) ]
pub fn key_clear ( & mut self ) -> KEY_CLEAR_W { KEY_CLEAR_W { w : self } } # [ doc = "Bit 2 - Keep current values in input registers (0) or clear those registers (1)." ]
# [ inline ( always ) ]
pub fn data_in_clear ( & mut self ) -> DATA_IN_CLEAR_W { DATA_IN_CLEAR_W { w : self } } # [ doc = "Bit 3 - Keep current values in output registers (0) or clear those registers (1)." ]
# [ inline ( always ) ]
pub fn data_out_clear ( & mut self ) -> DATA_OUT_CLEAR_W { DATA_OUT_CLEAR_W { w : self } } } } # [ doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module" ]
pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ]
impl crate :: Readable for STATUS { } # [ doc = "Status Register" ]
pub mod status { # [ doc = "Reader of register STATUS" ]
pub type R = crate :: R < u32 , super :: STATUS > ; # [ doc = "Reader of field `IDLE`" ]
pub type IDLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `STALL`" ]
pub type STALL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `OUTPUT_VALID`" ]
pub type OUTPUT_VALID_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `INPUT_READY`" ]
pub type INPUT_READY_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - The AES unit is idle (0) or busy (1)." ]
# [ inline ( always ) ]
pub fn idle ( & self ) -> IDLE_R { IDLE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - The AES unit is not stalled (0) or stalled (1) because there is previous output data that must be read by the processor before the AES unit can overwrite this data." ]
# [ inline ( always ) ]
pub fn stall ( & self ) -> STALL_R { STALL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - The AES unit has no valid output (0) or has valid output data (1)." ]
# [ inline ( always ) ]
pub fn output_valid ( & self ) -> OUTPUT_VALID_R { OUTPUT_VALID_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - The AES unit is ready (1) to receive new data input via the DATA_IN registers or the present values in the DATA_IN registers have not yet been loaded into the module (0)." ]
# [ inline ( always ) ]
pub fn input_ready ( & self ) -> INPUT_READY_R { INPUT_READY_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } } } # [ doc = "hmac" ]
pub struct HMAC { _marker : PhantomData < * const ( ) > } unsafe impl Send for HMAC { } impl HMAC { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const hmac :: RegisterBlock { 0x4012_0000 as * const _ } } impl Deref for HMAC { type Target = hmac :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * HMAC :: ptr ( ) } } } # [ doc = "hmac" ]
pub mod hmac { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - HMAC Configuration register. The register is updated when the engine is in Idle. If the software updates the register while the engine computes the hash, the updated value is discarded." ]
pub cfg : CFG , # [ doc = "0x10 - HMAC command register" ]
pub cmd : CMD , # [ doc = "0x14 - HMAC Status register" ]
pub status : STATUS , # [ doc = "0x18 - HMAC Error Code" ]
pub err_code : ERR_CODE , # [ doc = "0x1c - Randomize internal secret registers. If CPU writes value into the register, the value is used to randomize internal variables such as secret key, internal state machine, or hash value." ]
pub wipe_secret : WIPE_SECRET , # [ doc = "0x20 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key : KEY , # [ doc = "0x40 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest : DIGEST , # [ doc = "0x60 - Received Message Length calculated by the HMAC in bits \\[31:0\\]
Message is byte granularity. lower 3bits \\[2:0\\]
are ignored." ]
pub msg_length_lower : MSG_LENGTH_LOWER , # [ doc = "0x64 - Received Message Length calculated by the HMAC in bits \\[63:32\\]" ]
pub msg_length_upper : MSG_LENGTH_UPPER , _reserved12 : [ u8 ; 1944usize ]
, # [ doc = "0x800 - Message FIFO. Any write to this window will be appended to the FIFO. Only the lower \\[1:0\\]
bits of the address matter to writes within the window (for correctly dealing with non 32-bit writes)" ]
pub msg_fifo : [ MSG_FIFO ; 512 ]
, } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct KEY { # [ doc = "0x00 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key0 : self :: key :: KEY0 , # [ doc = "0x04 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key1 : self :: key :: KEY1 , # [ doc = "0x08 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key2 : self :: key :: KEY2 , # [ doc = "0x0c - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key3 : self :: key :: KEY3 , # [ doc = "0x10 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key4 : self :: key :: KEY4 , # [ doc = "0x14 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key5 : self :: key :: KEY5 , # [ doc = "0x18 - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key6 : self :: key :: KEY6 , # [ doc = "0x1c - HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub key7 : self :: key :: KEY7 , } # [ doc = r"Register block" ]
# [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key { # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key0](key0) module" ]
pub type KEY0 = crate :: Reg < u32 , _KEY0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY0 ; # [ doc = "`write(|w| ..)` method takes [key0::W](key0::W) writer structure" ]
impl crate :: Writable for KEY0 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key0 { # [ doc = "Writer for register KEY0" ]
pub type W = crate :: W < u32 , super :: KEY0 > ; # [ doc = "Register KEY0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key0`" ]
pub struct KEY0_W < 'a > { w : & 'a mut W , } impl < 'a > KEY0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC0" ]
# [ inline ( always ) ]
pub fn key0 ( & mut self ) -> KEY0_W { KEY0_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key1](key1) module" ]
pub type KEY1 = crate :: Reg < u32 , _KEY1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY1 ; # [ doc = "`write(|w| ..)` method takes [key1::W](key1::W) writer structure" ]
impl crate :: Writable for KEY1 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key1 { # [ doc = "Writer for register KEY1" ]
pub type W = crate :: W < u32 , super :: KEY1 > ; # [ doc = "Register KEY1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key1`" ]
pub struct KEY1_W < 'a > { w : & 'a mut W , } impl < 'a > KEY1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC1" ]
# [ inline ( always ) ]
pub fn key1 ( & mut self ) -> KEY1_W { KEY1_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key2](key2) module" ]
pub type KEY2 = crate :: Reg < u32 , _KEY2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY2 ; # [ doc = "`write(|w| ..)` method takes [key2::W](key2::W) writer structure" ]
impl crate :: Writable for KEY2 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key2 { # [ doc = "Writer for register KEY2" ]
pub type W = crate :: W < u32 , super :: KEY2 > ; # [ doc = "Register KEY2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key2`" ]
pub struct KEY2_W < 'a > { w : & 'a mut W , } impl < 'a > KEY2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC2" ]
# [ inline ( always ) ]
pub fn key2 ( & mut self ) -> KEY2_W { KEY2_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key3](key3) module" ]
pub type KEY3 = crate :: Reg < u32 , _KEY3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY3 ; # [ doc = "`write(|w| ..)` method takes [key3::W](key3::W) writer structure" ]
impl crate :: Writable for KEY3 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key3 { # [ doc = "Writer for register KEY3" ]
pub type W = crate :: W < u32 , super :: KEY3 > ; # [ doc = "Register KEY3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key3`" ]
pub struct KEY3_W < 'a > { w : & 'a mut W , } impl < 'a > KEY3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC3" ]
# [ inline ( always ) ]
pub fn key3 ( & mut self ) -> KEY3_W { KEY3_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key4](key4) module" ]
pub type KEY4 = crate :: Reg < u32 , _KEY4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY4 ; # [ doc = "`write(|w| ..)` method takes [key4::W](key4::W) writer structure" ]
impl crate :: Writable for KEY4 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key4 { # [ doc = "Writer for register KEY4" ]
pub type W = crate :: W < u32 , super :: KEY4 > ; # [ doc = "Register KEY4 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY4 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key4`" ]
pub struct KEY4_W < 'a > { w : & 'a mut W , } impl < 'a > KEY4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC4" ]
# [ inline ( always ) ]
pub fn key4 ( & mut self ) -> KEY4_W { KEY4_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key5](key5) module" ]
pub type KEY5 = crate :: Reg < u32 , _KEY5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY5 ; # [ doc = "`write(|w| ..)` method takes [key5::W](key5::W) writer structure" ]
impl crate :: Writable for KEY5 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key5 { # [ doc = "Writer for register KEY5" ]
pub type W = crate :: W < u32 , super :: KEY5 > ; # [ doc = "Register KEY5 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY5 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key5`" ]
pub struct KEY5_W < 'a > { w : & 'a mut W , } impl < 'a > KEY5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC5" ]
# [ inline ( always ) ]
pub fn key5 ( & mut self ) -> KEY5_W { KEY5_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key6](key6) module" ]
pub type KEY6 = crate :: Reg < u32 , _KEY6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY6 ; # [ doc = "`write(|w| ..)` method takes [key6::W](key6::W) writer structure" ]
impl crate :: Writable for KEY6 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key6 { # [ doc = "Writer for register KEY6" ]
pub type W = crate :: W < u32 , super :: KEY6 > ; # [ doc = "Register KEY6 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY6 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key6`" ]
pub struct KEY6_W < 'a > { w : & 'a mut W , } impl < 'a > KEY6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC6" ]
# [ inline ( always ) ]
pub fn key6 ( & mut self ) -> KEY6_W { KEY6_W { w : self } } } } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key7](key7) module" ]
pub type KEY7 = crate :: Reg < u32 , _KEY7 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _KEY7 ; # [ doc = "`write(|w| ..)` method takes [key7::W](key7::W) writer structure" ]
impl crate :: Writable for KEY7 { } # [ doc = "HMAC Secret Key SHA256 assumes secret key is hashed 256bit key. Order of the secret key is: key\\[255:0\\]
= {KEY0, KEY1, KEY2, ... , KEY7}; The registers are allowed to be updated when the engine is in Idle state. If the engine computes the hash, it discards any attempts to update the secret keys and report an error." ]
pub mod key7 { # [ doc = "Writer for register KEY7" ]
pub type W = crate :: W < u32 , super :: KEY7 > ; # [ doc = "Register KEY7 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: KEY7 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `key7`" ]
pub struct KEY7_W < 'a > { w : & 'a mut W , } impl < 'a > KEY7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Secret Key for HMAC7" ]
# [ inline ( always ) ]
pub fn key7 ( & mut self ) -> KEY7_W { KEY7_W { w : self } } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct DIGEST { # [ doc = "0x00 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest0 : self :: digest :: DIGEST0 , # [ doc = "0x04 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest1 : self :: digest :: DIGEST1 , # [ doc = "0x08 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest2 : self :: digest :: DIGEST2 , # [ doc = "0x0c - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest3 : self :: digest :: DIGEST3 , # [ doc = "0x10 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest4 : self :: digest :: DIGEST4 , # [ doc = "0x14 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest5 : self :: digest :: DIGEST5 , # [ doc = "0x18 - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest6 : self :: digest :: DIGEST6 , # [ doc = "0x1c - Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub digest7 : self :: digest :: DIGEST7 , } # [ doc = r"Register block" ]
# [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest { # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest0](digest0) module" ]
pub type DIGEST0 = crate :: Reg < u32 , _DIGEST0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST0 ; # [ doc = "`read()` method returns [digest0::R](digest0::R) reader structure" ]
impl crate :: Readable for DIGEST0 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest0 { # [ doc = "Reader of register DIGEST0" ]
pub type R = crate :: R < u32 , super :: DIGEST0 > ; # [ doc = "Reader of field `digest0`" ]
pub type DIGEST0_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC0" ]
# [ inline ( always ) ]
pub fn digest0 ( & self ) -> DIGEST0_R { DIGEST0_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest1](digest1) module" ]
pub type DIGEST1 = crate :: Reg < u32 , _DIGEST1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST1 ; # [ doc = "`read()` method returns [digest1::R](digest1::R) reader structure" ]
impl crate :: Readable for DIGEST1 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest1 { # [ doc = "Reader of register DIGEST1" ]
pub type R = crate :: R < u32 , super :: DIGEST1 > ; # [ doc = "Reader of field `digest1`" ]
pub type DIGEST1_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC1" ]
# [ inline ( always ) ]
pub fn digest1 ( & self ) -> DIGEST1_R { DIGEST1_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest2](digest2) module" ]
pub type DIGEST2 = crate :: Reg < u32 , _DIGEST2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST2 ; # [ doc = "`read()` method returns [digest2::R](digest2::R) reader structure" ]
impl crate :: Readable for DIGEST2 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest2 { # [ doc = "Reader of register DIGEST2" ]
pub type R = crate :: R < u32 , super :: DIGEST2 > ; # [ doc = "Reader of field `digest2`" ]
pub type DIGEST2_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC2" ]
# [ inline ( always ) ]
pub fn digest2 ( & self ) -> DIGEST2_R { DIGEST2_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest3](digest3) module" ]
pub type DIGEST3 = crate :: Reg < u32 , _DIGEST3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST3 ; # [ doc = "`read()` method returns [digest3::R](digest3::R) reader structure" ]
impl crate :: Readable for DIGEST3 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest3 { # [ doc = "Reader of register DIGEST3" ]
pub type R = crate :: R < u32 , super :: DIGEST3 > ; # [ doc = "Reader of field `digest3`" ]
pub type DIGEST3_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC3" ]
# [ inline ( always ) ]
pub fn digest3 ( & self ) -> DIGEST3_R { DIGEST3_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest4](digest4) module" ]
pub type DIGEST4 = crate :: Reg < u32 , _DIGEST4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST4 ; # [ doc = "`read()` method returns [digest4::R](digest4::R) reader structure" ]
impl crate :: Readable for DIGEST4 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest4 { # [ doc = "Reader of register DIGEST4" ]
pub type R = crate :: R < u32 , super :: DIGEST4 > ; # [ doc = "Reader of field `digest4`" ]
pub type DIGEST4_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC4" ]
# [ inline ( always ) ]
pub fn digest4 ( & self ) -> DIGEST4_R { DIGEST4_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest5](digest5) module" ]
pub type DIGEST5 = crate :: Reg < u32 , _DIGEST5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST5 ; # [ doc = "`read()` method returns [digest5::R](digest5::R) reader structure" ]
impl crate :: Readable for DIGEST5 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest5 { # [ doc = "Reader of register DIGEST5" ]
pub type R = crate :: R < u32 , super :: DIGEST5 > ; # [ doc = "Reader of field `digest5`" ]
pub type DIGEST5_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC5" ]
# [ inline ( always ) ]
pub fn digest5 ( & self ) -> DIGEST5_R { DIGEST5_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest6](digest6) module" ]
pub type DIGEST6 = crate :: Reg < u32 , _DIGEST6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST6 ; # [ doc = "`read()` method returns [digest6::R](digest6::R) reader structure" ]
impl crate :: Readable for DIGEST6 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest6 { # [ doc = "Reader of register DIGEST6" ]
pub type R = crate :: R < u32 , super :: DIGEST6 > ; # [ doc = "Reader of field `digest6`" ]
pub type DIGEST6_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC6" ]
# [ inline ( always ) ]
pub fn digest6 ( & self ) -> DIGEST6_R { DIGEST6_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [digest7](digest7) module" ]
pub type DIGEST7 = crate :: Reg < u32 , _DIGEST7 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _DIGEST7 ; # [ doc = "`read()` method returns [digest7::R](digest7::R) reader structure" ]
impl crate :: Readable for DIGEST7 { } # [ doc = "Digest output. If HMAC is disabled, the register shows result of SHA256 Order of the digest is: digest\\[255:0\\]
= {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST7};" ]
pub mod digest7 { # [ doc = "Reader of register DIGEST7" ]
pub type R = crate :: R < u32 , super :: DIGEST7 > ; # [ doc = "Reader of field `digest7`" ]
pub type DIGEST7_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - 32-bit chunk of 256-bit Digest for HMAC7" ]
# [ inline ( always ) ]
pub fn digest7 ( & self ) -> DIGEST7_R { DIGEST7_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `hmac_done`" ]
pub type HMAC_DONE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `hmac_done`" ]
pub struct HMAC_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `fifo_full`" ]
pub type FIFO_FULL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `fifo_full`" ]
pub struct FIFO_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > FIFO_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `hmac_err`" ]
pub type HMAC_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `hmac_err`" ]
pub struct HMAC_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } impl R { # [ doc = "Bit 0 - HMAC-256 completes a message with key" ]
# [ inline ( always ) ]
pub fn hmac_done ( & self ) -> HMAC_DONE_R { HMAC_DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Message FIFO full condition" ]
# [ inline ( always ) ]
pub fn fifo_full ( & self ) -> FIFO_FULL_R { FIFO_FULL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - HMAC error occurred. ERR_CODE register shows which error occurred" ]
# [ inline ( always ) ]
pub fn hmac_err ( & self ) -> HMAC_ERR_R { HMAC_ERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - HMAC-256 completes a message with key" ]
# [ inline ( always ) ]
pub fn hmac_done ( & mut self ) -> HMAC_DONE_W { HMAC_DONE_W { w : self } } # [ doc = "Bit 1 - Message FIFO full condition" ]
# [ inline ( always ) ]
pub fn fifo_full ( & mut self ) -> FIFO_FULL_W { FIFO_FULL_W { w : self } } # [ doc = "Bit 2 - HMAC error occurred. ERR_CODE register shows which error occurred" ]
# [ inline ( always ) ]
pub fn hmac_err ( & mut self ) -> HMAC_ERR_W { HMAC_ERR_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `hmac_done`" ]
pub type HMAC_DONE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `hmac_done`" ]
pub struct HMAC_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `fifo_full`" ]
pub type FIFO_FULL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `fifo_full`" ]
pub struct FIFO_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > FIFO_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `hmac_err`" ]
pub type HMAC_ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `hmac_err`" ]
pub struct HMAC_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.hmac_done is set" ]
# [ inline ( always ) ]
pub fn hmac_done ( & self ) -> HMAC_DONE_R { HMAC_DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.fifo_full is set" ]
# [ inline ( always ) ]
pub fn fifo_full ( & self ) -> FIFO_FULL_R { FIFO_FULL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.hmac_err is set" ]
# [ inline ( always ) ]
pub fn hmac_err ( & self ) -> HMAC_ERR_R { HMAC_ERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.hmac_done is set" ]
# [ inline ( always ) ]
pub fn hmac_done ( & mut self ) -> HMAC_DONE_W { HMAC_DONE_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.fifo_full is set" ]
# [ inline ( always ) ]
pub fn fifo_full ( & mut self ) -> FIFO_FULL_W { FIFO_FULL_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.hmac_err is set" ]
# [ inline ( always ) ]
pub fn hmac_err ( & mut self ) -> HMAC_ERR_W { HMAC_ERR_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `hmac_done`" ]
pub struct HMAC_DONE_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_DONE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `fifo_full`" ]
pub struct FIFO_FULL_W < 'a > { w : & 'a mut W , } impl < 'a > FIFO_FULL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `hmac_err`" ]
pub struct HMAC_ERR_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_ERR_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.hmac_done to 1" ]
# [ inline ( always ) ]
pub fn hmac_done ( & mut self ) -> HMAC_DONE_W { HMAC_DONE_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.fifo_full to 1" ]
# [ inline ( always ) ]
pub fn fifo_full ( & mut self ) -> FIFO_FULL_W { FIFO_FULL_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.hmac_err to 1" ]
# [ inline ( always ) ]
pub fn hmac_err ( & mut self ) -> HMAC_ERR_W { HMAC_ERR_W { w : self } } } } # [ doc = "HMAC Configuration register. The register is updated when the engine is in Idle. If the software updates the register while the engine computes the hash, the updated value is discarded.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api)." ]
pub type CFG = crate :: Reg < u32 , _CFG > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CFG ; # [ doc = "`read()` method returns [cfg::R](cfg::R) reader structure" ]
impl crate :: Readable for CFG { } # [ doc = "`write(|w| ..)` method takes [cfg::W](cfg::W) writer structure" ]
impl crate :: Writable for CFG { } # [ doc = "HMAC Configuration register. The register is updated when the engine is in Idle. If the software updates the register while the engine computes the hash, the updated value is discarded." ]
pub mod cfg { # [ doc = "Reader of register CFG" ]
pub type R = crate :: R < u32 , super :: CFG > ; # [ doc = "Writer for register CFG" ]
pub type W = crate :: W < u32 , super :: CFG > ; # [ doc = "Register CFG `reset()`'s with value 0x04" ]
impl crate :: ResetValue for super :: CFG { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x04 } } # [ doc = "Reader of field `hmac_en`" ]
pub type HMAC_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `hmac_en`" ]
pub struct HMAC_EN_W < 'a > { w : & 'a mut W , } impl < 'a > HMAC_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `sha_en`" ]
pub type SHA_EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `sha_en`" ]
pub struct SHA_EN_W < 'a > { w : & 'a mut W , } impl < 'a > SHA_EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `endian_swap`" ]
pub type ENDIAN_SWAP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `endian_swap`" ]
pub struct ENDIAN_SWAP_W < 'a > { w : & 'a mut W , } impl < 'a > ENDIAN_SWAP_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `digest_swap`" ]
pub type DIGEST_SWAP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `digest_swap`" ]
pub struct DIGEST_SWAP_W < 'a > { w : & 'a mut W , } impl < 'a > DIGEST_SWAP_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - HMAC datapath enable. If this bit is 1, HMAC operates when `hash_start` toggles." ]
# [ inline ( always ) ]
pub fn hmac_en ( & self ) -> HMAC_EN_R { HMAC_EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SHA256 enable. If 0, SHA engine won't initiate compression, this is used to stop operation of the SHA engine until configuration has been done. When the SHA engine is disabled the digest is cleared." ]
# [ inline ( always ) ]
pub fn sha_en ( & self ) -> SHA_EN_R { SHA_EN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Convert TL-UL wdata\\[31:0\\]
to big-endian style {w\\[7:0\\], w\\[15:8\\], .. }" ]
# [ inline ( always ) ]
pub fn endian_swap ( & self ) -> ENDIAN_SWAP_R { ENDIAN_SWAP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - DIGEST register byte-order. If 1, it swaps each DIGEST registers' byte-order." ]
# [ inline ( always ) ]
pub fn digest_swap ( & self ) -> DIGEST_SWAP_R { DIGEST_SWAP_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - HMAC datapath enable. If this bit is 1, HMAC operates when `hash_start` toggles." ]
# [ inline ( always ) ]
pub fn hmac_en ( & mut self ) -> HMAC_EN_W { HMAC_EN_W { w : self } } # [ doc = "Bit 1 - SHA256 enable. If 0, SHA engine won't initiate compression, this is used to stop operation of the SHA engine until configuration has been done. When the SHA engine is disabled the digest is cleared." ]
# [ inline ( always ) ]
pub fn sha_en ( & mut self ) -> SHA_EN_W { SHA_EN_W { w : self } } # [ doc = "Bit 2 - Convert TL-UL wdata\\[31:0\\]
to big-endian style {w\\[7:0\\], w\\[15:8\\], .. }" ]
# [ inline ( always ) ]
pub fn endian_swap ( & mut self ) -> ENDIAN_SWAP_W { ENDIAN_SWAP_W { w : self } } # [ doc = "Bit 3 - DIGEST register byte-order. If 1, it swaps each DIGEST registers' byte-order." ]
# [ inline ( always ) ]
pub fn digest_swap ( & mut self ) -> DIGEST_SWAP_W { DIGEST_SWAP_W { w : self } } } } # [ doc = "HMAC command register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmd](cmd) module" ]
pub type CMD = crate :: Reg < u32 , _CMD > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CMD ; # [ doc = "`write(|w| ..)` method takes [cmd::W](cmd::W) writer structure" ]
impl crate :: Writable for CMD { } # [ doc = "HMAC command register" ]
pub mod cmd { # [ doc = "Writer for register CMD" ]
pub type W = crate :: W < u32 , super :: CMD > ; # [ doc = "Register CMD `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CMD { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `hash_start`" ]
pub struct HASH_START_W < 'a > { w : & 'a mut W , } impl < 'a > HASH_START_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `hash_process`" ]
pub struct HASH_PROCESS_W < 'a > { w : & 'a mut W , } impl < 'a > HASH_PROCESS_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } impl W { # [ doc = "Bit 0 - If writes 1 into this field, SHA256 or HMAC begins its operation. CPU should configure relative information first, such as message_length, secret_key." ]
# [ inline ( always ) ]
pub fn hash_start ( & mut self ) -> HASH_START_W { HASH_START_W { w : self } } # [ doc = "Bit 1 - If writes 1 into this field, SHA256 or HMAC calculates the digest or signing based on currently received message." ]
# [ inline ( always ) ]
pub fn hash_process ( & mut self ) -> HASH_PROCESS_W { HASH_PROCESS_W { w : self } } } } # [ doc = "HMAC Status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module" ]
pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ]
impl crate :: Readable for STATUS { } # [ doc = "HMAC Status register" ]
pub mod status { # [ doc = "Reader of register STATUS" ]
pub type R = crate :: R < u32 , super :: STATUS > ; # [ doc = "Reader of field `fifo_empty`" ]
pub type FIFO_EMPTY_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `fifo_full`" ]
pub type FIFO_FULL_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `fifo_depth`" ]
pub type FIFO_DEPTH_R = crate :: R < u8 , u8 > ; impl R { # [ doc = "Bit 0 - FIFO empty" ]
# [ inline ( always ) ]
pub fn fifo_empty ( & self ) -> FIFO_EMPTY_R { FIFO_EMPTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - FIFO full. Data written to the FIFO whilst it is full will cause back-pressure on the interconnect" ]
# [ inline ( always ) ]
pub fn fifo_full ( & self ) -> FIFO_FULL_R { FIFO_FULL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:8 - FIFO entry count." ]
# [ inline ( always ) ]
pub fn fifo_depth ( & self ) -> FIFO_DEPTH_R { FIFO_DEPTH_R :: new ( ( ( self . bits >> 4 ) & 0x1f ) as u8 ) } } } # [ doc = "HMAC Error Code\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [err_code](err_code) module" ]
pub type ERR_CODE = crate :: Reg < u32 , _ERR_CODE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ERR_CODE ; # [ doc = "`read()` method returns [err_code::R](err_code::R) reader structure" ]
impl crate :: Readable for ERR_CODE { } # [ doc = "HMAC Error Code" ]
pub mod err_code { # [ doc = "Reader of register ERR_CODE" ]
pub type R = crate :: R < u32 , super :: ERR_CODE > ; # [ doc = "Reader of field `err_code`" ]
pub type ERR_CODE_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - If error interrupt occurs, this register has information of error cause. Please take a look at `hw/ip/hmac/rtl/hmac_pkg.sv:err_code_e enum type." ]
# [ inline ( always ) ]
pub fn err_code ( & self ) -> ERR_CODE_R { ERR_CODE_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Randomize internal secret registers. If CPU writes value into the register, the value is used to randomize internal variables such as secret key, internal state machine, or hash value.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wipe_secret](wipe_secret) module" ]
pub type WIPE_SECRET = crate :: Reg < u32 , _WIPE_SECRET > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _WIPE_SECRET ; # [ doc = "`write(|w| ..)` method takes [wipe_secret::W](wipe_secret::W) writer structure" ]
impl crate :: Writable for WIPE_SECRET { } # [ doc = "Randomize internal secret registers. If CPU writes value into the register, the value is used to randomize internal variables such as secret key, internal state machine, or hash value." ]
pub mod wipe_secret { # [ doc = "Writer for register WIPE_SECRET" ]
pub type W = crate :: W < u32 , super :: WIPE_SECRET > ; # [ doc = "Register WIPE_SECRET `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: WIPE_SECRET { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `secret`" ]
pub struct SECRET_W < 'a > { w : & 'a mut W , } impl < 'a > SECRET_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl W { # [ doc = "Bits 0:31 - Secret value" ]
# [ inline ( always ) ]
pub fn secret ( & mut self ) -> SECRET_W { SECRET_W { w : self } } } } # [ doc = "Received Message Length calculated by the HMAC in bits \\[31:0\\]
Message is byte granularity. lower 3bits \\[2:0\\]
are ignored.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msg_length_lower](msg_length_lower) module" ]
pub type MSG_LENGTH_LOWER = crate :: Reg < u32 , _MSG_LENGTH_LOWER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MSG_LENGTH_LOWER ; # [ doc = "`read()` method returns [msg_length_lower::R](msg_length_lower::R) reader structure" ]
impl crate :: Readable for MSG_LENGTH_LOWER { } # [ doc = "Received Message Length calculated by the HMAC in bits \\[31:0\\]
Message is byte granularity. lower 3bits \\[2:0\\]
are ignored." ]
pub mod msg_length_lower { # [ doc = "Reader of register MSG_LENGTH_LOWER" ]
pub type R = crate :: R < u32 , super :: MSG_LENGTH_LOWER > ; # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Message Length \\[31:0\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Received Message Length calculated by the HMAC in bits \\[63:32\\]\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msg_length_upper](msg_length_upper) module" ]
pub type MSG_LENGTH_UPPER = crate :: Reg < u32 , _MSG_LENGTH_UPPER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MSG_LENGTH_UPPER ; # [ doc = "`read()` method returns [msg_length_upper::R](msg_length_upper::R) reader structure" ]
impl crate :: Readable for MSG_LENGTH_UPPER { } # [ doc = "Received Message Length calculated by the HMAC in bits \\[63:32\\]" ]
pub mod msg_length_upper { # [ doc = "Reader of register MSG_LENGTH_UPPER" ]
pub type R = crate :: R < u32 , super :: MSG_LENGTH_UPPER > ; # [ doc = "Reader of field `v`" ]
pub type V_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - Message Length \\[63:32\\]" ]
# [ inline ( always ) ]
pub fn v ( & self ) -> V_R { V_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "Message FIFO. Any write to this window will be appended to the FIFO. Only the lower \\[1:0\\]
bits of the address matter to writes within the window (for correctly dealing with non 32-bit writes)\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msg_fifo](msg_fifo) module" ]
pub type MSG_FIFO = crate :: Reg < u32 , _MSG_FIFO > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MSG_FIFO ; # [ doc = "`write(|w| ..)` method takes [msg_fifo::W](msg_fifo::W) writer structure" ]
impl crate :: Writable for MSG_FIFO { } # [ doc = "Message FIFO. Any write to this window will be appended to the FIFO. Only the lower \\[1:0\\]
bits of the address matter to writes within the window (for correctly dealing with non 32-bit writes)" ]
pub mod msg_fifo { # [ doc = "Writer for register MSG_FIFO%s" ]
pub type W = crate :: W < u32 , super :: MSG_FIFO > ; impl W { } } } # [ doc = "rv_plic" ]
pub struct RV_PLIC { _marker : PhantomData < * const ( ) > } unsafe impl Send for RV_PLIC { } impl RV_PLIC { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const rv_plic :: RegisterBlock { 0x4009_0000 as * const _ } } impl Deref for RV_PLIC { type Target = rv_plic :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * RV_PLIC :: ptr ( ) } } } # [ doc = "rv_plic" ]
pub mod rv_plic { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Pending" ]
pub ip : IP , # [ doc = "0x08 - Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub le : LE , # [ doc = "0x10 - Interrupt Source 0 Priority" ]
pub prio0 : PRIO0 , _reserved3 : [ u8 ; 4usize ]
, # [ doc = "0x14 - Interrupt Source 1 Priority" ]
pub prio1 : PRIO1 , _reserved4 : [ u8 ; 4usize ]
, # [ doc = "0x18 - Interrupt Source 2 Priority" ]
pub prio2 : PRIO2 , _reserved5 : [ u8 ; 4usize ]
, # [ doc = "0x1c - Interrupt Source 3 Priority" ]
pub prio3 : PRIO3 , _reserved6 : [ u8 ; 4usize ]
, # [ doc = "0x20 - Interrupt Source 4 Priority" ]
pub prio4 : PRIO4 , _reserved7 : [ u8 ; 4usize ]
, # [ doc = "0x24 - Interrupt Source 5 Priority" ]
pub prio5 : PRIO5 , _reserved8 : [ u8 ; 4usize ]
, # [ doc = "0x28 - Interrupt Source 6 Priority" ]
pub prio6 : PRIO6 , _reserved9 : [ u8 ; 4usize ]
, # [ doc = "0x2c - Interrupt Source 7 Priority" ]
pub prio7 : PRIO7 , _reserved10 : [ u8 ; 4usize ]
, # [ doc = "0x30 - Interrupt Source 8 Priority" ]
pub prio8 : PRIO8 , _reserved11 : [ u8 ; 4usize ]
, # [ doc = "0x34 - Interrupt Source 9 Priority" ]
pub prio9 : PRIO9 , _reserved12 : [ u8 ; 4usize ]
, # [ doc = "0x38 - Interrupt Source 10 Priority" ]
pub prio10 : PRIO10 , _reserved13 : [ u8 ; 4usize ]
, # [ doc = "0x3c - Interrupt Source 11 Priority" ]
pub prio11 : PRIO11 , _reserved14 : [ u8 ; 4usize ]
, # [ doc = "0x40 - Interrupt Source 12 Priority" ]
pub prio12 : PRIO12 , _reserved15 : [ u8 ; 4usize ]
, # [ doc = "0x44 - Interrupt Source 13 Priority" ]
pub prio13 : PRIO13 , _reserved16 : [ u8 ; 4usize ]
, # [ doc = "0x48 - Interrupt Source 14 Priority" ]
pub prio14 : PRIO14 , _reserved17 : [ u8 ; 4usize ]
, # [ doc = "0x4c - Interrupt Source 15 Priority" ]
pub prio15 : PRIO15 , _reserved18 : [ u8 ; 4usize ]
, # [ doc = "0x50 - Interrupt Source 16 Priority" ]
pub prio16 : PRIO16 , _reserved19 : [ u8 ; 4usize ]
, # [ doc = "0x54 - Interrupt Source 17 Priority" ]
pub prio17 : PRIO17 , _reserved20 : [ u8 ; 4usize ]
, # [ doc = "0x58 - Interrupt Source 18 Priority" ]
pub prio18 : PRIO18 , _reserved21 : [ u8 ; 4usize ]
, # [ doc = "0x5c - Interrupt Source 19 Priority" ]
pub prio19 : PRIO19 , _reserved22 : [ u8 ; 4usize ]
, # [ doc = "0x60 - Interrupt Source 20 Priority" ]
pub prio20 : PRIO20 , _reserved23 : [ u8 ; 4usize ]
, # [ doc = "0x64 - Interrupt Source 21 Priority" ]
pub prio21 : PRIO21 , _reserved24 : [ u8 ; 4usize ]
, # [ doc = "0x68 - Interrupt Source 22 Priority" ]
pub prio22 : PRIO22 , _reserved25 : [ u8 ; 4usize ]
, # [ doc = "0x6c - Interrupt Source 23 Priority" ]
pub prio23 : PRIO23 , _reserved26 : [ u8 ; 4usize ]
, # [ doc = "0x70 - Interrupt Source 24 Priority" ]
pub prio24 : PRIO24 , _reserved27 : [ u8 ; 4usize ]
, # [ doc = "0x74 - Interrupt Source 25 Priority" ]
pub prio25 : PRIO25 , _reserved28 : [ u8 ; 4usize ]
, # [ doc = "0x78 - Interrupt Source 26 Priority" ]
pub prio26 : PRIO26 , _reserved29 : [ u8 ; 4usize ]
, # [ doc = "0x7c - Interrupt Source 27 Priority" ]
pub prio27 : PRIO27 , _reserved30 : [ u8 ; 4usize ]
, # [ doc = "0x80 - Interrupt Source 28 Priority" ]
pub prio28 : PRIO28 , _reserved31 : [ u8 ; 4usize ]
, # [ doc = "0x84 - Interrupt Source 29 Priority" ]
pub prio29 : PRIO29 , _reserved32 : [ u8 ; 4usize ]
, # [ doc = "0x88 - Interrupt Source 30 Priority" ]
pub prio30 : PRIO30 , _reserved33 : [ u8 ; 4usize ]
, # [ doc = "0x8c - Interrupt Source 31 Priority" ]
pub prio31 : PRIO31 , _reserved34 : [ u8 ; 4usize ]
, # [ doc = "0x90 - Interrupt Source 32 Priority" ]
pub prio32 : PRIO32 , _reserved35 : [ u8 ; 4usize ]
, # [ doc = "0x94 - Interrupt Source 33 Priority" ]
pub prio33 : PRIO33 , _reserved36 : [ u8 ; 4usize ]
, # [ doc = "0x98 - Interrupt Source 34 Priority" ]
pub prio34 : PRIO34 , _reserved37 : [ u8 ; 4usize ]
, # [ doc = "0x9c - Interrupt Source 35 Priority" ]
pub prio35 : PRIO35 , _reserved38 : [ u8 ; 4usize ]
, # [ doc = "0xa0 - Interrupt Source 36 Priority" ]
pub prio36 : PRIO36 , _reserved39 : [ u8 ; 4usize ]
, # [ doc = "0xa4 - Interrupt Source 37 Priority" ]
pub prio37 : PRIO37 , _reserved40 : [ u8 ; 4usize ]
, # [ doc = "0xa8 - Interrupt Source 38 Priority" ]
pub prio38 : PRIO38 , _reserved41 : [ u8 ; 4usize ]
, # [ doc = "0xac - Interrupt Source 39 Priority" ]
pub prio39 : PRIO39 , _reserved42 : [ u8 ; 4usize ]
, # [ doc = "0xb0 - Interrupt Source 40 Priority" ]
pub prio40 : PRIO40 , _reserved43 : [ u8 ; 4usize ]
, # [ doc = "0xb4 - Interrupt Source 41 Priority" ]
pub prio41 : PRIO41 , _reserved44 : [ u8 ; 4usize ]
, # [ doc = "0xb8 - Interrupt Source 42 Priority" ]
pub prio42 : PRIO42 , _reserved45 : [ u8 ; 4usize ]
, # [ doc = "0xbc - Interrupt Source 43 Priority" ]
pub prio43 : PRIO43 , _reserved46 : [ u8 ; 4usize ]
, # [ doc = "0xc0 - Interrupt Source 44 Priority" ]
pub prio44 : PRIO44 , _reserved47 : [ u8 ; 4usize ]
, # [ doc = "0xc4 - Interrupt Source 45 Priority" ]
pub prio45 : PRIO45 , _reserved48 : [ u8 ; 4usize ]
, # [ doc = "0xc8 - Interrupt Source 46 Priority" ]
pub prio46 : PRIO46 , _reserved49 : [ u8 ; 4usize ]
, # [ doc = "0xcc - Interrupt Source 47 Priority" ]
pub prio47 : PRIO47 , _reserved50 : [ u8 ; 4usize ]
, # [ doc = "0xd0 - Interrupt Source 48 Priority" ]
pub prio48 : PRIO48 , _reserved51 : [ u8 ; 4usize ]
, # [ doc = "0xd4 - Interrupt Source 49 Priority" ]
pub prio49 : PRIO49 , _reserved52 : [ u8 ; 4usize ]
, # [ doc = "0xd8 - Interrupt Source 50 Priority" ]
pub prio50 : PRIO50 , _reserved53 : [ u8 ; 4usize ]
, # [ doc = "0xdc - Interrupt Source 51 Priority" ]
pub prio51 : PRIO51 , _reserved54 : [ u8 ; 4usize ]
, # [ doc = "0xe0 - Interrupt Source 52 Priority" ]
pub prio52 : PRIO52 , _reserved55 : [ u8 ; 4usize ]
, # [ doc = "0xe4 - Interrupt Source 53 Priority" ]
pub prio53 : PRIO53 , _reserved56 : [ u8 ; 4usize ]
, # [ doc = "0xe8 - Interrupt Source 54 Priority" ]
pub prio54 : PRIO54 , _reserved57 : [ u8 ; 4usize ]
, # [ doc = "0xec - Interrupt Source 55 Priority" ]
pub prio55 : PRIO55 , _reserved58 : [ u8 ; 4usize ]
, # [ doc = "0xf0 - Interrupt Source 56 Priority" ]
pub prio56 : PRIO56 , _reserved59 : [ u8 ; 4usize ]
, # [ doc = "0xf4 - Interrupt Source 57 Priority" ]
pub prio57 : PRIO57 , _reserved60 : [ u8 ; 4usize ]
, # [ doc = "0xf8 - Interrupt Source 58 Priority" ]
pub prio58 : PRIO58 , _reserved61 : [ u8 ; 4usize ]
, # [ doc = "0xfc - Interrupt Source 59 Priority" ]
pub prio59 : PRIO59 , _reserved62 : [ u8 ; 4usize ]
, # [ doc = "0x100 - Interrupt Source 60 Priority" ]
pub prio60 : PRIO60 , _reserved63 : [ u8 ; 4usize ]
, # [ doc = "0x104 - Interrupt Source 61 Priority" ]
pub prio61 : PRIO61 , _reserved64 : [ u8 ; 4usize ]
, # [ doc = "0x108 - Interrupt Source 62 Priority" ]
pub prio62 : PRIO62 , _reserved65 : [ u8 ; 248usize ]
, # [ doc = "0x200 - Interrupt Enable for Target 0" ]
pub ie0 : IE0 , # [ doc = "0x208 - Threshold of priority for Target 0" ]
pub threshold0 : THRESHOLD0 , _reserved67 : [ u8 ; 4usize ]
, # [ doc = "0x20c - Claim interrupt by read, complete interrupt by write for Target 0. Value read/written is interrupt ID. Reading a value of 0 means no pending interrupts." ]
pub cc0 : CC0 , _reserved68 : [ u8 ; 4usize ]
, # [ doc = "0x210 - msip for Hart 0. Write 1 to here asserts software interrupt for Hart msip_o\\[0\\], write 0 to clear." ]
pub msip0 : MSIP0 , } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct IP { # [ doc = "0x00 - Interrupt Pending" ]
pub ip0 : self :: ip :: IP0 , # [ doc = "0x04 - Interrupt Pending" ]
pub ip1 : self :: ip :: IP1 , } # [ doc = r"Register block" ]
# [ doc = "Interrupt Pending" ]
pub mod ip { # [ doc = "Interrupt Pending\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ip0](ip0) module" ]
pub type IP0 = crate :: Reg < u32 , _IP0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _IP0 ; # [ doc = "`read()` method returns [ip0::R](ip0::R) reader structure" ]
impl crate :: Readable for IP0 { } # [ doc = "Interrupt Pending" ]
pub mod ip0 { # [ doc = "Reader of register IP0" ]
pub type R = crate :: R < u32 , super :: IP0 > ; # [ doc = "Reader of field `P0`" ]
pub type P0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P1`" ]
pub type P1_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P2`" ]
pub type P2_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P3`" ]
pub type P3_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P4`" ]
pub type P4_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P5`" ]
pub type P5_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P6`" ]
pub type P6_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P7`" ]
pub type P7_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P8`" ]
pub type P8_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P9`" ]
pub type P9_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P10`" ]
pub type P10_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P11`" ]
pub type P11_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P12`" ]
pub type P12_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P13`" ]
pub type P13_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P14`" ]
pub type P14_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P15`" ]
pub type P15_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P16`" ]
pub type P16_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P17`" ]
pub type P17_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P18`" ]
pub type P18_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P19`" ]
pub type P19_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P20`" ]
pub type P20_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P21`" ]
pub type P21_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P22`" ]
pub type P22_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P23`" ]
pub type P23_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P24`" ]
pub type P24_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P25`" ]
pub type P25_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P26`" ]
pub type P26_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P27`" ]
pub type P27_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P28`" ]
pub type P28_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P29`" ]
pub type P29_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P30`" ]
pub type P30_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P31`" ]
pub type P31_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Interrupt Pending of Source for RV_PLIC0" ]
# [ inline ( always ) ]
pub fn p0 ( & self ) -> P0_R { P0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC1" ]
# [ inline ( always ) ]
pub fn p1 ( & self ) -> P1_R { P1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC2" ]
# [ inline ( always ) ]
pub fn p2 ( & self ) -> P2_R { P2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC3" ]
# [ inline ( always ) ]
pub fn p3 ( & self ) -> P3_R { P3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC4" ]
# [ inline ( always ) ]
pub fn p4 ( & self ) -> P4_R { P4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC5" ]
# [ inline ( always ) ]
pub fn p5 ( & self ) -> P5_R { P5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC6" ]
# [ inline ( always ) ]
pub fn p6 ( & self ) -> P6_R { P6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC7" ]
# [ inline ( always ) ]
pub fn p7 ( & self ) -> P7_R { P7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC8" ]
# [ inline ( always ) ]
pub fn p8 ( & self ) -> P8_R { P8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC9" ]
# [ inline ( always ) ]
pub fn p9 ( & self ) -> P9_R { P9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC10" ]
# [ inline ( always ) ]
pub fn p10 ( & self ) -> P10_R { P10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC11" ]
# [ inline ( always ) ]
pub fn p11 ( & self ) -> P11_R { P11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC12" ]
# [ inline ( always ) ]
pub fn p12 ( & self ) -> P12_R { P12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC13" ]
# [ inline ( always ) ]
pub fn p13 ( & self ) -> P13_R { P13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC14" ]
# [ inline ( always ) ]
pub fn p14 ( & self ) -> P14_R { P14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC15" ]
# [ inline ( always ) ]
pub fn p15 ( & self ) -> P15_R { P15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC16" ]
# [ inline ( always ) ]
pub fn p16 ( & self ) -> P16_R { P16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC17" ]
# [ inline ( always ) ]
pub fn p17 ( & self ) -> P17_R { P17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC18" ]
# [ inline ( always ) ]
pub fn p18 ( & self ) -> P18_R { P18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC19" ]
# [ inline ( always ) ]
pub fn p19 ( & self ) -> P19_R { P19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC20" ]
# [ inline ( always ) ]
pub fn p20 ( & self ) -> P20_R { P20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC21" ]
# [ inline ( always ) ]
pub fn p21 ( & self ) -> P21_R { P21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC22" ]
# [ inline ( always ) ]
pub fn p22 ( & self ) -> P22_R { P22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC23" ]
# [ inline ( always ) ]
pub fn p23 ( & self ) -> P23_R { P23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC24" ]
# [ inline ( always ) ]
pub fn p24 ( & self ) -> P24_R { P24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC25" ]
# [ inline ( always ) ]
pub fn p25 ( & self ) -> P25_R { P25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC26" ]
# [ inline ( always ) ]
pub fn p26 ( & self ) -> P26_R { P26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC27" ]
# [ inline ( always ) ]
pub fn p27 ( & self ) -> P27_R { P27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC28" ]
# [ inline ( always ) ]
pub fn p28 ( & self ) -> P28_R { P28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC29" ]
# [ inline ( always ) ]
pub fn p29 ( & self ) -> P29_R { P29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC30" ]
# [ inline ( always ) ]
pub fn p30 ( & self ) -> P30_R { P30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } # [ doc = "Bit 31 - for RV_PLIC31" ]
# [ inline ( always ) ]
pub fn p31 ( & self ) -> P31_R { P31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) } } } # [ doc = "Interrupt Pending\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ip1](ip1) module" ]
pub type IP1 = crate :: Reg < u32 , _IP1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _IP1 ; # [ doc = "`read()` method returns [ip1::R](ip1::R) reader structure" ]
impl crate :: Readable for IP1 { } # [ doc = "Interrupt Pending" ]
pub mod ip1 { # [ doc = "Reader of register IP1" ]
pub type R = crate :: R < u32 , super :: IP1 > ; # [ doc = "Reader of field `P32`" ]
pub type P32_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P33`" ]
pub type P33_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P34`" ]
pub type P34_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P35`" ]
pub type P35_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P36`" ]
pub type P36_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P37`" ]
pub type P37_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P38`" ]
pub type P38_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P39`" ]
pub type P39_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P40`" ]
pub type P40_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P41`" ]
pub type P41_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P42`" ]
pub type P42_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P43`" ]
pub type P43_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P44`" ]
pub type P44_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P45`" ]
pub type P45_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P46`" ]
pub type P46_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P47`" ]
pub type P47_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P48`" ]
pub type P48_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P49`" ]
pub type P49_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P50`" ]
pub type P50_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P51`" ]
pub type P51_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P52`" ]
pub type P52_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P53`" ]
pub type P53_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P54`" ]
pub type P54_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P55`" ]
pub type P55_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P56`" ]
pub type P56_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P57`" ]
pub type P57_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P58`" ]
pub type P58_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P59`" ]
pub type P59_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P60`" ]
pub type P60_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P61`" ]
pub type P61_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `P62`" ]
pub type P62_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Interrupt Pending of Source for RV_PLIC32" ]
# [ inline ( always ) ]
pub fn p32 ( & self ) -> P32_R { P32_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC33" ]
# [ inline ( always ) ]
pub fn p33 ( & self ) -> P33_R { P33_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC34" ]
# [ inline ( always ) ]
pub fn p34 ( & self ) -> P34_R { P34_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC35" ]
# [ inline ( always ) ]
pub fn p35 ( & self ) -> P35_R { P35_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC36" ]
# [ inline ( always ) ]
pub fn p36 ( & self ) -> P36_R { P36_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC37" ]
# [ inline ( always ) ]
pub fn p37 ( & self ) -> P37_R { P37_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC38" ]
# [ inline ( always ) ]
pub fn p38 ( & self ) -> P38_R { P38_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC39" ]
# [ inline ( always ) ]
pub fn p39 ( & self ) -> P39_R { P39_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC40" ]
# [ inline ( always ) ]
pub fn p40 ( & self ) -> P40_R { P40_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC41" ]
# [ inline ( always ) ]
pub fn p41 ( & self ) -> P41_R { P41_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC42" ]
# [ inline ( always ) ]
pub fn p42 ( & self ) -> P42_R { P42_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC43" ]
# [ inline ( always ) ]
pub fn p43 ( & self ) -> P43_R { P43_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC44" ]
# [ inline ( always ) ]
pub fn p44 ( & self ) -> P44_R { P44_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC45" ]
# [ inline ( always ) ]
pub fn p45 ( & self ) -> P45_R { P45_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC46" ]
# [ inline ( always ) ]
pub fn p46 ( & self ) -> P46_R { P46_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC47" ]
# [ inline ( always ) ]
pub fn p47 ( & self ) -> P47_R { P47_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC48" ]
# [ inline ( always ) ]
pub fn p48 ( & self ) -> P48_R { P48_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC49" ]
# [ inline ( always ) ]
pub fn p49 ( & self ) -> P49_R { P49_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC50" ]
# [ inline ( always ) ]
pub fn p50 ( & self ) -> P50_R { P50_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC51" ]
# [ inline ( always ) ]
pub fn p51 ( & self ) -> P51_R { P51_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC52" ]
# [ inline ( always ) ]
pub fn p52 ( & self ) -> P52_R { P52_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC53" ]
# [ inline ( always ) ]
pub fn p53 ( & self ) -> P53_R { P53_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC54" ]
# [ inline ( always ) ]
pub fn p54 ( & self ) -> P54_R { P54_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC55" ]
# [ inline ( always ) ]
pub fn p55 ( & self ) -> P55_R { P55_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC56" ]
# [ inline ( always ) ]
pub fn p56 ( & self ) -> P56_R { P56_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC57" ]
# [ inline ( always ) ]
pub fn p57 ( & self ) -> P57_R { P57_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC58" ]
# [ inline ( always ) ]
pub fn p58 ( & self ) -> P58_R { P58_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC59" ]
# [ inline ( always ) ]
pub fn p59 ( & self ) -> P59_R { P59_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC60" ]
# [ inline ( always ) ]
pub fn p60 ( & self ) -> P60_R { P60_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC61" ]
# [ inline ( always ) ]
pub fn p61 ( & self ) -> P61_R { P61_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC62" ]
# [ inline ( always ) ]
pub fn p62 ( & self ) -> P62_R { P62_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct LE { # [ doc = "0x00 - Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub le0 : self :: le :: LE0 , # [ doc = "0x04 - Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub le1 : self :: le :: LE1 , } # [ doc = r"Register block" ]
# [ doc = "Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub mod le { # [ doc = "Interrupt Source mode. 0: Level, 1: Edge-triggered\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [le0](le0) module" ]
pub type LE0 = crate :: Reg < u32 , _LE0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LE0 ; # [ doc = "`read()` method returns [le0::R](le0::R) reader structure" ]
impl crate :: Readable for LE0 { } # [ doc = "`write(|w| ..)` method takes [le0::W](le0::W) writer structure" ]
impl crate :: Writable for LE0 { } # [ doc = "Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub mod le0 { # [ doc = "Reader of register LE0" ]
pub type R = crate :: R < u32 , super :: LE0 > ; # [ doc = "Writer for register LE0" ]
pub type W = crate :: W < u32 , super :: LE0 > ; # [ doc = "Register LE0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LE0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `LE0`" ]
pub type LE0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE0`" ]
pub struct LE0_W < 'a > { w : & 'a mut W , } impl < 'a > LE0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LE1`" ]
pub type LE1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE1`" ]
pub struct LE1_W < 'a > { w : & 'a mut W , } impl < 'a > LE1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `LE2`" ]
pub type LE2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE2`" ]
pub struct LE2_W < 'a > { w : & 'a mut W , } impl < 'a > LE2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `LE3`" ]
pub type LE3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE3`" ]
pub struct LE3_W < 'a > { w : & 'a mut W , } impl < 'a > LE3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `LE4`" ]
pub type LE4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE4`" ]
pub struct LE4_W < 'a > { w : & 'a mut W , } impl < 'a > LE4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `LE5`" ]
pub type LE5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE5`" ]
pub struct LE5_W < 'a > { w : & 'a mut W , } impl < 'a > LE5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `LE6`" ]
pub type LE6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE6`" ]
pub struct LE6_W < 'a > { w : & 'a mut W , } impl < 'a > LE6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `LE7`" ]
pub type LE7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE7`" ]
pub struct LE7_W < 'a > { w : & 'a mut W , } impl < 'a > LE7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `LE8`" ]
pub type LE8_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE8`" ]
pub struct LE8_W < 'a > { w : & 'a mut W , } impl < 'a > LE8_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `LE9`" ]
pub type LE9_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE9`" ]
pub struct LE9_W < 'a > { w : & 'a mut W , } impl < 'a > LE9_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `LE10`" ]
pub type LE10_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE10`" ]
pub struct LE10_W < 'a > { w : & 'a mut W , } impl < 'a > LE10_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Reader of field `LE11`" ]
pub type LE11_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE11`" ]
pub struct LE11_W < 'a > { w : & 'a mut W , } impl < 'a > LE11_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `LE12`" ]
pub type LE12_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE12`" ]
pub struct LE12_W < 'a > { w : & 'a mut W , } impl < 'a > LE12_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `LE13`" ]
pub type LE13_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE13`" ]
pub struct LE13_W < 'a > { w : & 'a mut W , } impl < 'a > LE13_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `LE14`" ]
pub type LE14_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE14`" ]
pub struct LE14_W < 'a > { w : & 'a mut W , } impl < 'a > LE14_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } } # [ doc = "Reader of field `LE15`" ]
pub type LE15_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE15`" ]
pub struct LE15_W < 'a > { w : & 'a mut W , } impl < 'a > LE15_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `LE16`" ]
pub type LE16_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE16`" ]
pub struct LE16_W < 'a > { w : & 'a mut W , } impl < 'a > LE16_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `LE17`" ]
pub type LE17_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE17`" ]
pub struct LE17_W < 'a > { w : & 'a mut W , } impl < 'a > LE17_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `LE18`" ]
pub type LE18_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE18`" ]
pub struct LE18_W < 'a > { w : & 'a mut W , } impl < 'a > LE18_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } # [ doc = "Reader of field `LE19`" ]
pub type LE19_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE19`" ]
pub struct LE19_W < 'a > { w : & 'a mut W , } impl < 'a > LE19_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } } # [ doc = "Reader of field `LE20`" ]
pub type LE20_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE20`" ]
pub struct LE20_W < 'a > { w : & 'a mut W , } impl < 'a > LE20_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `LE21`" ]
pub type LE21_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE21`" ]
pub struct LE21_W < 'a > { w : & 'a mut W , } impl < 'a > LE21_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Reader of field `LE22`" ]
pub type LE22_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE22`" ]
pub struct LE22_W < 'a > { w : & 'a mut W , } impl < 'a > LE22_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Reader of field `LE23`" ]
pub type LE23_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE23`" ]
pub struct LE23_W < 'a > { w : & 'a mut W , } impl < 'a > LE23_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Reader of field `LE24`" ]
pub type LE24_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE24`" ]
pub struct LE24_W < 'a > { w : & 'a mut W , } impl < 'a > LE24_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } } # [ doc = "Reader of field `LE25`" ]
pub type LE25_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE25`" ]
pub struct LE25_W < 'a > { w : & 'a mut W , } impl < 'a > LE25_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } } # [ doc = "Reader of field `LE26`" ]
pub type LE26_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE26`" ]
pub struct LE26_W < 'a > { w : & 'a mut W , } impl < 'a > LE26_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } } # [ doc = "Reader of field `LE27`" ]
pub type LE27_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE27`" ]
pub struct LE27_W < 'a > { w : & 'a mut W , } impl < 'a > LE27_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Reader of field `LE28`" ]
pub type LE28_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE28`" ]
pub struct LE28_W < 'a > { w : & 'a mut W , } impl < 'a > LE28_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Reader of field `LE29`" ]
pub type LE29_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE29`" ]
pub struct LE29_W < 'a > { w : & 'a mut W , } impl < 'a > LE29_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Reader of field `LE30`" ]
pub type LE30_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE30`" ]
pub struct LE30_W < 'a > { w : & 'a mut W , } impl < 'a > LE30_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } # [ doc = "Reader of field `LE31`" ]
pub type LE31_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE31`" ]
pub struct LE31_W < 'a > { w : & 'a mut W , } impl < 'a > LE31_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } } impl R { # [ doc = "Bit 0 - L0E1 for RV_PLIC0" ]
# [ inline ( always ) ]
pub fn le0 ( & self ) -> LE0_R { LE0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC1" ]
# [ inline ( always ) ]
pub fn le1 ( & self ) -> LE1_R { LE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC2" ]
# [ inline ( always ) ]
pub fn le2 ( & self ) -> LE2_R { LE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC3" ]
# [ inline ( always ) ]
pub fn le3 ( & self ) -> LE3_R { LE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC4" ]
# [ inline ( always ) ]
pub fn le4 ( & self ) -> LE4_R { LE4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC5" ]
# [ inline ( always ) ]
pub fn le5 ( & self ) -> LE5_R { LE5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC6" ]
# [ inline ( always ) ]
pub fn le6 ( & self ) -> LE6_R { LE6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC7" ]
# [ inline ( always ) ]
pub fn le7 ( & self ) -> LE7_R { LE7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC8" ]
# [ inline ( always ) ]
pub fn le8 ( & self ) -> LE8_R { LE8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC9" ]
# [ inline ( always ) ]
pub fn le9 ( & self ) -> LE9_R { LE9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC10" ]
# [ inline ( always ) ]
pub fn le10 ( & self ) -> LE10_R { LE10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC11" ]
# [ inline ( always ) ]
pub fn le11 ( & self ) -> LE11_R { LE11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC12" ]
# [ inline ( always ) ]
pub fn le12 ( & self ) -> LE12_R { LE12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC13" ]
# [ inline ( always ) ]
pub fn le13 ( & self ) -> LE13_R { LE13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC14" ]
# [ inline ( always ) ]
pub fn le14 ( & self ) -> LE14_R { LE14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC15" ]
# [ inline ( always ) ]
pub fn le15 ( & self ) -> LE15_R { LE15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC16" ]
# [ inline ( always ) ]
pub fn le16 ( & self ) -> LE16_R { LE16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC17" ]
# [ inline ( always ) ]
pub fn le17 ( & self ) -> LE17_R { LE17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC18" ]
# [ inline ( always ) ]
pub fn le18 ( & self ) -> LE18_R { LE18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC19" ]
# [ inline ( always ) ]
pub fn le19 ( & self ) -> LE19_R { LE19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC20" ]
# [ inline ( always ) ]
pub fn le20 ( & self ) -> LE20_R { LE20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC21" ]
# [ inline ( always ) ]
pub fn le21 ( & self ) -> LE21_R { LE21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC22" ]
# [ inline ( always ) ]
pub fn le22 ( & self ) -> LE22_R { LE22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC23" ]
# [ inline ( always ) ]
pub fn le23 ( & self ) -> LE23_R { LE23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC24" ]
# [ inline ( always ) ]
pub fn le24 ( & self ) -> LE24_R { LE24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC25" ]
# [ inline ( always ) ]
pub fn le25 ( & self ) -> LE25_R { LE25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC26" ]
# [ inline ( always ) ]
pub fn le26 ( & self ) -> LE26_R { LE26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC27" ]
# [ inline ( always ) ]
pub fn le27 ( & self ) -> LE27_R { LE27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC28" ]
# [ inline ( always ) ]
pub fn le28 ( & self ) -> LE28_R { LE28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC29" ]
# [ inline ( always ) ]
pub fn le29 ( & self ) -> LE29_R { LE29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC30" ]
# [ inline ( always ) ]
pub fn le30 ( & self ) -> LE30_R { LE30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } # [ doc = "Bit 31 - for RV_PLIC31" ]
# [ inline ( always ) ]
pub fn le31 ( & self ) -> LE31_R { LE31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - L0E1 for RV_PLIC0" ]
# [ inline ( always ) ]
pub fn le0 ( & mut self ) -> LE0_W { LE0_W { w : self } } # [ doc = "Bit 1 - for RV_PLIC1" ]
# [ inline ( always ) ]
pub fn le1 ( & mut self ) -> LE1_W { LE1_W { w : self } } # [ doc = "Bit 2 - for RV_PLIC2" ]
# [ inline ( always ) ]
pub fn le2 ( & mut self ) -> LE2_W { LE2_W { w : self } } # [ doc = "Bit 3 - for RV_PLIC3" ]
# [ inline ( always ) ]
pub fn le3 ( & mut self ) -> LE3_W { LE3_W { w : self } } # [ doc = "Bit 4 - for RV_PLIC4" ]
# [ inline ( always ) ]
pub fn le4 ( & mut self ) -> LE4_W { LE4_W { w : self } } # [ doc = "Bit 5 - for RV_PLIC5" ]
# [ inline ( always ) ]
pub fn le5 ( & mut self ) -> LE5_W { LE5_W { w : self } } # [ doc = "Bit 6 - for RV_PLIC6" ]
# [ inline ( always ) ]
pub fn le6 ( & mut self ) -> LE6_W { LE6_W { w : self } } # [ doc = "Bit 7 - for RV_PLIC7" ]
# [ inline ( always ) ]
pub fn le7 ( & mut self ) -> LE7_W { LE7_W { w : self } } # [ doc = "Bit 8 - for RV_PLIC8" ]
# [ inline ( always ) ]
pub fn le8 ( & mut self ) -> LE8_W { LE8_W { w : self } } # [ doc = "Bit 9 - for RV_PLIC9" ]
# [ inline ( always ) ]
pub fn le9 ( & mut self ) -> LE9_W { LE9_W { w : self } } # [ doc = "Bit 10 - for RV_PLIC10" ]
# [ inline ( always ) ]
pub fn le10 ( & mut self ) -> LE10_W { LE10_W { w : self } } # [ doc = "Bit 11 - for RV_PLIC11" ]
# [ inline ( always ) ]
pub fn le11 ( & mut self ) -> LE11_W { LE11_W { w : self } } # [ doc = "Bit 12 - for RV_PLIC12" ]
# [ inline ( always ) ]
pub fn le12 ( & mut self ) -> LE12_W { LE12_W { w : self } } # [ doc = "Bit 13 - for RV_PLIC13" ]
# [ inline ( always ) ]
pub fn le13 ( & mut self ) -> LE13_W { LE13_W { w : self } } # [ doc = "Bit 14 - for RV_PLIC14" ]
# [ inline ( always ) ]
pub fn le14 ( & mut self ) -> LE14_W { LE14_W { w : self } } # [ doc = "Bit 15 - for RV_PLIC15" ]
# [ inline ( always ) ]
pub fn le15 ( & mut self ) -> LE15_W { LE15_W { w : self } } # [ doc = "Bit 16 - for RV_PLIC16" ]
# [ inline ( always ) ]
pub fn le16 ( & mut self ) -> LE16_W { LE16_W { w : self } } # [ doc = "Bit 17 - for RV_PLIC17" ]
# [ inline ( always ) ]
pub fn le17 ( & mut self ) -> LE17_W { LE17_W { w : self } } # [ doc = "Bit 18 - for RV_PLIC18" ]
# [ inline ( always ) ]
pub fn le18 ( & mut self ) -> LE18_W { LE18_W { w : self } } # [ doc = "Bit 19 - for RV_PLIC19" ]
# [ inline ( always ) ]
pub fn le19 ( & mut self ) -> LE19_W { LE19_W { w : self } } # [ doc = "Bit 20 - for RV_PLIC20" ]
# [ inline ( always ) ]
pub fn le20 ( & mut self ) -> LE20_W { LE20_W { w : self } } # [ doc = "Bit 21 - for RV_PLIC21" ]
# [ inline ( always ) ]
pub fn le21 ( & mut self ) -> LE21_W { LE21_W { w : self } } # [ doc = "Bit 22 - for RV_PLIC22" ]
# [ inline ( always ) ]
pub fn le22 ( & mut self ) -> LE22_W { LE22_W { w : self } } # [ doc = "Bit 23 - for RV_PLIC23" ]
# [ inline ( always ) ]
pub fn le23 ( & mut self ) -> LE23_W { LE23_W { w : self } } # [ doc = "Bit 24 - for RV_PLIC24" ]
# [ inline ( always ) ]
pub fn le24 ( & mut self ) -> LE24_W { LE24_W { w : self } } # [ doc = "Bit 25 - for RV_PLIC25" ]
# [ inline ( always ) ]
pub fn le25 ( & mut self ) -> LE25_W { LE25_W { w : self } } # [ doc = "Bit 26 - for RV_PLIC26" ]
# [ inline ( always ) ]
pub fn le26 ( & mut self ) -> LE26_W { LE26_W { w : self } } # [ doc = "Bit 27 - for RV_PLIC27" ]
# [ inline ( always ) ]
pub fn le27 ( & mut self ) -> LE27_W { LE27_W { w : self } } # [ doc = "Bit 28 - for RV_PLIC28" ]
# [ inline ( always ) ]
pub fn le28 ( & mut self ) -> LE28_W { LE28_W { w : self } } # [ doc = "Bit 29 - for RV_PLIC29" ]
# [ inline ( always ) ]
pub fn le29 ( & mut self ) -> LE29_W { LE29_W { w : self } } # [ doc = "Bit 30 - for RV_PLIC30" ]
# [ inline ( always ) ]
pub fn le30 ( & mut self ) -> LE30_W { LE30_W { w : self } } # [ doc = "Bit 31 - for RV_PLIC31" ]
# [ inline ( always ) ]
pub fn le31 ( & mut self ) -> LE31_W { LE31_W { w : self } } } } # [ doc = "Interrupt Source mode. 0: Level, 1: Edge-triggered\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [le1](le1) module" ]
pub type LE1 = crate :: Reg < u32 , _LE1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LE1 ; # [ doc = "`read()` method returns [le1::R](le1::R) reader structure" ]
impl crate :: Readable for LE1 { } # [ doc = "`write(|w| ..)` method takes [le1::W](le1::W) writer structure" ]
impl crate :: Writable for LE1 { } # [ doc = "Interrupt Source mode. 0: Level, 1: Edge-triggered" ]
pub mod le1 { # [ doc = "Reader of register LE1" ]
pub type R = crate :: R < u32 , super :: LE1 > ; # [ doc = "Writer for register LE1" ]
pub type W = crate :: W < u32 , super :: LE1 > ; # [ doc = "Register LE1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LE1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `LE32`" ]
pub type LE32_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE32`" ]
pub struct LE32_W < 'a > { w : & 'a mut W , } impl < 'a > LE32_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LE33`" ]
pub type LE33_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE33`" ]
pub struct LE33_W < 'a > { w : & 'a mut W , } impl < 'a > LE33_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `LE34`" ]
pub type LE34_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE34`" ]
pub struct LE34_W < 'a > { w : & 'a mut W , } impl < 'a > LE34_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `LE35`" ]
pub type LE35_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE35`" ]
pub struct LE35_W < 'a > { w : & 'a mut W , } impl < 'a > LE35_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `LE36`" ]
pub type LE36_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE36`" ]
pub struct LE36_W < 'a > { w : & 'a mut W , } impl < 'a > LE36_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `LE37`" ]
pub type LE37_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE37`" ]
pub struct LE37_W < 'a > { w : & 'a mut W , } impl < 'a > LE37_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `LE38`" ]
pub type LE38_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE38`" ]
pub struct LE38_W < 'a > { w : & 'a mut W , } impl < 'a > LE38_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `LE39`" ]
pub type LE39_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE39`" ]
pub struct LE39_W < 'a > { w : & 'a mut W , } impl < 'a > LE39_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `LE40`" ]
pub type LE40_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE40`" ]
pub struct LE40_W < 'a > { w : & 'a mut W , } impl < 'a > LE40_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `LE41`" ]
pub type LE41_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE41`" ]
pub struct LE41_W < 'a > { w : & 'a mut W , } impl < 'a > LE41_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `LE42`" ]
pub type LE42_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE42`" ]
pub struct LE42_W < 'a > { w : & 'a mut W , } impl < 'a > LE42_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Reader of field `LE43`" ]
pub type LE43_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE43`" ]
pub struct LE43_W < 'a > { w : & 'a mut W , } impl < 'a > LE43_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `LE44`" ]
pub type LE44_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE44`" ]
pub struct LE44_W < 'a > { w : & 'a mut W , } impl < 'a > LE44_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `LE45`" ]
pub type LE45_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE45`" ]
pub struct LE45_W < 'a > { w : & 'a mut W , } impl < 'a > LE45_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `LE46`" ]
pub type LE46_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE46`" ]
pub struct LE46_W < 'a > { w : & 'a mut W , } impl < 'a > LE46_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } } # [ doc = "Reader of field `LE47`" ]
pub type LE47_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE47`" ]
pub struct LE47_W < 'a > { w : & 'a mut W , } impl < 'a > LE47_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `LE48`" ]
pub type LE48_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE48`" ]
pub struct LE48_W < 'a > { w : & 'a mut W , } impl < 'a > LE48_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `LE49`" ]
pub type LE49_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE49`" ]
pub struct LE49_W < 'a > { w : & 'a mut W , } impl < 'a > LE49_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `LE50`" ]
pub type LE50_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE50`" ]
pub struct LE50_W < 'a > { w : & 'a mut W , } impl < 'a > LE50_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } # [ doc = "Reader of field `LE51`" ]
pub type LE51_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE51`" ]
pub struct LE51_W < 'a > { w : & 'a mut W , } impl < 'a > LE51_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } } # [ doc = "Reader of field `LE52`" ]
pub type LE52_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE52`" ]
pub struct LE52_W < 'a > { w : & 'a mut W , } impl < 'a > LE52_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `LE53`" ]
pub type LE53_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE53`" ]
pub struct LE53_W < 'a > { w : & 'a mut W , } impl < 'a > LE53_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Reader of field `LE54`" ]
pub type LE54_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE54`" ]
pub struct LE54_W < 'a > { w : & 'a mut W , } impl < 'a > LE54_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Reader of field `LE55`" ]
pub type LE55_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE55`" ]
pub struct LE55_W < 'a > { w : & 'a mut W , } impl < 'a > LE55_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Reader of field `LE56`" ]
pub type LE56_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE56`" ]
pub struct LE56_W < 'a > { w : & 'a mut W , } impl < 'a > LE56_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } } # [ doc = "Reader of field `LE57`" ]
pub type LE57_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE57`" ]
pub struct LE57_W < 'a > { w : & 'a mut W , } impl < 'a > LE57_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } } # [ doc = "Reader of field `LE58`" ]
pub type LE58_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE58`" ]
pub struct LE58_W < 'a > { w : & 'a mut W , } impl < 'a > LE58_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } } # [ doc = "Reader of field `LE59`" ]
pub type LE59_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE59`" ]
pub struct LE59_W < 'a > { w : & 'a mut W , } impl < 'a > LE59_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Reader of field `LE60`" ]
pub type LE60_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE60`" ]
pub struct LE60_W < 'a > { w : & 'a mut W , } impl < 'a > LE60_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Reader of field `LE61`" ]
pub type LE61_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE61`" ]
pub struct LE61_W < 'a > { w : & 'a mut W , } impl < 'a > LE61_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Reader of field `LE62`" ]
pub type LE62_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LE62`" ]
pub struct LE62_W < 'a > { w : & 'a mut W , } impl < 'a > LE62_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - L0E1 for RV_PLIC32" ]
# [ inline ( always ) ]
pub fn le32 ( & self ) -> LE32_R { LE32_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC33" ]
# [ inline ( always ) ]
pub fn le33 ( & self ) -> LE33_R { LE33_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC34" ]
# [ inline ( always ) ]
pub fn le34 ( & self ) -> LE34_R { LE34_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC35" ]
# [ inline ( always ) ]
pub fn le35 ( & self ) -> LE35_R { LE35_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC36" ]
# [ inline ( always ) ]
pub fn le36 ( & self ) -> LE36_R { LE36_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC37" ]
# [ inline ( always ) ]
pub fn le37 ( & self ) -> LE37_R { LE37_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC38" ]
# [ inline ( always ) ]
pub fn le38 ( & self ) -> LE38_R { LE38_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC39" ]
# [ inline ( always ) ]
pub fn le39 ( & self ) -> LE39_R { LE39_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC40" ]
# [ inline ( always ) ]
pub fn le40 ( & self ) -> LE40_R { LE40_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC41" ]
# [ inline ( always ) ]
pub fn le41 ( & self ) -> LE41_R { LE41_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC42" ]
# [ inline ( always ) ]
pub fn le42 ( & self ) -> LE42_R { LE42_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC43" ]
# [ inline ( always ) ]
pub fn le43 ( & self ) -> LE43_R { LE43_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC44" ]
# [ inline ( always ) ]
pub fn le44 ( & self ) -> LE44_R { LE44_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC45" ]
# [ inline ( always ) ]
pub fn le45 ( & self ) -> LE45_R { LE45_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC46" ]
# [ inline ( always ) ]
pub fn le46 ( & self ) -> LE46_R { LE46_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC47" ]
# [ inline ( always ) ]
pub fn le47 ( & self ) -> LE47_R { LE47_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC48" ]
# [ inline ( always ) ]
pub fn le48 ( & self ) -> LE48_R { LE48_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC49" ]
# [ inline ( always ) ]
pub fn le49 ( & self ) -> LE49_R { LE49_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC50" ]
# [ inline ( always ) ]
pub fn le50 ( & self ) -> LE50_R { LE50_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC51" ]
# [ inline ( always ) ]
pub fn le51 ( & self ) -> LE51_R { LE51_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC52" ]
# [ inline ( always ) ]
pub fn le52 ( & self ) -> LE52_R { LE52_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC53" ]
# [ inline ( always ) ]
pub fn le53 ( & self ) -> LE53_R { LE53_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC54" ]
# [ inline ( always ) ]
pub fn le54 ( & self ) -> LE54_R { LE54_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC55" ]
# [ inline ( always ) ]
pub fn le55 ( & self ) -> LE55_R { LE55_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC56" ]
# [ inline ( always ) ]
pub fn le56 ( & self ) -> LE56_R { LE56_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC57" ]
# [ inline ( always ) ]
pub fn le57 ( & self ) -> LE57_R { LE57_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC58" ]
# [ inline ( always ) ]
pub fn le58 ( & self ) -> LE58_R { LE58_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC59" ]
# [ inline ( always ) ]
pub fn le59 ( & self ) -> LE59_R { LE59_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC60" ]
# [ inline ( always ) ]
pub fn le60 ( & self ) -> LE60_R { LE60_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC61" ]
# [ inline ( always ) ]
pub fn le61 ( & self ) -> LE61_R { LE61_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC62" ]
# [ inline ( always ) ]
pub fn le62 ( & self ) -> LE62_R { LE62_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - L0E1 for RV_PLIC32" ]
# [ inline ( always ) ]
pub fn le32 ( & mut self ) -> LE32_W { LE32_W { w : self } } # [ doc = "Bit 1 - for RV_PLIC33" ]
# [ inline ( always ) ]
pub fn le33 ( & mut self ) -> LE33_W { LE33_W { w : self } } # [ doc = "Bit 2 - for RV_PLIC34" ]
# [ inline ( always ) ]
pub fn le34 ( & mut self ) -> LE34_W { LE34_W { w : self } } # [ doc = "Bit 3 - for RV_PLIC35" ]
# [ inline ( always ) ]
pub fn le35 ( & mut self ) -> LE35_W { LE35_W { w : self } } # [ doc = "Bit 4 - for RV_PLIC36" ]
# [ inline ( always ) ]
pub fn le36 ( & mut self ) -> LE36_W { LE36_W { w : self } } # [ doc = "Bit 5 - for RV_PLIC37" ]
# [ inline ( always ) ]
pub fn le37 ( & mut self ) -> LE37_W { LE37_W { w : self } } # [ doc = "Bit 6 - for RV_PLIC38" ]
# [ inline ( always ) ]
pub fn le38 ( & mut self ) -> LE38_W { LE38_W { w : self } } # [ doc = "Bit 7 - for RV_PLIC39" ]
# [ inline ( always ) ]
pub fn le39 ( & mut self ) -> LE39_W { LE39_W { w : self } } # [ doc = "Bit 8 - for RV_PLIC40" ]
# [ inline ( always ) ]
pub fn le40 ( & mut self ) -> LE40_W { LE40_W { w : self } } # [ doc = "Bit 9 - for RV_PLIC41" ]
# [ inline ( always ) ]
pub fn le41 ( & mut self ) -> LE41_W { LE41_W { w : self } } # [ doc = "Bit 10 - for RV_PLIC42" ]
# [ inline ( always ) ]
pub fn le42 ( & mut self ) -> LE42_W { LE42_W { w : self } } # [ doc = "Bit 11 - for RV_PLIC43" ]
# [ inline ( always ) ]
pub fn le43 ( & mut self ) -> LE43_W { LE43_W { w : self } } # [ doc = "Bit 12 - for RV_PLIC44" ]
# [ inline ( always ) ]
pub fn le44 ( & mut self ) -> LE44_W { LE44_W { w : self } } # [ doc = "Bit 13 - for RV_PLIC45" ]
# [ inline ( always ) ]
pub fn le45 ( & mut self ) -> LE45_W { LE45_W { w : self } } # [ doc = "Bit 14 - for RV_PLIC46" ]
# [ inline ( always ) ]
pub fn le46 ( & mut self ) -> LE46_W { LE46_W { w : self } } # [ doc = "Bit 15 - for RV_PLIC47" ]
# [ inline ( always ) ]
pub fn le47 ( & mut self ) -> LE47_W { LE47_W { w : self } } # [ doc = "Bit 16 - for RV_PLIC48" ]
# [ inline ( always ) ]
pub fn le48 ( & mut self ) -> LE48_W { LE48_W { w : self } } # [ doc = "Bit 17 - for RV_PLIC49" ]
# [ inline ( always ) ]
pub fn le49 ( & mut self ) -> LE49_W { LE49_W { w : self } } # [ doc = "Bit 18 - for RV_PLIC50" ]
# [ inline ( always ) ]
pub fn le50 ( & mut self ) -> LE50_W { LE50_W { w : self } } # [ doc = "Bit 19 - for RV_PLIC51" ]
# [ inline ( always ) ]
pub fn le51 ( & mut self ) -> LE51_W { LE51_W { w : self } } # [ doc = "Bit 20 - for RV_PLIC52" ]
# [ inline ( always ) ]
pub fn le52 ( & mut self ) -> LE52_W { LE52_W { w : self } } # [ doc = "Bit 21 - for RV_PLIC53" ]
# [ inline ( always ) ]
pub fn le53 ( & mut self ) -> LE53_W { LE53_W { w : self } } # [ doc = "Bit 22 - for RV_PLIC54" ]
# [ inline ( always ) ]
pub fn le54 ( & mut self ) -> LE54_W { LE54_W { w : self } } # [ doc = "Bit 23 - for RV_PLIC55" ]
# [ inline ( always ) ]
pub fn le55 ( & mut self ) -> LE55_W { LE55_W { w : self } } # [ doc = "Bit 24 - for RV_PLIC56" ]
# [ inline ( always ) ]
pub fn le56 ( & mut self ) -> LE56_W { LE56_W { w : self } } # [ doc = "Bit 25 - for RV_PLIC57" ]
# [ inline ( always ) ]
pub fn le57 ( & mut self ) -> LE57_W { LE57_W { w : self } } # [ doc = "Bit 26 - for RV_PLIC58" ]
# [ inline ( always ) ]
pub fn le58 ( & mut self ) -> LE58_W { LE58_W { w : self } } # [ doc = "Bit 27 - for RV_PLIC59" ]
# [ inline ( always ) ]
pub fn le59 ( & mut self ) -> LE59_W { LE59_W { w : self } } # [ doc = "Bit 28 - for RV_PLIC60" ]
# [ inline ( always ) ]
pub fn le60 ( & mut self ) -> LE60_W { LE60_W { w : self } } # [ doc = "Bit 29 - for RV_PLIC61" ]
# [ inline ( always ) ]
pub fn le61 ( & mut self ) -> LE61_W { LE61_W { w : self } } # [ doc = "Bit 30 - for RV_PLIC62" ]
# [ inline ( always ) ]
pub fn le62 ( & mut self ) -> LE62_W { LE62_W { w : self } } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct IE0 { # [ doc = "0x00 - Interrupt Enable for Target 0" ]
pub ie00 : self :: ie0 :: IE00 , # [ doc = "0x04 - Interrupt Enable for Target 0" ]
pub ie01 : self :: ie0 :: IE01 , } # [ doc = r"Register block" ]
# [ doc = "Interrupt Enable for Target 0" ]
pub mod ie0 { # [ doc = "Interrupt Enable for Target 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ie00](ie00) module" ]
pub type IE00 = crate :: Reg < u32 , _IE00 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _IE00 ; # [ doc = "`read()` method returns [ie00::R](ie00::R) reader structure" ]
impl crate :: Readable for IE00 { } # [ doc = "`write(|w| ..)` method takes [ie00::W](ie00::W) writer structure" ]
impl crate :: Writable for IE00 { } # [ doc = "Interrupt Enable for Target 0" ]
pub mod ie00 { # [ doc = "Reader of register IE00" ]
pub type R = crate :: R < u32 , super :: IE00 > ; # [ doc = "Writer for register IE00" ]
pub type W = crate :: W < u32 , super :: IE00 > ; # [ doc = "Register IE00 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: IE00 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `E0`" ]
pub type E0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E0`" ]
pub struct E0_W < 'a > { w : & 'a mut W , } impl < 'a > E0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `E1`" ]
pub type E1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E1`" ]
pub struct E1_W < 'a > { w : & 'a mut W , } impl < 'a > E1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `E2`" ]
pub type E2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E2`" ]
pub struct E2_W < 'a > { w : & 'a mut W , } impl < 'a > E2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `E3`" ]
pub type E3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E3`" ]
pub struct E3_W < 'a > { w : & 'a mut W , } impl < 'a > E3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `E4`" ]
pub type E4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E4`" ]
pub struct E4_W < 'a > { w : & 'a mut W , } impl < 'a > E4_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `E5`" ]
pub type E5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E5`" ]
pub struct E5_W < 'a > { w : & 'a mut W , } impl < 'a > E5_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `E6`" ]
pub type E6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E6`" ]
pub struct E6_W < 'a > { w : & 'a mut W , } impl < 'a > E6_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `E7`" ]
pub type E7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E7`" ]
pub struct E7_W < 'a > { w : & 'a mut W , } impl < 'a > E7_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `E8`" ]
pub type E8_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E8`" ]
pub struct E8_W < 'a > { w : & 'a mut W , } impl < 'a > E8_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `E9`" ]
pub type E9_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E9`" ]
pub struct E9_W < 'a > { w : & 'a mut W , } impl < 'a > E9_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `E10`" ]
pub type E10_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E10`" ]
pub struct E10_W < 'a > { w : & 'a mut W , } impl < 'a > E10_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Reader of field `E11`" ]
pub type E11_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E11`" ]
pub struct E11_W < 'a > { w : & 'a mut W , } impl < 'a > E11_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `E12`" ]
pub type E12_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E12`" ]
pub struct E12_W < 'a > { w : & 'a mut W , } impl < 'a > E12_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `E13`" ]
pub type E13_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E13`" ]
pub struct E13_W < 'a > { w : & 'a mut W , } impl < 'a > E13_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `E14`" ]
pub type E14_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E14`" ]
pub struct E14_W < 'a > { w : & 'a mut W , } impl < 'a > E14_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } } # [ doc = "Reader of field `E15`" ]
pub type E15_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E15`" ]
pub struct E15_W < 'a > { w : & 'a mut W , } impl < 'a > E15_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `E16`" ]
pub type E16_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E16`" ]
pub struct E16_W < 'a > { w : & 'a mut W , } impl < 'a > E16_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `E17`" ]
pub type E17_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E17`" ]
pub struct E17_W < 'a > { w : & 'a mut W , } impl < 'a > E17_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `E18`" ]
pub type E18_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E18`" ]
pub struct E18_W < 'a > { w : & 'a mut W , } impl < 'a > E18_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } # [ doc = "Reader of field `E19`" ]
pub type E19_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E19`" ]
pub struct E19_W < 'a > { w : & 'a mut W , } impl < 'a > E19_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } } # [ doc = "Reader of field `E20`" ]
pub type E20_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E20`" ]
pub struct E20_W < 'a > { w : & 'a mut W , } impl < 'a > E20_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `E21`" ]
pub type E21_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E21`" ]
pub struct E21_W < 'a > { w : & 'a mut W , } impl < 'a > E21_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Reader of field `E22`" ]
pub type E22_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E22`" ]
pub struct E22_W < 'a > { w : & 'a mut W , } impl < 'a > E22_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Reader of field `E23`" ]
pub type E23_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E23`" ]
pub struct E23_W < 'a > { w : & 'a mut W , } impl < 'a > E23_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Reader of field `E24`" ]
pub type E24_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E24`" ]
pub struct E24_W < 'a > { w : & 'a mut W , } impl < 'a > E24_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } } # [ doc = "Reader of field `E25`" ]
pub type E25_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E25`" ]
pub struct E25_W < 'a > { w : & 'a mut W , } impl < 'a > E25_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } } # [ doc = "Reader of field `E26`" ]
pub type E26_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E26`" ]
pub struct E26_W < 'a > { w : & 'a mut W , } impl < 'a > E26_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } } # [ doc = "Reader of field `E27`" ]
pub type E27_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E27`" ]
pub struct E27_W < 'a > { w : & 'a mut W , } impl < 'a > E27_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Reader of field `E28`" ]
pub type E28_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E28`" ]
pub struct E28_W < 'a > { w : & 'a mut W , } impl < 'a > E28_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Reader of field `E29`" ]
pub type E29_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E29`" ]
pub struct E29_W < 'a > { w : & 'a mut W , } impl < 'a > E29_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Reader of field `E30`" ]
pub type E30_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E30`" ]
pub struct E30_W < 'a > { w : & 'a mut W , } impl < 'a > E30_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } # [ doc = "Reader of field `E31`" ]
pub type E31_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E31`" ]
pub struct E31_W < 'a > { w : & 'a mut W , } impl < 'a > E31_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } } impl R { # [ doc = "Bit 0 - Interrupt Enable of Source for RV_PLIC0" ]
# [ inline ( always ) ]
pub fn e0 ( & self ) -> E0_R { E0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC1" ]
# [ inline ( always ) ]
pub fn e1 ( & self ) -> E1_R { E1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC2" ]
# [ inline ( always ) ]
pub fn e2 ( & self ) -> E2_R { E2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC3" ]
# [ inline ( always ) ]
pub fn e3 ( & self ) -> E3_R { E3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC4" ]
# [ inline ( always ) ]
pub fn e4 ( & self ) -> E4_R { E4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC5" ]
# [ inline ( always ) ]
pub fn e5 ( & self ) -> E5_R { E5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC6" ]
# [ inline ( always ) ]
pub fn e6 ( & self ) -> E6_R { E6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC7" ]
# [ inline ( always ) ]
pub fn e7 ( & self ) -> E7_R { E7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC8" ]
# [ inline ( always ) ]
pub fn e8 ( & self ) -> E8_R { E8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC9" ]
# [ inline ( always ) ]
pub fn e9 ( & self ) -> E9_R { E9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC10" ]
# [ inline ( always ) ]
pub fn e10 ( & self ) -> E10_R { E10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC11" ]
# [ inline ( always ) ]
pub fn e11 ( & self ) -> E11_R { E11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC12" ]
# [ inline ( always ) ]
pub fn e12 ( & self ) -> E12_R { E12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC13" ]
# [ inline ( always ) ]
pub fn e13 ( & self ) -> E13_R { E13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC14" ]
# [ inline ( always ) ]
pub fn e14 ( & self ) -> E14_R { E14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC15" ]
# [ inline ( always ) ]
pub fn e15 ( & self ) -> E15_R { E15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC16" ]
# [ inline ( always ) ]
pub fn e16 ( & self ) -> E16_R { E16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC17" ]
# [ inline ( always ) ]
pub fn e17 ( & self ) -> E17_R { E17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC18" ]
# [ inline ( always ) ]
pub fn e18 ( & self ) -> E18_R { E18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC19" ]
# [ inline ( always ) ]
pub fn e19 ( & self ) -> E19_R { E19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC20" ]
# [ inline ( always ) ]
pub fn e20 ( & self ) -> E20_R { E20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC21" ]
# [ inline ( always ) ]
pub fn e21 ( & self ) -> E21_R { E21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC22" ]
# [ inline ( always ) ]
pub fn e22 ( & self ) -> E22_R { E22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC23" ]
# [ inline ( always ) ]
pub fn e23 ( & self ) -> E23_R { E23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC24" ]
# [ inline ( always ) ]
pub fn e24 ( & self ) -> E24_R { E24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC25" ]
# [ inline ( always ) ]
pub fn e25 ( & self ) -> E25_R { E25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC26" ]
# [ inline ( always ) ]
pub fn e26 ( & self ) -> E26_R { E26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC27" ]
# [ inline ( always ) ]
pub fn e27 ( & self ) -> E27_R { E27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC28" ]
# [ inline ( always ) ]
pub fn e28 ( & self ) -> E28_R { E28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC29" ]
# [ inline ( always ) ]
pub fn e29 ( & self ) -> E29_R { E29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC30" ]
# [ inline ( always ) ]
pub fn e30 ( & self ) -> E30_R { E30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } # [ doc = "Bit 31 - for RV_PLIC31" ]
# [ inline ( always ) ]
pub fn e31 ( & self ) -> E31_R { E31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Interrupt Enable of Source for RV_PLIC0" ]
# [ inline ( always ) ]
pub fn e0 ( & mut self ) -> E0_W { E0_W { w : self } } # [ doc = "Bit 1 - for RV_PLIC1" ]
# [ inline ( always ) ]
pub fn e1 ( & mut self ) -> E1_W { E1_W { w : self } } # [ doc = "Bit 2 - for RV_PLIC2" ]
# [ inline ( always ) ]
pub fn e2 ( & mut self ) -> E2_W { E2_W { w : self } } # [ doc = "Bit 3 - for RV_PLIC3" ]
# [ inline ( always ) ]
pub fn e3 ( & mut self ) -> E3_W { E3_W { w : self } } # [ doc = "Bit 4 - for RV_PLIC4" ]
# [ inline ( always ) ]
pub fn e4 ( & mut self ) -> E4_W { E4_W { w : self } } # [ doc = "Bit 5 - for RV_PLIC5" ]
# [ inline ( always ) ]
pub fn e5 ( & mut self ) -> E5_W { E5_W { w : self } } # [ doc = "Bit 6 - for RV_PLIC6" ]
# [ inline ( always ) ]
pub fn e6 ( & mut self ) -> E6_W { E6_W { w : self } } # [ doc = "Bit 7 - for RV_PLIC7" ]
# [ inline ( always ) ]
pub fn e7 ( & mut self ) -> E7_W { E7_W { w : self } } # [ doc = "Bit 8 - for RV_PLIC8" ]
# [ inline ( always ) ]
pub fn e8 ( & mut self ) -> E8_W { E8_W { w : self } } # [ doc = "Bit 9 - for RV_PLIC9" ]
# [ inline ( always ) ]
pub fn e9 ( & mut self ) -> E9_W { E9_W { w : self } } # [ doc = "Bit 10 - for RV_PLIC10" ]
# [ inline ( always ) ]
pub fn e10 ( & mut self ) -> E10_W { E10_W { w : self } } # [ doc = "Bit 11 - for RV_PLIC11" ]
# [ inline ( always ) ]
pub fn e11 ( & mut self ) -> E11_W { E11_W { w : self } } # [ doc = "Bit 12 - for RV_PLIC12" ]
# [ inline ( always ) ]
pub fn e12 ( & mut self ) -> E12_W { E12_W { w : self } } # [ doc = "Bit 13 - for RV_PLIC13" ]
# [ inline ( always ) ]
pub fn e13 ( & mut self ) -> E13_W { E13_W { w : self } } # [ doc = "Bit 14 - for RV_PLIC14" ]
# [ inline ( always ) ]
pub fn e14 ( & mut self ) -> E14_W { E14_W { w : self } } # [ doc = "Bit 15 - for RV_PLIC15" ]
# [ inline ( always ) ]
pub fn e15 ( & mut self ) -> E15_W { E15_W { w : self } } # [ doc = "Bit 16 - for RV_PLIC16" ]
# [ inline ( always ) ]
pub fn e16 ( & mut self ) -> E16_W { E16_W { w : self } } # [ doc = "Bit 17 - for RV_PLIC17" ]
# [ inline ( always ) ]
pub fn e17 ( & mut self ) -> E17_W { E17_W { w : self } } # [ doc = "Bit 18 - for RV_PLIC18" ]
# [ inline ( always ) ]
pub fn e18 ( & mut self ) -> E18_W { E18_W { w : self } } # [ doc = "Bit 19 - for RV_PLIC19" ]
# [ inline ( always ) ]
pub fn e19 ( & mut self ) -> E19_W { E19_W { w : self } } # [ doc = "Bit 20 - for RV_PLIC20" ]
# [ inline ( always ) ]
pub fn e20 ( & mut self ) -> E20_W { E20_W { w : self } } # [ doc = "Bit 21 - for RV_PLIC21" ]
# [ inline ( always ) ]
pub fn e21 ( & mut self ) -> E21_W { E21_W { w : self } } # [ doc = "Bit 22 - for RV_PLIC22" ]
# [ inline ( always ) ]
pub fn e22 ( & mut self ) -> E22_W { E22_W { w : self } } # [ doc = "Bit 23 - for RV_PLIC23" ]
# [ inline ( always ) ]
pub fn e23 ( & mut self ) -> E23_W { E23_W { w : self } } # [ doc = "Bit 24 - for RV_PLIC24" ]
# [ inline ( always ) ]
pub fn e24 ( & mut self ) -> E24_W { E24_W { w : self } } # [ doc = "Bit 25 - for RV_PLIC25" ]
# [ inline ( always ) ]
pub fn e25 ( & mut self ) -> E25_W { E25_W { w : self } } # [ doc = "Bit 26 - for RV_PLIC26" ]
# [ inline ( always ) ]
pub fn e26 ( & mut self ) -> E26_W { E26_W { w : self } } # [ doc = "Bit 27 - for RV_PLIC27" ]
# [ inline ( always ) ]
pub fn e27 ( & mut self ) -> E27_W { E27_W { w : self } } # [ doc = "Bit 28 - for RV_PLIC28" ]
# [ inline ( always ) ]
pub fn e28 ( & mut self ) -> E28_W { E28_W { w : self } } # [ doc = "Bit 29 - for RV_PLIC29" ]
# [ inline ( always ) ]
pub fn e29 ( & mut self ) -> E29_W { E29_W { w : self } } # [ doc = "Bit 30 - for RV_PLIC30" ]
# [ inline ( always ) ]
pub fn e30 ( & mut self ) -> E30_W { E30_W { w : self } } # [ doc = "Bit 31 - for RV_PLIC31" ]
# [ inline ( always ) ]
pub fn e31 ( & mut self ) -> E31_W { E31_W { w : self } } } } # [ doc = "Interrupt Enable for Target 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ie01](ie01) module" ]
pub type IE01 = crate :: Reg < u32 , _IE01 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _IE01 ; # [ doc = "`read()` method returns [ie01::R](ie01::R) reader structure" ]
impl crate :: Readable for IE01 { } # [ doc = "`write(|w| ..)` method takes [ie01::W](ie01::W) writer structure" ]
impl crate :: Writable for IE01 { } # [ doc = "Interrupt Enable for Target 0" ]
pub mod ie01 { # [ doc = "Reader of register IE01" ]
pub type R = crate :: R < u32 , super :: IE01 > ; # [ doc = "Writer for register IE01" ]
pub type W = crate :: W < u32 , super :: IE01 > ; # [ doc = "Register IE01 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: IE01 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `E32`" ]
pub type E32_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E32`" ]
pub struct E32_W < 'a > { w : & 'a mut W , } impl < 'a > E32_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `E33`" ]
pub type E33_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E33`" ]
pub struct E33_W < 'a > { w : & 'a mut W , } impl < 'a > E33_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `E34`" ]
pub type E34_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E34`" ]
pub struct E34_W < 'a > { w : & 'a mut W , } impl < 'a > E34_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `E35`" ]
pub type E35_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E35`" ]
pub struct E35_W < 'a > { w : & 'a mut W , } impl < 'a > E35_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `E36`" ]
pub type E36_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E36`" ]
pub struct E36_W < 'a > { w : & 'a mut W , } impl < 'a > E36_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `E37`" ]
pub type E37_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E37`" ]
pub struct E37_W < 'a > { w : & 'a mut W , } impl < 'a > E37_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `E38`" ]
pub type E38_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E38`" ]
pub struct E38_W < 'a > { w : & 'a mut W , } impl < 'a > E38_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `E39`" ]
pub type E39_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E39`" ]
pub struct E39_W < 'a > { w : & 'a mut W , } impl < 'a > E39_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `E40`" ]
pub type E40_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E40`" ]
pub struct E40_W < 'a > { w : & 'a mut W , } impl < 'a > E40_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `E41`" ]
pub type E41_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E41`" ]
pub struct E41_W < 'a > { w : & 'a mut W , } impl < 'a > E41_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `E42`" ]
pub type E42_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E42`" ]
pub struct E42_W < 'a > { w : & 'a mut W , } impl < 'a > E42_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Reader of field `E43`" ]
pub type E43_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E43`" ]
pub struct E43_W < 'a > { w : & 'a mut W , } impl < 'a > E43_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `E44`" ]
pub type E44_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E44`" ]
pub struct E44_W < 'a > { w : & 'a mut W , } impl < 'a > E44_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `E45`" ]
pub type E45_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E45`" ]
pub struct E45_W < 'a > { w : & 'a mut W , } impl < 'a > E45_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `E46`" ]
pub type E46_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E46`" ]
pub struct E46_W < 'a > { w : & 'a mut W , } impl < 'a > E46_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } } # [ doc = "Reader of field `E47`" ]
pub type E47_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E47`" ]
pub struct E47_W < 'a > { w : & 'a mut W , } impl < 'a > E47_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `E48`" ]
pub type E48_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E48`" ]
pub struct E48_W < 'a > { w : & 'a mut W , } impl < 'a > E48_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `E49`" ]
pub type E49_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E49`" ]
pub struct E49_W < 'a > { w : & 'a mut W , } impl < 'a > E49_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `E50`" ]
pub type E50_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E50`" ]
pub struct E50_W < 'a > { w : & 'a mut W , } impl < 'a > E50_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } # [ doc = "Reader of field `E51`" ]
pub type E51_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E51`" ]
pub struct E51_W < 'a > { w : & 'a mut W , } impl < 'a > E51_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } } # [ doc = "Reader of field `E52`" ]
pub type E52_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E52`" ]
pub struct E52_W < 'a > { w : & 'a mut W , } impl < 'a > E52_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `E53`" ]
pub type E53_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E53`" ]
pub struct E53_W < 'a > { w : & 'a mut W , } impl < 'a > E53_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Reader of field `E54`" ]
pub type E54_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E54`" ]
pub struct E54_W < 'a > { w : & 'a mut W , } impl < 'a > E54_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Reader of field `E55`" ]
pub type E55_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E55`" ]
pub struct E55_W < 'a > { w : & 'a mut W , } impl < 'a > E55_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Reader of field `E56`" ]
pub type E56_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E56`" ]
pub struct E56_W < 'a > { w : & 'a mut W , } impl < 'a > E56_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } } # [ doc = "Reader of field `E57`" ]
pub type E57_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E57`" ]
pub struct E57_W < 'a > { w : & 'a mut W , } impl < 'a > E57_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } } # [ doc = "Reader of field `E58`" ]
pub type E58_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E58`" ]
pub struct E58_W < 'a > { w : & 'a mut W , } impl < 'a > E58_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } } # [ doc = "Reader of field `E59`" ]
pub type E59_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E59`" ]
pub struct E59_W < 'a > { w : & 'a mut W , } impl < 'a > E59_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Reader of field `E60`" ]
pub type E60_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E60`" ]
pub struct E60_W < 'a > { w : & 'a mut W , } impl < 'a > E60_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Reader of field `E61`" ]
pub type E61_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E61`" ]
pub struct E61_W < 'a > { w : & 'a mut W , } impl < 'a > E61_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Reader of field `E62`" ]
pub type E62_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `E62`" ]
pub struct E62_W < 'a > { w : & 'a mut W , } impl < 'a > E62_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Interrupt Enable of Source for RV_PLIC32" ]
# [ inline ( always ) ]
pub fn e32 ( & self ) -> E32_R { E32_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for RV_PLIC33" ]
# [ inline ( always ) ]
pub fn e33 ( & self ) -> E33_R { E33_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for RV_PLIC34" ]
# [ inline ( always ) ]
pub fn e34 ( & self ) -> E34_R { E34_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for RV_PLIC35" ]
# [ inline ( always ) ]
pub fn e35 ( & self ) -> E35_R { E35_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - for RV_PLIC36" ]
# [ inline ( always ) ]
pub fn e36 ( & self ) -> E36_R { E36_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - for RV_PLIC37" ]
# [ inline ( always ) ]
pub fn e37 ( & self ) -> E37_R { E37_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - for RV_PLIC38" ]
# [ inline ( always ) ]
pub fn e38 ( & self ) -> E38_R { E38_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - for RV_PLIC39" ]
# [ inline ( always ) ]
pub fn e39 ( & self ) -> E39_R { E39_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - for RV_PLIC40" ]
# [ inline ( always ) ]
pub fn e40 ( & self ) -> E40_R { E40_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - for RV_PLIC41" ]
# [ inline ( always ) ]
pub fn e41 ( & self ) -> E41_R { E41_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - for RV_PLIC42" ]
# [ inline ( always ) ]
pub fn e42 ( & self ) -> E42_R { E42_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - for RV_PLIC43" ]
# [ inline ( always ) ]
pub fn e43 ( & self ) -> E43_R { E43_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - for RV_PLIC44" ]
# [ inline ( always ) ]
pub fn e44 ( & self ) -> E44_R { E44_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - for RV_PLIC45" ]
# [ inline ( always ) ]
pub fn e45 ( & self ) -> E45_R { E45_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - for RV_PLIC46" ]
# [ inline ( always ) ]
pub fn e46 ( & self ) -> E46_R { E46_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - for RV_PLIC47" ]
# [ inline ( always ) ]
pub fn e47 ( & self ) -> E47_R { E47_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - for RV_PLIC48" ]
# [ inline ( always ) ]
pub fn e48 ( & self ) -> E48_R { E48_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - for RV_PLIC49" ]
# [ inline ( always ) ]
pub fn e49 ( & self ) -> E49_R { E49_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 18 - for RV_PLIC50" ]
# [ inline ( always ) ]
pub fn e50 ( & self ) -> E50_R { E50_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } # [ doc = "Bit 19 - for RV_PLIC51" ]
# [ inline ( always ) ]
pub fn e51 ( & self ) -> E51_R { E51_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - for RV_PLIC52" ]
# [ inline ( always ) ]
pub fn e52 ( & self ) -> E52_R { E52_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - for RV_PLIC53" ]
# [ inline ( always ) ]
pub fn e53 ( & self ) -> E53_R { E53_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bit 22 - for RV_PLIC54" ]
# [ inline ( always ) ]
pub fn e54 ( & self ) -> E54_R { E54_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - for RV_PLIC55" ]
# [ inline ( always ) ]
pub fn e55 ( & self ) -> E55_R { E55_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bit 24 - for RV_PLIC56" ]
# [ inline ( always ) ]
pub fn e56 ( & self ) -> E56_R { E56_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) } # [ doc = "Bit 25 - for RV_PLIC57" ]
# [ inline ( always ) ]
pub fn e57 ( & self ) -> E57_R { E57_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) } # [ doc = "Bit 26 - for RV_PLIC58" ]
# [ inline ( always ) ]
pub fn e58 ( & self ) -> E58_R { E58_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) } # [ doc = "Bit 27 - for RV_PLIC59" ]
# [ inline ( always ) ]
pub fn e59 ( & self ) -> E59_R { E59_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 28 - for RV_PLIC60" ]
# [ inline ( always ) ]
pub fn e60 ( & self ) -> E60_R { E60_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - for RV_PLIC61" ]
# [ inline ( always ) ]
pub fn e61 ( & self ) -> E61_R { E61_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - for RV_PLIC62" ]
# [ inline ( always ) ]
pub fn e62 ( & self ) -> E62_R { E62_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Interrupt Enable of Source for RV_PLIC32" ]
# [ inline ( always ) ]
pub fn e32 ( & mut self ) -> E32_W { E32_W { w : self } } # [ doc = "Bit 1 - for RV_PLIC33" ]
# [ inline ( always ) ]
pub fn e33 ( & mut self ) -> E33_W { E33_W { w : self } } # [ doc = "Bit 2 - for RV_PLIC34" ]
# [ inline ( always ) ]
pub fn e34 ( & mut self ) -> E34_W { E34_W { w : self } } # [ doc = "Bit 3 - for RV_PLIC35" ]
# [ inline ( always ) ]
pub fn e35 ( & mut self ) -> E35_W { E35_W { w : self } } # [ doc = "Bit 4 - for RV_PLIC36" ]
# [ inline ( always ) ]
pub fn e36 ( & mut self ) -> E36_W { E36_W { w : self } } # [ doc = "Bit 5 - for RV_PLIC37" ]
# [ inline ( always ) ]
pub fn e37 ( & mut self ) -> E37_W { E37_W { w : self } } # [ doc = "Bit 6 - for RV_PLIC38" ]
# [ inline ( always ) ]
pub fn e38 ( & mut self ) -> E38_W { E38_W { w : self } } # [ doc = "Bit 7 - for RV_PLIC39" ]
# [ inline ( always ) ]
pub fn e39 ( & mut self ) -> E39_W { E39_W { w : self } } # [ doc = "Bit 8 - for RV_PLIC40" ]
# [ inline ( always ) ]
pub fn e40 ( & mut self ) -> E40_W { E40_W { w : self } } # [ doc = "Bit 9 - for RV_PLIC41" ]
# [ inline ( always ) ]
pub fn e41 ( & mut self ) -> E41_W { E41_W { w : self } } # [ doc = "Bit 10 - for RV_PLIC42" ]
# [ inline ( always ) ]
pub fn e42 ( & mut self ) -> E42_W { E42_W { w : self } } # [ doc = "Bit 11 - for RV_PLIC43" ]
# [ inline ( always ) ]
pub fn e43 ( & mut self ) -> E43_W { E43_W { w : self } } # [ doc = "Bit 12 - for RV_PLIC44" ]
# [ inline ( always ) ]
pub fn e44 ( & mut self ) -> E44_W { E44_W { w : self } } # [ doc = "Bit 13 - for RV_PLIC45" ]
# [ inline ( always ) ]
pub fn e45 ( & mut self ) -> E45_W { E45_W { w : self } } # [ doc = "Bit 14 - for RV_PLIC46" ]
# [ inline ( always ) ]
pub fn e46 ( & mut self ) -> E46_W { E46_W { w : self } } # [ doc = "Bit 15 - for RV_PLIC47" ]
# [ inline ( always ) ]
pub fn e47 ( & mut self ) -> E47_W { E47_W { w : self } } # [ doc = "Bit 16 - for RV_PLIC48" ]
# [ inline ( always ) ]
pub fn e48 ( & mut self ) -> E48_W { E48_W { w : self } } # [ doc = "Bit 17 - for RV_PLIC49" ]
# [ inline ( always ) ]
pub fn e49 ( & mut self ) -> E49_W { E49_W { w : self } } # [ doc = "Bit 18 - for RV_PLIC50" ]
# [ inline ( always ) ]
pub fn e50 ( & mut self ) -> E50_W { E50_W { w : self } } # [ doc = "Bit 19 - for RV_PLIC51" ]
# [ inline ( always ) ]
pub fn e51 ( & mut self ) -> E51_W { E51_W { w : self } } # [ doc = "Bit 20 - for RV_PLIC52" ]
# [ inline ( always ) ]
pub fn e52 ( & mut self ) -> E52_W { E52_W { w : self } } # [ doc = "Bit 21 - for RV_PLIC53" ]
# [ inline ( always ) ]
pub fn e53 ( & mut self ) -> E53_W { E53_W { w : self } } # [ doc = "Bit 22 - for RV_PLIC54" ]
# [ inline ( always ) ]
pub fn e54 ( & mut self ) -> E54_W { E54_W { w : self } } # [ doc = "Bit 23 - for RV_PLIC55" ]
# [ inline ( always ) ]
pub fn e55 ( & mut self ) -> E55_W { E55_W { w : self } } # [ doc = "Bit 24 - for RV_PLIC56" ]
# [ inline ( always ) ]
pub fn e56 ( & mut self ) -> E56_W { E56_W { w : self } } # [ doc = "Bit 25 - for RV_PLIC57" ]
# [ inline ( always ) ]
pub fn e57 ( & mut self ) -> E57_W { E57_W { w : self } } # [ doc = "Bit 26 - for RV_PLIC58" ]
# [ inline ( always ) ]
pub fn e58 ( & mut self ) -> E58_W { E58_W { w : self } } # [ doc = "Bit 27 - for RV_PLIC59" ]
# [ inline ( always ) ]
pub fn e59 ( & mut self ) -> E59_W { E59_W { w : self } } # [ doc = "Bit 28 - for RV_PLIC60" ]
# [ inline ( always ) ]
pub fn e60 ( & mut self ) -> E60_W { E60_W { w : self } } # [ doc = "Bit 29 - for RV_PLIC61" ]
# [ inline ( always ) ]
pub fn e61 ( & mut self ) -> E61_W { E61_W { w : self } } # [ doc = "Bit 30 - for RV_PLIC62" ]
# [ inline ( always ) ]
pub fn e62 ( & mut self ) -> E62_W { E62_W { w : self } } } } } # [ doc = "Interrupt Source 0 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio0](prio0) module" ]
pub type PRIO0 = crate :: Reg < u8 , _PRIO0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO0 ; # [ doc = "`read()` method returns [prio0::R](prio0::R) reader structure" ]
impl crate :: Readable for PRIO0 { } # [ doc = "`write(|w| ..)` method takes [prio0::W](prio0::W) writer structure" ]
impl crate :: Writable for PRIO0 { } # [ doc = "Interrupt Source 0 Priority" ]
pub mod prio0 { # [ doc = "Reader of register PRIO0" ]
pub type R = crate :: R < u8 , super :: PRIO0 > ; # [ doc = "Writer for register PRIO0" ]
pub type W = crate :: W < u8 , super :: PRIO0 > ; # [ doc = "Register PRIO0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO0 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 1 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio1](prio1) module" ]
pub type PRIO1 = crate :: Reg < u8 , _PRIO1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO1 ; # [ doc = "`read()` method returns [prio1::R](prio1::R) reader structure" ]
impl crate :: Readable for PRIO1 { } # [ doc = "`write(|w| ..)` method takes [prio1::W](prio1::W) writer structure" ]
impl crate :: Writable for PRIO1 { } # [ doc = "Interrupt Source 1 Priority" ]
pub mod prio1 { # [ doc = "Reader of register PRIO1" ]
pub type R = crate :: R < u8 , super :: PRIO1 > ; # [ doc = "Writer for register PRIO1" ]
pub type W = crate :: W < u8 , super :: PRIO1 > ; # [ doc = "Register PRIO1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO1 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 2 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio2](prio2) module" ]
pub type PRIO2 = crate :: Reg < u8 , _PRIO2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO2 ; # [ doc = "`read()` method returns [prio2::R](prio2::R) reader structure" ]
impl crate :: Readable for PRIO2 { } # [ doc = "`write(|w| ..)` method takes [prio2::W](prio2::W) writer structure" ]
impl crate :: Writable for PRIO2 { } # [ doc = "Interrupt Source 2 Priority" ]
pub mod prio2 { # [ doc = "Reader of register PRIO2" ]
pub type R = crate :: R < u8 , super :: PRIO2 > ; # [ doc = "Writer for register PRIO2" ]
pub type W = crate :: W < u8 , super :: PRIO2 > ; # [ doc = "Register PRIO2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO2 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 3 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio3](prio3) module" ]
pub type PRIO3 = crate :: Reg < u8 , _PRIO3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO3 ; # [ doc = "`read()` method returns [prio3::R](prio3::R) reader structure" ]
impl crate :: Readable for PRIO3 { } # [ doc = "`write(|w| ..)` method takes [prio3::W](prio3::W) writer structure" ]
impl crate :: Writable for PRIO3 { } # [ doc = "Interrupt Source 3 Priority" ]
pub mod prio3 { # [ doc = "Reader of register PRIO3" ]
pub type R = crate :: R < u8 , super :: PRIO3 > ; # [ doc = "Writer for register PRIO3" ]
pub type W = crate :: W < u8 , super :: PRIO3 > ; # [ doc = "Register PRIO3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO3 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 4 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio4](prio4) module" ]
pub type PRIO4 = crate :: Reg < u8 , _PRIO4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO4 ; # [ doc = "`read()` method returns [prio4::R](prio4::R) reader structure" ]
impl crate :: Readable for PRIO4 { } # [ doc = "`write(|w| ..)` method takes [prio4::W](prio4::W) writer structure" ]
impl crate :: Writable for PRIO4 { } # [ doc = "Interrupt Source 4 Priority" ]
pub mod prio4 { # [ doc = "Reader of register PRIO4" ]
pub type R = crate :: R < u8 , super :: PRIO4 > ; # [ doc = "Writer for register PRIO4" ]
pub type W = crate :: W < u8 , super :: PRIO4 > ; # [ doc = "Register PRIO4 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO4 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 5 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio5](prio5) module" ]
pub type PRIO5 = crate :: Reg < u8 , _PRIO5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO5 ; # [ doc = "`read()` method returns [prio5::R](prio5::R) reader structure" ]
impl crate :: Readable for PRIO5 { } # [ doc = "`write(|w| ..)` method takes [prio5::W](prio5::W) writer structure" ]
impl crate :: Writable for PRIO5 { } # [ doc = "Interrupt Source 5 Priority" ]
pub mod prio5 { # [ doc = "Reader of register PRIO5" ]
pub type R = crate :: R < u8 , super :: PRIO5 > ; # [ doc = "Writer for register PRIO5" ]
pub type W = crate :: W < u8 , super :: PRIO5 > ; # [ doc = "Register PRIO5 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO5 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 6 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio6](prio6) module" ]
pub type PRIO6 = crate :: Reg < u8 , _PRIO6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO6 ; # [ doc = "`read()` method returns [prio6::R](prio6::R) reader structure" ]
impl crate :: Readable for PRIO6 { } # [ doc = "`write(|w| ..)` method takes [prio6::W](prio6::W) writer structure" ]
impl crate :: Writable for PRIO6 { } # [ doc = "Interrupt Source 6 Priority" ]
pub mod prio6 { # [ doc = "Reader of register PRIO6" ]
pub type R = crate :: R < u8 , super :: PRIO6 > ; # [ doc = "Writer for register PRIO6" ]
pub type W = crate :: W < u8 , super :: PRIO6 > ; # [ doc = "Register PRIO6 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO6 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 7 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio7](prio7) module" ]
pub type PRIO7 = crate :: Reg < u8 , _PRIO7 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO7 ; # [ doc = "`read()` method returns [prio7::R](prio7::R) reader structure" ]
impl crate :: Readable for PRIO7 { } # [ doc = "`write(|w| ..)` method takes [prio7::W](prio7::W) writer structure" ]
impl crate :: Writable for PRIO7 { } # [ doc = "Interrupt Source 7 Priority" ]
pub mod prio7 { # [ doc = "Reader of register PRIO7" ]
pub type R = crate :: R < u8 , super :: PRIO7 > ; # [ doc = "Writer for register PRIO7" ]
pub type W = crate :: W < u8 , super :: PRIO7 > ; # [ doc = "Register PRIO7 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO7 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 8 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio8](prio8) module" ]
pub type PRIO8 = crate :: Reg < u8 , _PRIO8 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO8 ; # [ doc = "`read()` method returns [prio8::R](prio8::R) reader structure" ]
impl crate :: Readable for PRIO8 { } # [ doc = "`write(|w| ..)` method takes [prio8::W](prio8::W) writer structure" ]
impl crate :: Writable for PRIO8 { } # [ doc = "Interrupt Source 8 Priority" ]
pub mod prio8 { # [ doc = "Reader of register PRIO8" ]
pub type R = crate :: R < u8 , super :: PRIO8 > ; # [ doc = "Writer for register PRIO8" ]
pub type W = crate :: W < u8 , super :: PRIO8 > ; # [ doc = "Register PRIO8 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO8 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 9 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio9](prio9) module" ]
pub type PRIO9 = crate :: Reg < u8 , _PRIO9 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO9 ; # [ doc = "`read()` method returns [prio9::R](prio9::R) reader structure" ]
impl crate :: Readable for PRIO9 { } # [ doc = "`write(|w| ..)` method takes [prio9::W](prio9::W) writer structure" ]
impl crate :: Writable for PRIO9 { } # [ doc = "Interrupt Source 9 Priority" ]
pub mod prio9 { # [ doc = "Reader of register PRIO9" ]
pub type R = crate :: R < u8 , super :: PRIO9 > ; # [ doc = "Writer for register PRIO9" ]
pub type W = crate :: W < u8 , super :: PRIO9 > ; # [ doc = "Register PRIO9 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO9 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 10 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio10](prio10) module" ]
pub type PRIO10 = crate :: Reg < u8 , _PRIO10 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO10 ; # [ doc = "`read()` method returns [prio10::R](prio10::R) reader structure" ]
impl crate :: Readable for PRIO10 { } # [ doc = "`write(|w| ..)` method takes [prio10::W](prio10::W) writer structure" ]
impl crate :: Writable for PRIO10 { } # [ doc = "Interrupt Source 10 Priority" ]
pub mod prio10 { # [ doc = "Reader of register PRIO10" ]
pub type R = crate :: R < u8 , super :: PRIO10 > ; # [ doc = "Writer for register PRIO10" ]
pub type W = crate :: W < u8 , super :: PRIO10 > ; # [ doc = "Register PRIO10 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO10 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 11 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio11](prio11) module" ]
pub type PRIO11 = crate :: Reg < u8 , _PRIO11 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO11 ; # [ doc = "`read()` method returns [prio11::R](prio11::R) reader structure" ]
impl crate :: Readable for PRIO11 { } # [ doc = "`write(|w| ..)` method takes [prio11::W](prio11::W) writer structure" ]
impl crate :: Writable for PRIO11 { } # [ doc = "Interrupt Source 11 Priority" ]
pub mod prio11 { # [ doc = "Reader of register PRIO11" ]
pub type R = crate :: R < u8 , super :: PRIO11 > ; # [ doc = "Writer for register PRIO11" ]
pub type W = crate :: W < u8 , super :: PRIO11 > ; # [ doc = "Register PRIO11 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO11 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 12 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio12](prio12) module" ]
pub type PRIO12 = crate :: Reg < u8 , _PRIO12 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO12 ; # [ doc = "`read()` method returns [prio12::R](prio12::R) reader structure" ]
impl crate :: Readable for PRIO12 { } # [ doc = "`write(|w| ..)` method takes [prio12::W](prio12::W) writer structure" ]
impl crate :: Writable for PRIO12 { } # [ doc = "Interrupt Source 12 Priority" ]
pub mod prio12 { # [ doc = "Reader of register PRIO12" ]
pub type R = crate :: R < u8 , super :: PRIO12 > ; # [ doc = "Writer for register PRIO12" ]
pub type W = crate :: W < u8 , super :: PRIO12 > ; # [ doc = "Register PRIO12 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO12 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 13 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio13](prio13) module" ]
pub type PRIO13 = crate :: Reg < u8 , _PRIO13 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO13 ; # [ doc = "`read()` method returns [prio13::R](prio13::R) reader structure" ]
impl crate :: Readable for PRIO13 { } # [ doc = "`write(|w| ..)` method takes [prio13::W](prio13::W) writer structure" ]
impl crate :: Writable for PRIO13 { } # [ doc = "Interrupt Source 13 Priority" ]
pub mod prio13 { # [ doc = "Reader of register PRIO13" ]
pub type R = crate :: R < u8 , super :: PRIO13 > ; # [ doc = "Writer for register PRIO13" ]
pub type W = crate :: W < u8 , super :: PRIO13 > ; # [ doc = "Register PRIO13 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO13 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 14 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio14](prio14) module" ]
pub type PRIO14 = crate :: Reg < u8 , _PRIO14 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO14 ; # [ doc = "`read()` method returns [prio14::R](prio14::R) reader structure" ]
impl crate :: Readable for PRIO14 { } # [ doc = "`write(|w| ..)` method takes [prio14::W](prio14::W) writer structure" ]
impl crate :: Writable for PRIO14 { } # [ doc = "Interrupt Source 14 Priority" ]
pub mod prio14 { # [ doc = "Reader of register PRIO14" ]
pub type R = crate :: R < u8 , super :: PRIO14 > ; # [ doc = "Writer for register PRIO14" ]
pub type W = crate :: W < u8 , super :: PRIO14 > ; # [ doc = "Register PRIO14 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO14 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 15 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio15](prio15) module" ]
pub type PRIO15 = crate :: Reg < u8 , _PRIO15 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO15 ; # [ doc = "`read()` method returns [prio15::R](prio15::R) reader structure" ]
impl crate :: Readable for PRIO15 { } # [ doc = "`write(|w| ..)` method takes [prio15::W](prio15::W) writer structure" ]
impl crate :: Writable for PRIO15 { } # [ doc = "Interrupt Source 15 Priority" ]
pub mod prio15 { # [ doc = "Reader of register PRIO15" ]
pub type R = crate :: R < u8 , super :: PRIO15 > ; # [ doc = "Writer for register PRIO15" ]
pub type W = crate :: W < u8 , super :: PRIO15 > ; # [ doc = "Register PRIO15 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO15 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 16 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio16](prio16) module" ]
pub type PRIO16 = crate :: Reg < u8 , _PRIO16 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO16 ; # [ doc = "`read()` method returns [prio16::R](prio16::R) reader structure" ]
impl crate :: Readable for PRIO16 { } # [ doc = "`write(|w| ..)` method takes [prio16::W](prio16::W) writer structure" ]
impl crate :: Writable for PRIO16 { } # [ doc = "Interrupt Source 16 Priority" ]
pub mod prio16 { # [ doc = "Reader of register PRIO16" ]
pub type R = crate :: R < u8 , super :: PRIO16 > ; # [ doc = "Writer for register PRIO16" ]
pub type W = crate :: W < u8 , super :: PRIO16 > ; # [ doc = "Register PRIO16 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO16 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 17 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio17](prio17) module" ]
pub type PRIO17 = crate :: Reg < u8 , _PRIO17 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO17 ; # [ doc = "`read()` method returns [prio17::R](prio17::R) reader structure" ]
impl crate :: Readable for PRIO17 { } # [ doc = "`write(|w| ..)` method takes [prio17::W](prio17::W) writer structure" ]
impl crate :: Writable for PRIO17 { } # [ doc = "Interrupt Source 17 Priority" ]
pub mod prio17 { # [ doc = "Reader of register PRIO17" ]
pub type R = crate :: R < u8 , super :: PRIO17 > ; # [ doc = "Writer for register PRIO17" ]
pub type W = crate :: W < u8 , super :: PRIO17 > ; # [ doc = "Register PRIO17 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO17 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 18 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio18](prio18) module" ]
pub type PRIO18 = crate :: Reg < u8 , _PRIO18 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO18 ; # [ doc = "`read()` method returns [prio18::R](prio18::R) reader structure" ]
impl crate :: Readable for PRIO18 { } # [ doc = "`write(|w| ..)` method takes [prio18::W](prio18::W) writer structure" ]
impl crate :: Writable for PRIO18 { } # [ doc = "Interrupt Source 18 Priority" ]
pub mod prio18 { # [ doc = "Reader of register PRIO18" ]
pub type R = crate :: R < u8 , super :: PRIO18 > ; # [ doc = "Writer for register PRIO18" ]
pub type W = crate :: W < u8 , super :: PRIO18 > ; # [ doc = "Register PRIO18 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO18 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 19 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio19](prio19) module" ]
pub type PRIO19 = crate :: Reg < u8 , _PRIO19 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO19 ; # [ doc = "`read()` method returns [prio19::R](prio19::R) reader structure" ]
impl crate :: Readable for PRIO19 { } # [ doc = "`write(|w| ..)` method takes [prio19::W](prio19::W) writer structure" ]
impl crate :: Writable for PRIO19 { } # [ doc = "Interrupt Source 19 Priority" ]
pub mod prio19 { # [ doc = "Reader of register PRIO19" ]
pub type R = crate :: R < u8 , super :: PRIO19 > ; # [ doc = "Writer for register PRIO19" ]
pub type W = crate :: W < u8 , super :: PRIO19 > ; # [ doc = "Register PRIO19 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO19 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 20 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio20](prio20) module" ]
pub type PRIO20 = crate :: Reg < u8 , _PRIO20 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO20 ; # [ doc = "`read()` method returns [prio20::R](prio20::R) reader structure" ]
impl crate :: Readable for PRIO20 { } # [ doc = "`write(|w| ..)` method takes [prio20::W](prio20::W) writer structure" ]
impl crate :: Writable for PRIO20 { } # [ doc = "Interrupt Source 20 Priority" ]
pub mod prio20 { # [ doc = "Reader of register PRIO20" ]
pub type R = crate :: R < u8 , super :: PRIO20 > ; # [ doc = "Writer for register PRIO20" ]
pub type W = crate :: W < u8 , super :: PRIO20 > ; # [ doc = "Register PRIO20 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO20 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 21 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio21](prio21) module" ]
pub type PRIO21 = crate :: Reg < u8 , _PRIO21 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO21 ; # [ doc = "`read()` method returns [prio21::R](prio21::R) reader structure" ]
impl crate :: Readable for PRIO21 { } # [ doc = "`write(|w| ..)` method takes [prio21::W](prio21::W) writer structure" ]
impl crate :: Writable for PRIO21 { } # [ doc = "Interrupt Source 21 Priority" ]
pub mod prio21 { # [ doc = "Reader of register PRIO21" ]
pub type R = crate :: R < u8 , super :: PRIO21 > ; # [ doc = "Writer for register PRIO21" ]
pub type W = crate :: W < u8 , super :: PRIO21 > ; # [ doc = "Register PRIO21 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO21 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 22 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio22](prio22) module" ]
pub type PRIO22 = crate :: Reg < u8 , _PRIO22 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO22 ; # [ doc = "`read()` method returns [prio22::R](prio22::R) reader structure" ]
impl crate :: Readable for PRIO22 { } # [ doc = "`write(|w| ..)` method takes [prio22::W](prio22::W) writer structure" ]
impl crate :: Writable for PRIO22 { } # [ doc = "Interrupt Source 22 Priority" ]
pub mod prio22 { # [ doc = "Reader of register PRIO22" ]
pub type R = crate :: R < u8 , super :: PRIO22 > ; # [ doc = "Writer for register PRIO22" ]
pub type W = crate :: W < u8 , super :: PRIO22 > ; # [ doc = "Register PRIO22 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO22 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 23 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio23](prio23) module" ]
pub type PRIO23 = crate :: Reg < u8 , _PRIO23 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO23 ; # [ doc = "`read()` method returns [prio23::R](prio23::R) reader structure" ]
impl crate :: Readable for PRIO23 { } # [ doc = "`write(|w| ..)` method takes [prio23::W](prio23::W) writer structure" ]
impl crate :: Writable for PRIO23 { } # [ doc = "Interrupt Source 23 Priority" ]
pub mod prio23 { # [ doc = "Reader of register PRIO23" ]
pub type R = crate :: R < u8 , super :: PRIO23 > ; # [ doc = "Writer for register PRIO23" ]
pub type W = crate :: W < u8 , super :: PRIO23 > ; # [ doc = "Register PRIO23 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO23 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 24 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio24](prio24) module" ]
pub type PRIO24 = crate :: Reg < u8 , _PRIO24 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO24 ; # [ doc = "`read()` method returns [prio24::R](prio24::R) reader structure" ]
impl crate :: Readable for PRIO24 { } # [ doc = "`write(|w| ..)` method takes [prio24::W](prio24::W) writer structure" ]
impl crate :: Writable for PRIO24 { } # [ doc = "Interrupt Source 24 Priority" ]
pub mod prio24 { # [ doc = "Reader of register PRIO24" ]
pub type R = crate :: R < u8 , super :: PRIO24 > ; # [ doc = "Writer for register PRIO24" ]
pub type W = crate :: W < u8 , super :: PRIO24 > ; # [ doc = "Register PRIO24 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO24 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 25 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio25](prio25) module" ]
pub type PRIO25 = crate :: Reg < u8 , _PRIO25 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO25 ; # [ doc = "`read()` method returns [prio25::R](prio25::R) reader structure" ]
impl crate :: Readable for PRIO25 { } # [ doc = "`write(|w| ..)` method takes [prio25::W](prio25::W) writer structure" ]
impl crate :: Writable for PRIO25 { } # [ doc = "Interrupt Source 25 Priority" ]
pub mod prio25 { # [ doc = "Reader of register PRIO25" ]
pub type R = crate :: R < u8 , super :: PRIO25 > ; # [ doc = "Writer for register PRIO25" ]
pub type W = crate :: W < u8 , super :: PRIO25 > ; # [ doc = "Register PRIO25 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO25 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 26 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio26](prio26) module" ]
pub type PRIO26 = crate :: Reg < u8 , _PRIO26 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO26 ; # [ doc = "`read()` method returns [prio26::R](prio26::R) reader structure" ]
impl crate :: Readable for PRIO26 { } # [ doc = "`write(|w| ..)` method takes [prio26::W](prio26::W) writer structure" ]
impl crate :: Writable for PRIO26 { } # [ doc = "Interrupt Source 26 Priority" ]
pub mod prio26 { # [ doc = "Reader of register PRIO26" ]
pub type R = crate :: R < u8 , super :: PRIO26 > ; # [ doc = "Writer for register PRIO26" ]
pub type W = crate :: W < u8 , super :: PRIO26 > ; # [ doc = "Register PRIO26 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO26 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 27 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio27](prio27) module" ]
pub type PRIO27 = crate :: Reg < u8 , _PRIO27 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO27 ; # [ doc = "`read()` method returns [prio27::R](prio27::R) reader structure" ]
impl crate :: Readable for PRIO27 { } # [ doc = "`write(|w| ..)` method takes [prio27::W](prio27::W) writer structure" ]
impl crate :: Writable for PRIO27 { } # [ doc = "Interrupt Source 27 Priority" ]
pub mod prio27 { # [ doc = "Reader of register PRIO27" ]
pub type R = crate :: R < u8 , super :: PRIO27 > ; # [ doc = "Writer for register PRIO27" ]
pub type W = crate :: W < u8 , super :: PRIO27 > ; # [ doc = "Register PRIO27 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO27 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 28 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio28](prio28) module" ]
pub type PRIO28 = crate :: Reg < u8 , _PRIO28 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO28 ; # [ doc = "`read()` method returns [prio28::R](prio28::R) reader structure" ]
impl crate :: Readable for PRIO28 { } # [ doc = "`write(|w| ..)` method takes [prio28::W](prio28::W) writer structure" ]
impl crate :: Writable for PRIO28 { } # [ doc = "Interrupt Source 28 Priority" ]
pub mod prio28 { # [ doc = "Reader of register PRIO28" ]
pub type R = crate :: R < u8 , super :: PRIO28 > ; # [ doc = "Writer for register PRIO28" ]
pub type W = crate :: W < u8 , super :: PRIO28 > ; # [ doc = "Register PRIO28 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO28 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 29 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio29](prio29) module" ]
pub type PRIO29 = crate :: Reg < u8 , _PRIO29 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO29 ; # [ doc = "`read()` method returns [prio29::R](prio29::R) reader structure" ]
impl crate :: Readable for PRIO29 { } # [ doc = "`write(|w| ..)` method takes [prio29::W](prio29::W) writer structure" ]
impl crate :: Writable for PRIO29 { } # [ doc = "Interrupt Source 29 Priority" ]
pub mod prio29 { # [ doc = "Reader of register PRIO29" ]
pub type R = crate :: R < u8 , super :: PRIO29 > ; # [ doc = "Writer for register PRIO29" ]
pub type W = crate :: W < u8 , super :: PRIO29 > ; # [ doc = "Register PRIO29 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO29 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 30 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio30](prio30) module" ]
pub type PRIO30 = crate :: Reg < u8 , _PRIO30 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO30 ; # [ doc = "`read()` method returns [prio30::R](prio30::R) reader structure" ]
impl crate :: Readable for PRIO30 { } # [ doc = "`write(|w| ..)` method takes [prio30::W](prio30::W) writer structure" ]
impl crate :: Writable for PRIO30 { } # [ doc = "Interrupt Source 30 Priority" ]
pub mod prio30 { # [ doc = "Reader of register PRIO30" ]
pub type R = crate :: R < u8 , super :: PRIO30 > ; # [ doc = "Writer for register PRIO30" ]
pub type W = crate :: W < u8 , super :: PRIO30 > ; # [ doc = "Register PRIO30 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO30 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 31 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio31](prio31) module" ]
pub type PRIO31 = crate :: Reg < u8 , _PRIO31 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO31 ; # [ doc = "`read()` method returns [prio31::R](prio31::R) reader structure" ]
impl crate :: Readable for PRIO31 { } # [ doc = "`write(|w| ..)` method takes [prio31::W](prio31::W) writer structure" ]
impl crate :: Writable for PRIO31 { } # [ doc = "Interrupt Source 31 Priority" ]
pub mod prio31 { # [ doc = "Reader of register PRIO31" ]
pub type R = crate :: R < u8 , super :: PRIO31 > ; # [ doc = "Writer for register PRIO31" ]
pub type W = crate :: W < u8 , super :: PRIO31 > ; # [ doc = "Register PRIO31 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO31 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 32 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio32](prio32) module" ]
pub type PRIO32 = crate :: Reg < u8 , _PRIO32 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO32 ; # [ doc = "`read()` method returns [prio32::R](prio32::R) reader structure" ]
impl crate :: Readable for PRIO32 { } # [ doc = "`write(|w| ..)` method takes [prio32::W](prio32::W) writer structure" ]
impl crate :: Writable for PRIO32 { } # [ doc = "Interrupt Source 32 Priority" ]
pub mod prio32 { # [ doc = "Reader of register PRIO32" ]
pub type R = crate :: R < u8 , super :: PRIO32 > ; # [ doc = "Writer for register PRIO32" ]
pub type W = crate :: W < u8 , super :: PRIO32 > ; # [ doc = "Register PRIO32 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO32 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 33 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio33](prio33) module" ]
pub type PRIO33 = crate :: Reg < u8 , _PRIO33 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO33 ; # [ doc = "`read()` method returns [prio33::R](prio33::R) reader structure" ]
impl crate :: Readable for PRIO33 { } # [ doc = "`write(|w| ..)` method takes [prio33::W](prio33::W) writer structure" ]
impl crate :: Writable for PRIO33 { } # [ doc = "Interrupt Source 33 Priority" ]
pub mod prio33 { # [ doc = "Reader of register PRIO33" ]
pub type R = crate :: R < u8 , super :: PRIO33 > ; # [ doc = "Writer for register PRIO33" ]
pub type W = crate :: W < u8 , super :: PRIO33 > ; # [ doc = "Register PRIO33 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO33 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 34 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio34](prio34) module" ]
pub type PRIO34 = crate :: Reg < u8 , _PRIO34 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO34 ; # [ doc = "`read()` method returns [prio34::R](prio34::R) reader structure" ]
impl crate :: Readable for PRIO34 { } # [ doc = "`write(|w| ..)` method takes [prio34::W](prio34::W) writer structure" ]
impl crate :: Writable for PRIO34 { } # [ doc = "Interrupt Source 34 Priority" ]
pub mod prio34 { # [ doc = "Reader of register PRIO34" ]
pub type R = crate :: R < u8 , super :: PRIO34 > ; # [ doc = "Writer for register PRIO34" ]
pub type W = crate :: W < u8 , super :: PRIO34 > ; # [ doc = "Register PRIO34 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO34 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 35 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio35](prio35) module" ]
pub type PRIO35 = crate :: Reg < u8 , _PRIO35 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO35 ; # [ doc = "`read()` method returns [prio35::R](prio35::R) reader structure" ]
impl crate :: Readable for PRIO35 { } # [ doc = "`write(|w| ..)` method takes [prio35::W](prio35::W) writer structure" ]
impl crate :: Writable for PRIO35 { } # [ doc = "Interrupt Source 35 Priority" ]
pub mod prio35 { # [ doc = "Reader of register PRIO35" ]
pub type R = crate :: R < u8 , super :: PRIO35 > ; # [ doc = "Writer for register PRIO35" ]
pub type W = crate :: W < u8 , super :: PRIO35 > ; # [ doc = "Register PRIO35 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO35 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 36 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio36](prio36) module" ]
pub type PRIO36 = crate :: Reg < u8 , _PRIO36 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO36 ; # [ doc = "`read()` method returns [prio36::R](prio36::R) reader structure" ]
impl crate :: Readable for PRIO36 { } # [ doc = "`write(|w| ..)` method takes [prio36::W](prio36::W) writer structure" ]
impl crate :: Writable for PRIO36 { } # [ doc = "Interrupt Source 36 Priority" ]
pub mod prio36 { # [ doc = "Reader of register PRIO36" ]
pub type R = crate :: R < u8 , super :: PRIO36 > ; # [ doc = "Writer for register PRIO36" ]
pub type W = crate :: W < u8 , super :: PRIO36 > ; # [ doc = "Register PRIO36 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO36 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 37 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio37](prio37) module" ]
pub type PRIO37 = crate :: Reg < u8 , _PRIO37 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO37 ; # [ doc = "`read()` method returns [prio37::R](prio37::R) reader structure" ]
impl crate :: Readable for PRIO37 { } # [ doc = "`write(|w| ..)` method takes [prio37::W](prio37::W) writer structure" ]
impl crate :: Writable for PRIO37 { } # [ doc = "Interrupt Source 37 Priority" ]
pub mod prio37 { # [ doc = "Reader of register PRIO37" ]
pub type R = crate :: R < u8 , super :: PRIO37 > ; # [ doc = "Writer for register PRIO37" ]
pub type W = crate :: W < u8 , super :: PRIO37 > ; # [ doc = "Register PRIO37 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO37 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 38 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio38](prio38) module" ]
pub type PRIO38 = crate :: Reg < u8 , _PRIO38 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO38 ; # [ doc = "`read()` method returns [prio38::R](prio38::R) reader structure" ]
impl crate :: Readable for PRIO38 { } # [ doc = "`write(|w| ..)` method takes [prio38::W](prio38::W) writer structure" ]
impl crate :: Writable for PRIO38 { } # [ doc = "Interrupt Source 38 Priority" ]
pub mod prio38 { # [ doc = "Reader of register PRIO38" ]
pub type R = crate :: R < u8 , super :: PRIO38 > ; # [ doc = "Writer for register PRIO38" ]
pub type W = crate :: W < u8 , super :: PRIO38 > ; # [ doc = "Register PRIO38 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO38 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 39 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio39](prio39) module" ]
pub type PRIO39 = crate :: Reg < u8 , _PRIO39 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO39 ; # [ doc = "`read()` method returns [prio39::R](prio39::R) reader structure" ]
impl crate :: Readable for PRIO39 { } # [ doc = "`write(|w| ..)` method takes [prio39::W](prio39::W) writer structure" ]
impl crate :: Writable for PRIO39 { } # [ doc = "Interrupt Source 39 Priority" ]
pub mod prio39 { # [ doc = "Reader of register PRIO39" ]
pub type R = crate :: R < u8 , super :: PRIO39 > ; # [ doc = "Writer for register PRIO39" ]
pub type W = crate :: W < u8 , super :: PRIO39 > ; # [ doc = "Register PRIO39 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO39 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 40 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio40](prio40) module" ]
pub type PRIO40 = crate :: Reg < u8 , _PRIO40 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO40 ; # [ doc = "`read()` method returns [prio40::R](prio40::R) reader structure" ]
impl crate :: Readable for PRIO40 { } # [ doc = "`write(|w| ..)` method takes [prio40::W](prio40::W) writer structure" ]
impl crate :: Writable for PRIO40 { } # [ doc = "Interrupt Source 40 Priority" ]
pub mod prio40 { # [ doc = "Reader of register PRIO40" ]
pub type R = crate :: R < u8 , super :: PRIO40 > ; # [ doc = "Writer for register PRIO40" ]
pub type W = crate :: W < u8 , super :: PRIO40 > ; # [ doc = "Register PRIO40 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO40 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 41 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio41](prio41) module" ]
pub type PRIO41 = crate :: Reg < u8 , _PRIO41 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO41 ; # [ doc = "`read()` method returns [prio41::R](prio41::R) reader structure" ]
impl crate :: Readable for PRIO41 { } # [ doc = "`write(|w| ..)` method takes [prio41::W](prio41::W) writer structure" ]
impl crate :: Writable for PRIO41 { } # [ doc = "Interrupt Source 41 Priority" ]
pub mod prio41 { # [ doc = "Reader of register PRIO41" ]
pub type R = crate :: R < u8 , super :: PRIO41 > ; # [ doc = "Writer for register PRIO41" ]
pub type W = crate :: W < u8 , super :: PRIO41 > ; # [ doc = "Register PRIO41 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO41 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 42 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio42](prio42) module" ]
pub type PRIO42 = crate :: Reg < u8 , _PRIO42 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO42 ; # [ doc = "`read()` method returns [prio42::R](prio42::R) reader structure" ]
impl crate :: Readable for PRIO42 { } # [ doc = "`write(|w| ..)` method takes [prio42::W](prio42::W) writer structure" ]
impl crate :: Writable for PRIO42 { } # [ doc = "Interrupt Source 42 Priority" ]
pub mod prio42 { # [ doc = "Reader of register PRIO42" ]
pub type R = crate :: R < u8 , super :: PRIO42 > ; # [ doc = "Writer for register PRIO42" ]
pub type W = crate :: W < u8 , super :: PRIO42 > ; # [ doc = "Register PRIO42 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO42 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 43 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio43](prio43) module" ]
pub type PRIO43 = crate :: Reg < u8 , _PRIO43 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO43 ; # [ doc = "`read()` method returns [prio43::R](prio43::R) reader structure" ]
impl crate :: Readable for PRIO43 { } # [ doc = "`write(|w| ..)` method takes [prio43::W](prio43::W) writer structure" ]
impl crate :: Writable for PRIO43 { } # [ doc = "Interrupt Source 43 Priority" ]
pub mod prio43 { # [ doc = "Reader of register PRIO43" ]
pub type R = crate :: R < u8 , super :: PRIO43 > ; # [ doc = "Writer for register PRIO43" ]
pub type W = crate :: W < u8 , super :: PRIO43 > ; # [ doc = "Register PRIO43 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO43 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 44 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio44](prio44) module" ]
pub type PRIO44 = crate :: Reg < u8 , _PRIO44 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO44 ; # [ doc = "`read()` method returns [prio44::R](prio44::R) reader structure" ]
impl crate :: Readable for PRIO44 { } # [ doc = "`write(|w| ..)` method takes [prio44::W](prio44::W) writer structure" ]
impl crate :: Writable for PRIO44 { } # [ doc = "Interrupt Source 44 Priority" ]
pub mod prio44 { # [ doc = "Reader of register PRIO44" ]
pub type R = crate :: R < u8 , super :: PRIO44 > ; # [ doc = "Writer for register PRIO44" ]
pub type W = crate :: W < u8 , super :: PRIO44 > ; # [ doc = "Register PRIO44 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO44 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 45 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio45](prio45) module" ]
pub type PRIO45 = crate :: Reg < u8 , _PRIO45 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO45 ; # [ doc = "`read()` method returns [prio45::R](prio45::R) reader structure" ]
impl crate :: Readable for PRIO45 { } # [ doc = "`write(|w| ..)` method takes [prio45::W](prio45::W) writer structure" ]
impl crate :: Writable for PRIO45 { } # [ doc = "Interrupt Source 45 Priority" ]
pub mod prio45 { # [ doc = "Reader of register PRIO45" ]
pub type R = crate :: R < u8 , super :: PRIO45 > ; # [ doc = "Writer for register PRIO45" ]
pub type W = crate :: W < u8 , super :: PRIO45 > ; # [ doc = "Register PRIO45 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO45 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 46 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio46](prio46) module" ]
pub type PRIO46 = crate :: Reg < u8 , _PRIO46 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO46 ; # [ doc = "`read()` method returns [prio46::R](prio46::R) reader structure" ]
impl crate :: Readable for PRIO46 { } # [ doc = "`write(|w| ..)` method takes [prio46::W](prio46::W) writer structure" ]
impl crate :: Writable for PRIO46 { } # [ doc = "Interrupt Source 46 Priority" ]
pub mod prio46 { # [ doc = "Reader of register PRIO46" ]
pub type R = crate :: R < u8 , super :: PRIO46 > ; # [ doc = "Writer for register PRIO46" ]
pub type W = crate :: W < u8 , super :: PRIO46 > ; # [ doc = "Register PRIO46 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO46 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 47 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio47](prio47) module" ]
pub type PRIO47 = crate :: Reg < u8 , _PRIO47 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO47 ; # [ doc = "`read()` method returns [prio47::R](prio47::R) reader structure" ]
impl crate :: Readable for PRIO47 { } # [ doc = "`write(|w| ..)` method takes [prio47::W](prio47::W) writer structure" ]
impl crate :: Writable for PRIO47 { } # [ doc = "Interrupt Source 47 Priority" ]
pub mod prio47 { # [ doc = "Reader of register PRIO47" ]
pub type R = crate :: R < u8 , super :: PRIO47 > ; # [ doc = "Writer for register PRIO47" ]
pub type W = crate :: W < u8 , super :: PRIO47 > ; # [ doc = "Register PRIO47 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO47 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 48 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio48](prio48) module" ]
pub type PRIO48 = crate :: Reg < u8 , _PRIO48 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO48 ; # [ doc = "`read()` method returns [prio48::R](prio48::R) reader structure" ]
impl crate :: Readable for PRIO48 { } # [ doc = "`write(|w| ..)` method takes [prio48::W](prio48::W) writer structure" ]
impl crate :: Writable for PRIO48 { } # [ doc = "Interrupt Source 48 Priority" ]
pub mod prio48 { # [ doc = "Reader of register PRIO48" ]
pub type R = crate :: R < u8 , super :: PRIO48 > ; # [ doc = "Writer for register PRIO48" ]
pub type W = crate :: W < u8 , super :: PRIO48 > ; # [ doc = "Register PRIO48 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO48 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 49 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio49](prio49) module" ]
pub type PRIO49 = crate :: Reg < u8 , _PRIO49 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO49 ; # [ doc = "`read()` method returns [prio49::R](prio49::R) reader structure" ]
impl crate :: Readable for PRIO49 { } # [ doc = "`write(|w| ..)` method takes [prio49::W](prio49::W) writer structure" ]
impl crate :: Writable for PRIO49 { } # [ doc = "Interrupt Source 49 Priority" ]
pub mod prio49 { # [ doc = "Reader of register PRIO49" ]
pub type R = crate :: R < u8 , super :: PRIO49 > ; # [ doc = "Writer for register PRIO49" ]
pub type W = crate :: W < u8 , super :: PRIO49 > ; # [ doc = "Register PRIO49 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO49 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 50 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio50](prio50) module" ]
pub type PRIO50 = crate :: Reg < u8 , _PRIO50 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO50 ; # [ doc = "`read()` method returns [prio50::R](prio50::R) reader structure" ]
impl crate :: Readable for PRIO50 { } # [ doc = "`write(|w| ..)` method takes [prio50::W](prio50::W) writer structure" ]
impl crate :: Writable for PRIO50 { } # [ doc = "Interrupt Source 50 Priority" ]
pub mod prio50 { # [ doc = "Reader of register PRIO50" ]
pub type R = crate :: R < u8 , super :: PRIO50 > ; # [ doc = "Writer for register PRIO50" ]
pub type W = crate :: W < u8 , super :: PRIO50 > ; # [ doc = "Register PRIO50 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO50 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 51 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio51](prio51) module" ]
pub type PRIO51 = crate :: Reg < u8 , _PRIO51 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO51 ; # [ doc = "`read()` method returns [prio51::R](prio51::R) reader structure" ]
impl crate :: Readable for PRIO51 { } # [ doc = "`write(|w| ..)` method takes [prio51::W](prio51::W) writer structure" ]
impl crate :: Writable for PRIO51 { } # [ doc = "Interrupt Source 51 Priority" ]
pub mod prio51 { # [ doc = "Reader of register PRIO51" ]
pub type R = crate :: R < u8 , super :: PRIO51 > ; # [ doc = "Writer for register PRIO51" ]
pub type W = crate :: W < u8 , super :: PRIO51 > ; # [ doc = "Register PRIO51 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO51 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 52 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio52](prio52) module" ]
pub type PRIO52 = crate :: Reg < u8 , _PRIO52 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO52 ; # [ doc = "`read()` method returns [prio52::R](prio52::R) reader structure" ]
impl crate :: Readable for PRIO52 { } # [ doc = "`write(|w| ..)` method takes [prio52::W](prio52::W) writer structure" ]
impl crate :: Writable for PRIO52 { } # [ doc = "Interrupt Source 52 Priority" ]
pub mod prio52 { # [ doc = "Reader of register PRIO52" ]
pub type R = crate :: R < u8 , super :: PRIO52 > ; # [ doc = "Writer for register PRIO52" ]
pub type W = crate :: W < u8 , super :: PRIO52 > ; # [ doc = "Register PRIO52 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO52 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 53 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio53](prio53) module" ]
pub type PRIO53 = crate :: Reg < u8 , _PRIO53 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO53 ; # [ doc = "`read()` method returns [prio53::R](prio53::R) reader structure" ]
impl crate :: Readable for PRIO53 { } # [ doc = "`write(|w| ..)` method takes [prio53::W](prio53::W) writer structure" ]
impl crate :: Writable for PRIO53 { } # [ doc = "Interrupt Source 53 Priority" ]
pub mod prio53 { # [ doc = "Reader of register PRIO53" ]
pub type R = crate :: R < u8 , super :: PRIO53 > ; # [ doc = "Writer for register PRIO53" ]
pub type W = crate :: W < u8 , super :: PRIO53 > ; # [ doc = "Register PRIO53 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO53 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 54 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio54](prio54) module" ]
pub type PRIO54 = crate :: Reg < u8 , _PRIO54 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO54 ; # [ doc = "`read()` method returns [prio54::R](prio54::R) reader structure" ]
impl crate :: Readable for PRIO54 { } # [ doc = "`write(|w| ..)` method takes [prio54::W](prio54::W) writer structure" ]
impl crate :: Writable for PRIO54 { } # [ doc = "Interrupt Source 54 Priority" ]
pub mod prio54 { # [ doc = "Reader of register PRIO54" ]
pub type R = crate :: R < u8 , super :: PRIO54 > ; # [ doc = "Writer for register PRIO54" ]
pub type W = crate :: W < u8 , super :: PRIO54 > ; # [ doc = "Register PRIO54 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO54 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 55 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio55](prio55) module" ]
pub type PRIO55 = crate :: Reg < u8 , _PRIO55 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO55 ; # [ doc = "`read()` method returns [prio55::R](prio55::R) reader structure" ]
impl crate :: Readable for PRIO55 { } # [ doc = "`write(|w| ..)` method takes [prio55::W](prio55::W) writer structure" ]
impl crate :: Writable for PRIO55 { } # [ doc = "Interrupt Source 55 Priority" ]
pub mod prio55 { # [ doc = "Reader of register PRIO55" ]
pub type R = crate :: R < u8 , super :: PRIO55 > ; # [ doc = "Writer for register PRIO55" ]
pub type W = crate :: W < u8 , super :: PRIO55 > ; # [ doc = "Register PRIO55 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO55 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 56 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio56](prio56) module" ]
pub type PRIO56 = crate :: Reg < u8 , _PRIO56 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO56 ; # [ doc = "`read()` method returns [prio56::R](prio56::R) reader structure" ]
impl crate :: Readable for PRIO56 { } # [ doc = "`write(|w| ..)` method takes [prio56::W](prio56::W) writer structure" ]
impl crate :: Writable for PRIO56 { } # [ doc = "Interrupt Source 56 Priority" ]
pub mod prio56 { # [ doc = "Reader of register PRIO56" ]
pub type R = crate :: R < u8 , super :: PRIO56 > ; # [ doc = "Writer for register PRIO56" ]
pub type W = crate :: W < u8 , super :: PRIO56 > ; # [ doc = "Register PRIO56 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO56 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 57 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio57](prio57) module" ]
pub type PRIO57 = crate :: Reg < u8 , _PRIO57 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO57 ; # [ doc = "`read()` method returns [prio57::R](prio57::R) reader structure" ]
impl crate :: Readable for PRIO57 { } # [ doc = "`write(|w| ..)` method takes [prio57::W](prio57::W) writer structure" ]
impl crate :: Writable for PRIO57 { } # [ doc = "Interrupt Source 57 Priority" ]
pub mod prio57 { # [ doc = "Reader of register PRIO57" ]
pub type R = crate :: R < u8 , super :: PRIO57 > ; # [ doc = "Writer for register PRIO57" ]
pub type W = crate :: W < u8 , super :: PRIO57 > ; # [ doc = "Register PRIO57 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO57 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 58 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio58](prio58) module" ]
pub type PRIO58 = crate :: Reg < u8 , _PRIO58 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO58 ; # [ doc = "`read()` method returns [prio58::R](prio58::R) reader structure" ]
impl crate :: Readable for PRIO58 { } # [ doc = "`write(|w| ..)` method takes [prio58::W](prio58::W) writer structure" ]
impl crate :: Writable for PRIO58 { } # [ doc = "Interrupt Source 58 Priority" ]
pub mod prio58 { # [ doc = "Reader of register PRIO58" ]
pub type R = crate :: R < u8 , super :: PRIO58 > ; # [ doc = "Writer for register PRIO58" ]
pub type W = crate :: W < u8 , super :: PRIO58 > ; # [ doc = "Register PRIO58 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO58 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 59 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio59](prio59) module" ]
pub type PRIO59 = crate :: Reg < u8 , _PRIO59 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO59 ; # [ doc = "`read()` method returns [prio59::R](prio59::R) reader structure" ]
impl crate :: Readable for PRIO59 { } # [ doc = "`write(|w| ..)` method takes [prio59::W](prio59::W) writer structure" ]
impl crate :: Writable for PRIO59 { } # [ doc = "Interrupt Source 59 Priority" ]
pub mod prio59 { # [ doc = "Reader of register PRIO59" ]
pub type R = crate :: R < u8 , super :: PRIO59 > ; # [ doc = "Writer for register PRIO59" ]
pub type W = crate :: W < u8 , super :: PRIO59 > ; # [ doc = "Register PRIO59 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO59 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 60 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio60](prio60) module" ]
pub type PRIO60 = crate :: Reg < u8 , _PRIO60 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO60 ; # [ doc = "`read()` method returns [prio60::R](prio60::R) reader structure" ]
impl crate :: Readable for PRIO60 { } # [ doc = "`write(|w| ..)` method takes [prio60::W](prio60::W) writer structure" ]
impl crate :: Writable for PRIO60 { } # [ doc = "Interrupt Source 60 Priority" ]
pub mod prio60 { # [ doc = "Reader of register PRIO60" ]
pub type R = crate :: R < u8 , super :: PRIO60 > ; # [ doc = "Writer for register PRIO60" ]
pub type W = crate :: W < u8 , super :: PRIO60 > ; # [ doc = "Register PRIO60 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO60 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 61 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio61](prio61) module" ]
pub type PRIO61 = crate :: Reg < u8 , _PRIO61 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO61 ; # [ doc = "`read()` method returns [prio61::R](prio61::R) reader structure" ]
impl crate :: Readable for PRIO61 { } # [ doc = "`write(|w| ..)` method takes [prio61::W](prio61::W) writer structure" ]
impl crate :: Writable for PRIO61 { } # [ doc = "Interrupt Source 61 Priority" ]
pub mod prio61 { # [ doc = "Reader of register PRIO61" ]
pub type R = crate :: R < u8 , super :: PRIO61 > ; # [ doc = "Writer for register PRIO61" ]
pub type W = crate :: W < u8 , super :: PRIO61 > ; # [ doc = "Register PRIO61 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO61 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt Source 62 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prio62](prio62) module" ]
pub type PRIO62 = crate :: Reg < u8 , _PRIO62 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRIO62 ; # [ doc = "`read()` method returns [prio62::R](prio62::R) reader structure" ]
impl crate :: Readable for PRIO62 { } # [ doc = "`write(|w| ..)` method takes [prio62::W](prio62::W) writer structure" ]
impl crate :: Writable for PRIO62 { } # [ doc = "Interrupt Source 62 Priority" ]
pub mod prio62 { # [ doc = "Reader of register PRIO62" ]
pub type R = crate :: R < u8 , super :: PRIO62 > ; # [ doc = "Writer for register PRIO62" ]
pub type W = crate :: W < u8 , super :: PRIO62 > ; # [ doc = "Register PRIO62 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PRIO62 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Threshold of priority for Target 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [threshold0](threshold0) module" ]
pub type THRESHOLD0 = crate :: Reg < u8 , _THRESHOLD0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _THRESHOLD0 ; # [ doc = "`read()` method returns [threshold0::R](threshold0::R) reader structure" ]
impl crate :: Readable for THRESHOLD0 { } # [ doc = "`write(|w| ..)` method takes [threshold0::W](threshold0::W) writer structure" ]
impl crate :: Writable for THRESHOLD0 { } # [ doc = "Threshold of priority for Target 0" ]
pub mod threshold0 { # [ doc = "Reader of register THRESHOLD0" ]
pub type R = crate :: R < u8 , super :: THRESHOLD0 > ; # [ doc = "Writer for register THRESHOLD0" ]
pub type W = crate :: W < u8 , super :: THRESHOLD0 > ; # [ doc = "Register THRESHOLD0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: THRESHOLD0 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Claim interrupt by read, complete interrupt by write for Target 0. Value read/written is interrupt ID. Reading a value of 0 means no pending interrupts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc0](cc0) module" ]
pub type CC0 = crate :: Reg < u8 , _CC0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CC0 ; # [ doc = "`read()` method returns [cc0::R](cc0::R) reader structure" ]
impl crate :: Readable for CC0 { } # [ doc = "`write(|w| ..)` method takes [cc0::W](cc0::W) writer structure" ]
impl crate :: Writable for CC0 { } # [ doc = "Claim interrupt by read, complete interrupt by write for Target 0. Value read/written is interrupt ID. Reading a value of 0 means no pending interrupts." ]
pub mod cc0 { # [ doc = "Reader of register CC0" ]
pub type R = crate :: R < u8 , super :: CC0 > ; # [ doc = "Writer for register CC0" ]
pub type W = crate :: W < u8 , super :: CC0 > ; # [ doc = "Register CC0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CC0 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "msip for Hart 0. Write 1 to here asserts software interrupt for Hart msip_o\\[0\\], write 0 to clear.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msip0](msip0) module" ]
pub type MSIP0 = crate :: Reg < u8 , _MSIP0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MSIP0 ; # [ doc = "`read()` method returns [msip0::R](msip0::R) reader structure" ]
impl crate :: Readable for MSIP0 { } # [ doc = "`write(|w| ..)` method takes [msip0::W](msip0::W) writer structure" ]
impl crate :: Writable for MSIP0 { } # [ doc = "msip for Hart 0. Write 1 to here asserts software interrupt for Hart msip_o\\[0\\], write 0 to clear." ]
pub mod msip0 { # [ doc = "Reader of register MSIP0" ]
pub type R = crate :: R < u8 , super :: MSIP0 > ; # [ doc = "Writer for register MSIP0" ]
pub type W = crate :: W < u8 , super :: MSIP0 > ; # [ doc = "Register MSIP0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: MSIP0 { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } } # [ doc = "pinmux" ]
pub struct PINMUX { _marker : PhantomData < * const ( ) > } unsafe impl Send for PINMUX { } impl PINMUX { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const pinmux :: RegisterBlock { 0x4007_0000 as * const _ } } impl Deref for PINMUX { type Target = pinmux :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * PINMUX :: ptr ( ) } } } # [ doc = "pinmux" ]
pub mod pinmux { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Register write enable for all control registers." ]
pub regen : REGEN , # [ doc = "0x04 - Mux select for peripheral inputs." ]
pub periph_insel : PERIPH_INSEL , # [ doc = "0x20 - Mux select for MIO outputs." ]
pub mio_outsel : MIO_OUTSEL , } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct PERIPH_INSEL { # [ doc = "0x00 - Mux select for peripheral inputs." ]
pub periph_insel0 : self :: periph_insel :: PERIPH_INSEL0 , # [ doc = "0x04 - Mux select for peripheral inputs." ]
pub periph_insel1 : self :: periph_insel :: PERIPH_INSEL1 , # [ doc = "0x08 - Mux select for peripheral inputs." ]
pub periph_insel2 : self :: periph_insel :: PERIPH_INSEL2 , # [ doc = "0x0c - Mux select for peripheral inputs." ]
pub periph_insel3 : self :: periph_insel :: PERIPH_INSEL3 , # [ doc = "0x10 - Mux select for peripheral inputs." ]
pub periph_insel4 : self :: periph_insel :: PERIPH_INSEL4 , # [ doc = "0x14 - Mux select for peripheral inputs." ]
pub periph_insel5 : self :: periph_insel :: PERIPH_INSEL5 , # [ doc = "0x18 - Mux select for peripheral inputs." ]
pub periph_insel6 : self :: periph_insel :: PERIPH_INSEL6 , } # [ doc = r"Register block" ]
# [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel { # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel0](periph_insel0) module" ]
pub type PERIPH_INSEL0 = crate :: Reg < u32 , _PERIPH_INSEL0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL0 ; # [ doc = "`read()` method returns [periph_insel0::R](periph_insel0::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL0 { } # [ doc = "`write(|w| ..)` method takes [periph_insel0::W](periph_insel0::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL0 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel0 { # [ doc = "Reader of register PERIPH_INSEL0" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL0 > ; # [ doc = "Writer for register PERIPH_INSEL0" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL0 > ; # [ doc = "Register PERIPH_INSEL0 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN0`" ]
pub type IN0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN0`" ]
pub struct IN0_W < 'a > { w : & 'a mut W , } impl < 'a > IN0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN1`" ]
pub type IN1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN1`" ]
pub struct IN1_W < 'a > { w : & 'a mut W , } impl < 'a > IN1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN2`" ]
pub type IN2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN2`" ]
pub struct IN2_W < 'a > { w : & 'a mut W , } impl < 'a > IN2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN3`" ]
pub type IN3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN3`" ]
pub struct IN3_W < 'a > { w : & 'a mut W , } impl < 'a > IN3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN4`" ]
pub type IN4_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN4`" ]
pub struct IN4_W < 'a > { w : & 'a mut W , } impl < 'a > IN4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN0" ]
# [ inline ( always ) ]
pub fn in0 ( & self ) -> IN0_R { IN0_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN1" ]
# [ inline ( always ) ]
pub fn in1 ( & self ) -> IN1_R { IN1_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN2" ]
# [ inline ( always ) ]
pub fn in2 ( & self ) -> IN2_R { IN2_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN3" ]
# [ inline ( always ) ]
pub fn in3 ( & self ) -> IN3_R { IN3_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN4" ]
# [ inline ( always ) ]
pub fn in4 ( & self ) -> IN4_R { IN4_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN0" ]
# [ inline ( always ) ]
pub fn in0 ( & mut self ) -> IN0_W { IN0_W { w : self } } # [ doc = "Bits 6:11 - for IN1" ]
# [ inline ( always ) ]
pub fn in1 ( & mut self ) -> IN1_W { IN1_W { w : self } } # [ doc = "Bits 12:17 - for IN2" ]
# [ inline ( always ) ]
pub fn in2 ( & mut self ) -> IN2_W { IN2_W { w : self } } # [ doc = "Bits 18:23 - for IN3" ]
# [ inline ( always ) ]
pub fn in3 ( & mut self ) -> IN3_W { IN3_W { w : self } } # [ doc = "Bits 24:29 - for IN4" ]
# [ inline ( always ) ]
pub fn in4 ( & mut self ) -> IN4_W { IN4_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel1](periph_insel1) module" ]
pub type PERIPH_INSEL1 = crate :: Reg < u32 , _PERIPH_INSEL1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL1 ; # [ doc = "`read()` method returns [periph_insel1::R](periph_insel1::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL1 { } # [ doc = "`write(|w| ..)` method takes [periph_insel1::W](periph_insel1::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL1 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel1 { # [ doc = "Reader of register PERIPH_INSEL1" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL1 > ; # [ doc = "Writer for register PERIPH_INSEL1" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL1 > ; # [ doc = "Register PERIPH_INSEL1 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN5`" ]
pub type IN5_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN5`" ]
pub struct IN5_W < 'a > { w : & 'a mut W , } impl < 'a > IN5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN6`" ]
pub type IN6_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN6`" ]
pub struct IN6_W < 'a > { w : & 'a mut W , } impl < 'a > IN6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN7`" ]
pub type IN7_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN7`" ]
pub struct IN7_W < 'a > { w : & 'a mut W , } impl < 'a > IN7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN8`" ]
pub type IN8_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN8`" ]
pub struct IN8_W < 'a > { w : & 'a mut W , } impl < 'a > IN8_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN9`" ]
pub type IN9_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN9`" ]
pub struct IN9_W < 'a > { w : & 'a mut W , } impl < 'a > IN9_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN5" ]
# [ inline ( always ) ]
pub fn in5 ( & self ) -> IN5_R { IN5_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN6" ]
# [ inline ( always ) ]
pub fn in6 ( & self ) -> IN6_R { IN6_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN7" ]
# [ inline ( always ) ]
pub fn in7 ( & self ) -> IN7_R { IN7_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN8" ]
# [ inline ( always ) ]
pub fn in8 ( & self ) -> IN8_R { IN8_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN9" ]
# [ inline ( always ) ]
pub fn in9 ( & self ) -> IN9_R { IN9_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN5" ]
# [ inline ( always ) ]
pub fn in5 ( & mut self ) -> IN5_W { IN5_W { w : self } } # [ doc = "Bits 6:11 - for IN6" ]
# [ inline ( always ) ]
pub fn in6 ( & mut self ) -> IN6_W { IN6_W { w : self } } # [ doc = "Bits 12:17 - for IN7" ]
# [ inline ( always ) ]
pub fn in7 ( & mut self ) -> IN7_W { IN7_W { w : self } } # [ doc = "Bits 18:23 - for IN8" ]
# [ inline ( always ) ]
pub fn in8 ( & mut self ) -> IN8_W { IN8_W { w : self } } # [ doc = "Bits 24:29 - for IN9" ]
# [ inline ( always ) ]
pub fn in9 ( & mut self ) -> IN9_W { IN9_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel2](periph_insel2) module" ]
pub type PERIPH_INSEL2 = crate :: Reg < u32 , _PERIPH_INSEL2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL2 ; # [ doc = "`read()` method returns [periph_insel2::R](periph_insel2::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL2 { } # [ doc = "`write(|w| ..)` method takes [periph_insel2::W](periph_insel2::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL2 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel2 { # [ doc = "Reader of register PERIPH_INSEL2" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL2 > ; # [ doc = "Writer for register PERIPH_INSEL2" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL2 > ; # [ doc = "Register PERIPH_INSEL2 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN10`" ]
pub type IN10_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN10`" ]
pub struct IN10_W < 'a > { w : & 'a mut W , } impl < 'a > IN10_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN11`" ]
pub type IN11_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN11`" ]
pub struct IN11_W < 'a > { w : & 'a mut W , } impl < 'a > IN11_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN12`" ]
pub type IN12_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN12`" ]
pub struct IN12_W < 'a > { w : & 'a mut W , } impl < 'a > IN12_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN13`" ]
pub type IN13_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN13`" ]
pub struct IN13_W < 'a > { w : & 'a mut W , } impl < 'a > IN13_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN14`" ]
pub type IN14_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN14`" ]
pub struct IN14_W < 'a > { w : & 'a mut W , } impl < 'a > IN14_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN10" ]
# [ inline ( always ) ]
pub fn in10 ( & self ) -> IN10_R { IN10_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN11" ]
# [ inline ( always ) ]
pub fn in11 ( & self ) -> IN11_R { IN11_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN12" ]
# [ inline ( always ) ]
pub fn in12 ( & self ) -> IN12_R { IN12_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN13" ]
# [ inline ( always ) ]
pub fn in13 ( & self ) -> IN13_R { IN13_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN14" ]
# [ inline ( always ) ]
pub fn in14 ( & self ) -> IN14_R { IN14_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN10" ]
# [ inline ( always ) ]
pub fn in10 ( & mut self ) -> IN10_W { IN10_W { w : self } } # [ doc = "Bits 6:11 - for IN11" ]
# [ inline ( always ) ]
pub fn in11 ( & mut self ) -> IN11_W { IN11_W { w : self } } # [ doc = "Bits 12:17 - for IN12" ]
# [ inline ( always ) ]
pub fn in12 ( & mut self ) -> IN12_W { IN12_W { w : self } } # [ doc = "Bits 18:23 - for IN13" ]
# [ inline ( always ) ]
pub fn in13 ( & mut self ) -> IN13_W { IN13_W { w : self } } # [ doc = "Bits 24:29 - for IN14" ]
# [ inline ( always ) ]
pub fn in14 ( & mut self ) -> IN14_W { IN14_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel3](periph_insel3) module" ]
pub type PERIPH_INSEL3 = crate :: Reg < u32 , _PERIPH_INSEL3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL3 ; # [ doc = "`read()` method returns [periph_insel3::R](periph_insel3::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL3 { } # [ doc = "`write(|w| ..)` method takes [periph_insel3::W](periph_insel3::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL3 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel3 { # [ doc = "Reader of register PERIPH_INSEL3" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL3 > ; # [ doc = "Writer for register PERIPH_INSEL3" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL3 > ; # [ doc = "Register PERIPH_INSEL3 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN15`" ]
pub type IN15_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN15`" ]
pub struct IN15_W < 'a > { w : & 'a mut W , } impl < 'a > IN15_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN16`" ]
pub type IN16_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN16`" ]
pub struct IN16_W < 'a > { w : & 'a mut W , } impl < 'a > IN16_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN17`" ]
pub type IN17_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN17`" ]
pub struct IN17_W < 'a > { w : & 'a mut W , } impl < 'a > IN17_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN18`" ]
pub type IN18_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN18`" ]
pub struct IN18_W < 'a > { w : & 'a mut W , } impl < 'a > IN18_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN19`" ]
pub type IN19_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN19`" ]
pub struct IN19_W < 'a > { w : & 'a mut W , } impl < 'a > IN19_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN15" ]
# [ inline ( always ) ]
pub fn in15 ( & self ) -> IN15_R { IN15_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN16" ]
# [ inline ( always ) ]
pub fn in16 ( & self ) -> IN16_R { IN16_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN17" ]
# [ inline ( always ) ]
pub fn in17 ( & self ) -> IN17_R { IN17_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN18" ]
# [ inline ( always ) ]
pub fn in18 ( & self ) -> IN18_R { IN18_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN19" ]
# [ inline ( always ) ]
pub fn in19 ( & self ) -> IN19_R { IN19_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN15" ]
# [ inline ( always ) ]
pub fn in15 ( & mut self ) -> IN15_W { IN15_W { w : self } } # [ doc = "Bits 6:11 - for IN16" ]
# [ inline ( always ) ]
pub fn in16 ( & mut self ) -> IN16_W { IN16_W { w : self } } # [ doc = "Bits 12:17 - for IN17" ]
# [ inline ( always ) ]
pub fn in17 ( & mut self ) -> IN17_W { IN17_W { w : self } } # [ doc = "Bits 18:23 - for IN18" ]
# [ inline ( always ) ]
pub fn in18 ( & mut self ) -> IN18_W { IN18_W { w : self } } # [ doc = "Bits 24:29 - for IN19" ]
# [ inline ( always ) ]
pub fn in19 ( & mut self ) -> IN19_W { IN19_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel4](periph_insel4) module" ]
pub type PERIPH_INSEL4 = crate :: Reg < u32 , _PERIPH_INSEL4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL4 ; # [ doc = "`read()` method returns [periph_insel4::R](periph_insel4::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL4 { } # [ doc = "`write(|w| ..)` method takes [periph_insel4::W](periph_insel4::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL4 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel4 { # [ doc = "Reader of register PERIPH_INSEL4" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL4 > ; # [ doc = "Writer for register PERIPH_INSEL4" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL4 > ; # [ doc = "Register PERIPH_INSEL4 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL4 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN20`" ]
pub type IN20_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN20`" ]
pub struct IN20_W < 'a > { w : & 'a mut W , } impl < 'a > IN20_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN21`" ]
pub type IN21_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN21`" ]
pub struct IN21_W < 'a > { w : & 'a mut W , } impl < 'a > IN21_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN22`" ]
pub type IN22_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN22`" ]
pub struct IN22_W < 'a > { w : & 'a mut W , } impl < 'a > IN22_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN23`" ]
pub type IN23_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN23`" ]
pub struct IN23_W < 'a > { w : & 'a mut W , } impl < 'a > IN23_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN24`" ]
pub type IN24_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN24`" ]
pub struct IN24_W < 'a > { w : & 'a mut W , } impl < 'a > IN24_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN20" ]
# [ inline ( always ) ]
pub fn in20 ( & self ) -> IN20_R { IN20_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN21" ]
# [ inline ( always ) ]
pub fn in21 ( & self ) -> IN21_R { IN21_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN22" ]
# [ inline ( always ) ]
pub fn in22 ( & self ) -> IN22_R { IN22_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN23" ]
# [ inline ( always ) ]
pub fn in23 ( & self ) -> IN23_R { IN23_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN24" ]
# [ inline ( always ) ]
pub fn in24 ( & self ) -> IN24_R { IN24_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN20" ]
# [ inline ( always ) ]
pub fn in20 ( & mut self ) -> IN20_W { IN20_W { w : self } } # [ doc = "Bits 6:11 - for IN21" ]
# [ inline ( always ) ]
pub fn in21 ( & mut self ) -> IN21_W { IN21_W { w : self } } # [ doc = "Bits 12:17 - for IN22" ]
# [ inline ( always ) ]
pub fn in22 ( & mut self ) -> IN22_W { IN22_W { w : self } } # [ doc = "Bits 18:23 - for IN23" ]
# [ inline ( always ) ]
pub fn in23 ( & mut self ) -> IN23_W { IN23_W { w : self } } # [ doc = "Bits 24:29 - for IN24" ]
# [ inline ( always ) ]
pub fn in24 ( & mut self ) -> IN24_W { IN24_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel5](periph_insel5) module" ]
pub type PERIPH_INSEL5 = crate :: Reg < u32 , _PERIPH_INSEL5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL5 ; # [ doc = "`read()` method returns [periph_insel5::R](periph_insel5::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL5 { } # [ doc = "`write(|w| ..)` method takes [periph_insel5::W](periph_insel5::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL5 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel5 { # [ doc = "Reader of register PERIPH_INSEL5" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL5 > ; # [ doc = "Writer for register PERIPH_INSEL5" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL5 > ; # [ doc = "Register PERIPH_INSEL5 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL5 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN25`" ]
pub type IN25_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN25`" ]
pub struct IN25_W < 'a > { w : & 'a mut W , } impl < 'a > IN25_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN26`" ]
pub type IN26_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN26`" ]
pub struct IN26_W < 'a > { w : & 'a mut W , } impl < 'a > IN26_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `IN27`" ]
pub type IN27_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN27`" ]
pub struct IN27_W < 'a > { w : & 'a mut W , } impl < 'a > IN27_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `IN28`" ]
pub type IN28_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN28`" ]
pub struct IN28_W < 'a > { w : & 'a mut W , } impl < 'a > IN28_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `IN29`" ]
pub type IN29_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN29`" ]
pub struct IN29_W < 'a > { w : & 'a mut W , } impl < 'a > IN29_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN25" ]
# [ inline ( always ) ]
pub fn in25 ( & self ) -> IN25_R { IN25_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN26" ]
# [ inline ( always ) ]
pub fn in26 ( & self ) -> IN26_R { IN26_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for IN27" ]
# [ inline ( always ) ]
pub fn in27 ( & self ) -> IN27_R { IN27_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for IN28" ]
# [ inline ( always ) ]
pub fn in28 ( & self ) -> IN28_R { IN28_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for IN29" ]
# [ inline ( always ) ]
pub fn in29 ( & self ) -> IN29_R { IN29_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN25" ]
# [ inline ( always ) ]
pub fn in25 ( & mut self ) -> IN25_W { IN25_W { w : self } } # [ doc = "Bits 6:11 - for IN26" ]
# [ inline ( always ) ]
pub fn in26 ( & mut self ) -> IN26_W { IN26_W { w : self } } # [ doc = "Bits 12:17 - for IN27" ]
# [ inline ( always ) ]
pub fn in27 ( & mut self ) -> IN27_W { IN27_W { w : self } } # [ doc = "Bits 18:23 - for IN28" ]
# [ inline ( always ) ]
pub fn in28 ( & mut self ) -> IN28_W { IN28_W { w : self } } # [ doc = "Bits 24:29 - for IN29" ]
# [ inline ( always ) ]
pub fn in29 ( & mut self ) -> IN29_W { IN29_W { w : self } } } } # [ doc = "Mux select for peripheral inputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periph_insel6](periph_insel6) module" ]
pub type PERIPH_INSEL6 = crate :: Reg < u32 , _PERIPH_INSEL6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PERIPH_INSEL6 ; # [ doc = "`read()` method returns [periph_insel6::R](periph_insel6::R) reader structure" ]
impl crate :: Readable for PERIPH_INSEL6 { } # [ doc = "`write(|w| ..)` method takes [periph_insel6::W](periph_insel6::W) writer structure" ]
impl crate :: Writable for PERIPH_INSEL6 { } # [ doc = "Mux select for peripheral inputs." ]
pub mod periph_insel6 { # [ doc = "Reader of register PERIPH_INSEL6" ]
pub type R = crate :: R < u32 , super :: PERIPH_INSEL6 > ; # [ doc = "Writer for register PERIPH_INSEL6" ]
pub type W = crate :: W < u32 , super :: PERIPH_INSEL6 > ; # [ doc = "Register PERIPH_INSEL6 `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: PERIPH_INSEL6 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `IN30`" ]
pub type IN30_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN30`" ]
pub struct IN30_W < 'a > { w : & 'a mut W , } impl < 'a > IN30_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `IN31`" ]
pub type IN31_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `IN31`" ]
pub struct IN31_W < 'a > { w : & 'a mut W , } impl < 'a > IN31_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN30" ]
# [ inline ( always ) ]
pub fn in30 ( & self ) -> IN30_R { IN30_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for IN31" ]
# [ inline ( always ) ]
pub fn in31 ( & self ) -> IN31_R { IN31_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. >=2: MIO pads (i.e., add 2 to the native MIO pad index). for IN30" ]
# [ inline ( always ) ]
pub fn in30 ( & mut self ) -> IN30_W { IN30_W { w : self } } # [ doc = "Bits 6:11 - for IN31" ]
# [ inline ( always ) ]
pub fn in31 ( & mut self ) -> IN31_W { IN31_W { w : self } } } } } # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct MIO_OUTSEL { # [ doc = "0x00 - Mux select for MIO outputs." ]
pub mio_outsel0 : self :: mio_outsel :: MIO_OUTSEL0 , # [ doc = "0x04 - Mux select for MIO outputs." ]
pub mio_outsel1 : self :: mio_outsel :: MIO_OUTSEL1 , # [ doc = "0x08 - Mux select for MIO outputs." ]
pub mio_outsel2 : self :: mio_outsel :: MIO_OUTSEL2 , # [ doc = "0x0c - Mux select for MIO outputs." ]
pub mio_outsel3 : self :: mio_outsel :: MIO_OUTSEL3 , # [ doc = "0x10 - Mux select for MIO outputs." ]
pub mio_outsel4 : self :: mio_outsel :: MIO_OUTSEL4 , # [ doc = "0x14 - Mux select for MIO outputs." ]
pub mio_outsel5 : self :: mio_outsel :: MIO_OUTSEL5 , # [ doc = "0x18 - Mux select for MIO outputs." ]
pub mio_outsel6 : self :: mio_outsel :: MIO_OUTSEL6 , } # [ doc = r"Register block" ]
# [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel { # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel0](mio_outsel0) module" ]
pub type MIO_OUTSEL0 = crate :: Reg < u32 , _MIO_OUTSEL0 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL0 ; # [ doc = "`read()` method returns [mio_outsel0::R](mio_outsel0::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL0 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel0::W](mio_outsel0::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL0 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel0 { # [ doc = "Reader of register MIO_OUTSEL0" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL0 > ; # [ doc = "Writer for register MIO_OUTSEL0" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL0 > ; # [ doc = "Register MIO_OUTSEL0 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL0 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT0`" ]
pub type OUT0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT0`" ]
pub struct OUT0_W < 'a > { w : & 'a mut W , } impl < 'a > OUT0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT1`" ]
pub type OUT1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT1`" ]
pub struct OUT1_W < 'a > { w : & 'a mut W , } impl < 'a > OUT1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT2`" ]
pub type OUT2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT2`" ]
pub struct OUT2_W < 'a > { w : & 'a mut W , } impl < 'a > OUT2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT3`" ]
pub type OUT3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT3`" ]
pub struct OUT3_W < 'a > { w : & 'a mut W , } impl < 'a > OUT3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT4`" ]
pub type OUT4_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT4`" ]
pub struct OUT4_W < 'a > { w : & 'a mut W , } impl < 'a > OUT4_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT0" ]
# [ inline ( always ) ]
pub fn out0 ( & self ) -> OUT0_R { OUT0_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT1" ]
# [ inline ( always ) ]
pub fn out1 ( & self ) -> OUT1_R { OUT1_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT2" ]
# [ inline ( always ) ]
pub fn out2 ( & self ) -> OUT2_R { OUT2_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT3" ]
# [ inline ( always ) ]
pub fn out3 ( & self ) -> OUT3_R { OUT3_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT4" ]
# [ inline ( always ) ]
pub fn out4 ( & self ) -> OUT4_R { OUT4_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT0" ]
# [ inline ( always ) ]
pub fn out0 ( & mut self ) -> OUT0_W { OUT0_W { w : self } } # [ doc = "Bits 6:11 - for OUT1" ]
# [ inline ( always ) ]
pub fn out1 ( & mut self ) -> OUT1_W { OUT1_W { w : self } } # [ doc = "Bits 12:17 - for OUT2" ]
# [ inline ( always ) ]
pub fn out2 ( & mut self ) -> OUT2_W { OUT2_W { w : self } } # [ doc = "Bits 18:23 - for OUT3" ]
# [ inline ( always ) ]
pub fn out3 ( & mut self ) -> OUT3_W { OUT3_W { w : self } } # [ doc = "Bits 24:29 - for OUT4" ]
# [ inline ( always ) ]
pub fn out4 ( & mut self ) -> OUT4_W { OUT4_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel1](mio_outsel1) module" ]
pub type MIO_OUTSEL1 = crate :: Reg < u32 , _MIO_OUTSEL1 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL1 ; # [ doc = "`read()` method returns [mio_outsel1::R](mio_outsel1::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL1 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel1::W](mio_outsel1::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL1 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel1 { # [ doc = "Reader of register MIO_OUTSEL1" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL1 > ; # [ doc = "Writer for register MIO_OUTSEL1" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL1 > ; # [ doc = "Register MIO_OUTSEL1 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL1 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT5`" ]
pub type OUT5_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT5`" ]
pub struct OUT5_W < 'a > { w : & 'a mut W , } impl < 'a > OUT5_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT6`" ]
pub type OUT6_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT6`" ]
pub struct OUT6_W < 'a > { w : & 'a mut W , } impl < 'a > OUT6_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT7`" ]
pub type OUT7_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT7`" ]
pub struct OUT7_W < 'a > { w : & 'a mut W , } impl < 'a > OUT7_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT8`" ]
pub type OUT8_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT8`" ]
pub struct OUT8_W < 'a > { w : & 'a mut W , } impl < 'a > OUT8_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT9`" ]
pub type OUT9_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT9`" ]
pub struct OUT9_W < 'a > { w : & 'a mut W , } impl < 'a > OUT9_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT5" ]
# [ inline ( always ) ]
pub fn out5 ( & self ) -> OUT5_R { OUT5_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT6" ]
# [ inline ( always ) ]
pub fn out6 ( & self ) -> OUT6_R { OUT6_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT7" ]
# [ inline ( always ) ]
pub fn out7 ( & self ) -> OUT7_R { OUT7_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT8" ]
# [ inline ( always ) ]
pub fn out8 ( & self ) -> OUT8_R { OUT8_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT9" ]
# [ inline ( always ) ]
pub fn out9 ( & self ) -> OUT9_R { OUT9_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT5" ]
# [ inline ( always ) ]
pub fn out5 ( & mut self ) -> OUT5_W { OUT5_W { w : self } } # [ doc = "Bits 6:11 - for OUT6" ]
# [ inline ( always ) ]
pub fn out6 ( & mut self ) -> OUT6_W { OUT6_W { w : self } } # [ doc = "Bits 12:17 - for OUT7" ]
# [ inline ( always ) ]
pub fn out7 ( & mut self ) -> OUT7_W { OUT7_W { w : self } } # [ doc = "Bits 18:23 - for OUT8" ]
# [ inline ( always ) ]
pub fn out8 ( & mut self ) -> OUT8_W { OUT8_W { w : self } } # [ doc = "Bits 24:29 - for OUT9" ]
# [ inline ( always ) ]
pub fn out9 ( & mut self ) -> OUT9_W { OUT9_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel2](mio_outsel2) module" ]
pub type MIO_OUTSEL2 = crate :: Reg < u32 , _MIO_OUTSEL2 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL2 ; # [ doc = "`read()` method returns [mio_outsel2::R](mio_outsel2::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL2 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel2::W](mio_outsel2::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL2 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel2 { # [ doc = "Reader of register MIO_OUTSEL2" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL2 > ; # [ doc = "Writer for register MIO_OUTSEL2" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL2 > ; # [ doc = "Register MIO_OUTSEL2 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL2 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT10`" ]
pub type OUT10_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT10`" ]
pub struct OUT10_W < 'a > { w : & 'a mut W , } impl < 'a > OUT10_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT11`" ]
pub type OUT11_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT11`" ]
pub struct OUT11_W < 'a > { w : & 'a mut W , } impl < 'a > OUT11_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT12`" ]
pub type OUT12_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT12`" ]
pub struct OUT12_W < 'a > { w : & 'a mut W , } impl < 'a > OUT12_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT13`" ]
pub type OUT13_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT13`" ]
pub struct OUT13_W < 'a > { w : & 'a mut W , } impl < 'a > OUT13_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT14`" ]
pub type OUT14_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT14`" ]
pub struct OUT14_W < 'a > { w : & 'a mut W , } impl < 'a > OUT14_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT10" ]
# [ inline ( always ) ]
pub fn out10 ( & self ) -> OUT10_R { OUT10_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT11" ]
# [ inline ( always ) ]
pub fn out11 ( & self ) -> OUT11_R { OUT11_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT12" ]
# [ inline ( always ) ]
pub fn out12 ( & self ) -> OUT12_R { OUT12_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT13" ]
# [ inline ( always ) ]
pub fn out13 ( & self ) -> OUT13_R { OUT13_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT14" ]
# [ inline ( always ) ]
pub fn out14 ( & self ) -> OUT14_R { OUT14_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT10" ]
# [ inline ( always ) ]
pub fn out10 ( & mut self ) -> OUT10_W { OUT10_W { w : self } } # [ doc = "Bits 6:11 - for OUT11" ]
# [ inline ( always ) ]
pub fn out11 ( & mut self ) -> OUT11_W { OUT11_W { w : self } } # [ doc = "Bits 12:17 - for OUT12" ]
# [ inline ( always ) ]
pub fn out12 ( & mut self ) -> OUT12_W { OUT12_W { w : self } } # [ doc = "Bits 18:23 - for OUT13" ]
# [ inline ( always ) ]
pub fn out13 ( & mut self ) -> OUT13_W { OUT13_W { w : self } } # [ doc = "Bits 24:29 - for OUT14" ]
# [ inline ( always ) ]
pub fn out14 ( & mut self ) -> OUT14_W { OUT14_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel3](mio_outsel3) module" ]
pub type MIO_OUTSEL3 = crate :: Reg < u32 , _MIO_OUTSEL3 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL3 ; # [ doc = "`read()` method returns [mio_outsel3::R](mio_outsel3::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL3 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel3::W](mio_outsel3::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL3 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel3 { # [ doc = "Reader of register MIO_OUTSEL3" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL3 > ; # [ doc = "Writer for register MIO_OUTSEL3" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL3 > ; # [ doc = "Register MIO_OUTSEL3 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL3 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT15`" ]
pub type OUT15_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT15`" ]
pub struct OUT15_W < 'a > { w : & 'a mut W , } impl < 'a > OUT15_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT16`" ]
pub type OUT16_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT16`" ]
pub struct OUT16_W < 'a > { w : & 'a mut W , } impl < 'a > OUT16_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT17`" ]
pub type OUT17_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT17`" ]
pub struct OUT17_W < 'a > { w : & 'a mut W , } impl < 'a > OUT17_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT18`" ]
pub type OUT18_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT18`" ]
pub struct OUT18_W < 'a > { w : & 'a mut W , } impl < 'a > OUT18_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT19`" ]
pub type OUT19_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT19`" ]
pub struct OUT19_W < 'a > { w : & 'a mut W , } impl < 'a > OUT19_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT15" ]
# [ inline ( always ) ]
pub fn out15 ( & self ) -> OUT15_R { OUT15_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT16" ]
# [ inline ( always ) ]
pub fn out16 ( & self ) -> OUT16_R { OUT16_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT17" ]
# [ inline ( always ) ]
pub fn out17 ( & self ) -> OUT17_R { OUT17_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT18" ]
# [ inline ( always ) ]
pub fn out18 ( & self ) -> OUT18_R { OUT18_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT19" ]
# [ inline ( always ) ]
pub fn out19 ( & self ) -> OUT19_R { OUT19_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT15" ]
# [ inline ( always ) ]
pub fn out15 ( & mut self ) -> OUT15_W { OUT15_W { w : self } } # [ doc = "Bits 6:11 - for OUT16" ]
# [ inline ( always ) ]
pub fn out16 ( & mut self ) -> OUT16_W { OUT16_W { w : self } } # [ doc = "Bits 12:17 - for OUT17" ]
# [ inline ( always ) ]
pub fn out17 ( & mut self ) -> OUT17_W { OUT17_W { w : self } } # [ doc = "Bits 18:23 - for OUT18" ]
# [ inline ( always ) ]
pub fn out18 ( & mut self ) -> OUT18_W { OUT18_W { w : self } } # [ doc = "Bits 24:29 - for OUT19" ]
# [ inline ( always ) ]
pub fn out19 ( & mut self ) -> OUT19_W { OUT19_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel4](mio_outsel4) module" ]
pub type MIO_OUTSEL4 = crate :: Reg < u32 , _MIO_OUTSEL4 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL4 ; # [ doc = "`read()` method returns [mio_outsel4::R](mio_outsel4::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL4 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel4::W](mio_outsel4::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL4 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel4 { # [ doc = "Reader of register MIO_OUTSEL4" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL4 > ; # [ doc = "Writer for register MIO_OUTSEL4" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL4 > ; # [ doc = "Register MIO_OUTSEL4 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL4 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT20`" ]
pub type OUT20_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT20`" ]
pub struct OUT20_W < 'a > { w : & 'a mut W , } impl < 'a > OUT20_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT21`" ]
pub type OUT21_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT21`" ]
pub struct OUT21_W < 'a > { w : & 'a mut W , } impl < 'a > OUT21_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT22`" ]
pub type OUT22_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT22`" ]
pub struct OUT22_W < 'a > { w : & 'a mut W , } impl < 'a > OUT22_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT23`" ]
pub type OUT23_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT23`" ]
pub struct OUT23_W < 'a > { w : & 'a mut W , } impl < 'a > OUT23_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT24`" ]
pub type OUT24_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT24`" ]
pub struct OUT24_W < 'a > { w : & 'a mut W , } impl < 'a > OUT24_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT20" ]
# [ inline ( always ) ]
pub fn out20 ( & self ) -> OUT20_R { OUT20_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT21" ]
# [ inline ( always ) ]
pub fn out21 ( & self ) -> OUT21_R { OUT21_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT22" ]
# [ inline ( always ) ]
pub fn out22 ( & self ) -> OUT22_R { OUT22_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT23" ]
# [ inline ( always ) ]
pub fn out23 ( & self ) -> OUT23_R { OUT23_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT24" ]
# [ inline ( always ) ]
pub fn out24 ( & self ) -> OUT24_R { OUT24_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT20" ]
# [ inline ( always ) ]
pub fn out20 ( & mut self ) -> OUT20_W { OUT20_W { w : self } } # [ doc = "Bits 6:11 - for OUT21" ]
# [ inline ( always ) ]
pub fn out21 ( & mut self ) -> OUT21_W { OUT21_W { w : self } } # [ doc = "Bits 12:17 - for OUT22" ]
# [ inline ( always ) ]
pub fn out22 ( & mut self ) -> OUT22_W { OUT22_W { w : self } } # [ doc = "Bits 18:23 - for OUT23" ]
# [ inline ( always ) ]
pub fn out23 ( & mut self ) -> OUT23_W { OUT23_W { w : self } } # [ doc = "Bits 24:29 - for OUT24" ]
# [ inline ( always ) ]
pub fn out24 ( & mut self ) -> OUT24_W { OUT24_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel5](mio_outsel5) module" ]
pub type MIO_OUTSEL5 = crate :: Reg < u32 , _MIO_OUTSEL5 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL5 ; # [ doc = "`read()` method returns [mio_outsel5::R](mio_outsel5::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL5 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel5::W](mio_outsel5::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL5 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel5 { # [ doc = "Reader of register MIO_OUTSEL5" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL5 > ; # [ doc = "Writer for register MIO_OUTSEL5" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL5 > ; # [ doc = "Register MIO_OUTSEL5 `reset()`'s with value 0x0208_2082" ]
impl crate :: ResetValue for super :: MIO_OUTSEL5 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x0208_2082 } } # [ doc = "Reader of field `OUT25`" ]
pub type OUT25_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT25`" ]
pub struct OUT25_W < 'a > { w : & 'a mut W , } impl < 'a > OUT25_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT26`" ]
pub type OUT26_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT26`" ]
pub struct OUT26_W < 'a > { w : & 'a mut W , } impl < 'a > OUT26_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Reader of field `OUT27`" ]
pub type OUT27_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT27`" ]
pub struct OUT27_W < 'a > { w : & 'a mut W , } impl < 'a > OUT27_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 12 ) ) | ( ( ( value as u32 ) & 0x3f ) << 12 ) ; self . w } } # [ doc = "Reader of field `OUT28`" ]
pub type OUT28_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT28`" ]
pub struct OUT28_W < 'a > { w : & 'a mut W , } impl < 'a > OUT28_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 18 ) ) | ( ( ( value as u32 ) & 0x3f ) << 18 ) ; self . w } } # [ doc = "Reader of field `OUT29`" ]
pub type OUT29_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT29`" ]
pub struct OUT29_W < 'a > { w : & 'a mut W , } impl < 'a > OUT29_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT25" ]
# [ inline ( always ) ]
pub fn out25 ( & self ) -> OUT25_R { OUT25_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT26" ]
# [ inline ( always ) ]
pub fn out26 ( & self ) -> OUT26_R { OUT26_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:17 - for OUT27" ]
# [ inline ( always ) ]
pub fn out27 ( & self ) -> OUT27_R { OUT27_R :: new ( ( ( self . bits >> 12 ) & 0x3f ) as u8 ) } # [ doc = "Bits 18:23 - for OUT28" ]
# [ inline ( always ) ]
pub fn out28 ( & self ) -> OUT28_R { OUT28_R :: new ( ( ( self . bits >> 18 ) & 0x3f ) as u8 ) } # [ doc = "Bits 24:29 - for OUT29" ]
# [ inline ( always ) ]
pub fn out29 ( & self ) -> OUT29_R { OUT29_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT25" ]
# [ inline ( always ) ]
pub fn out25 ( & mut self ) -> OUT25_W { OUT25_W { w : self } } # [ doc = "Bits 6:11 - for OUT26" ]
# [ inline ( always ) ]
pub fn out26 ( & mut self ) -> OUT26_W { OUT26_W { w : self } } # [ doc = "Bits 12:17 - for OUT27" ]
# [ inline ( always ) ]
pub fn out27 ( & mut self ) -> OUT27_W { OUT27_W { w : self } } # [ doc = "Bits 18:23 - for OUT28" ]
# [ inline ( always ) ]
pub fn out28 ( & mut self ) -> OUT28_W { OUT28_W { w : self } } # [ doc = "Bits 24:29 - for OUT29" ]
# [ inline ( always ) ]
pub fn out29 ( & mut self ) -> OUT29_W { OUT29_W { w : self } } } } # [ doc = "Mux select for MIO outputs.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mio_outsel6](mio_outsel6) module" ]
pub type MIO_OUTSEL6 = crate :: Reg < u32 , _MIO_OUTSEL6 > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _MIO_OUTSEL6 ; # [ doc = "`read()` method returns [mio_outsel6::R](mio_outsel6::R) reader structure" ]
impl crate :: Readable for MIO_OUTSEL6 { } # [ doc = "`write(|w| ..)` method takes [mio_outsel6::W](mio_outsel6::W) writer structure" ]
impl crate :: Writable for MIO_OUTSEL6 { } # [ doc = "Mux select for MIO outputs." ]
pub mod mio_outsel6 { # [ doc = "Reader of register MIO_OUTSEL6" ]
pub type R = crate :: R < u32 , super :: MIO_OUTSEL6 > ; # [ doc = "Writer for register MIO_OUTSEL6" ]
pub type W = crate :: W < u32 , super :: MIO_OUTSEL6 > ; # [ doc = "Register MIO_OUTSEL6 `reset()`'s with value 0x82" ]
impl crate :: ResetValue for super :: MIO_OUTSEL6 { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x82 } } # [ doc = "Reader of field `OUT30`" ]
pub type OUT30_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT30`" ]
pub struct OUT30_W < 'a > { w : & 'a mut W , } impl < 'a > OUT30_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `OUT31`" ]
pub type OUT31_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `OUT31`" ]
pub struct OUT31_W < 'a > { w : & 'a mut W , } impl < 'a > OUT31_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT30" ]
# [ inline ( always ) ]
pub fn out30 ( & self ) -> OUT30_R { OUT30_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - for OUT31" ]
# [ inline ( always ) ]
pub fn out31 ( & self ) -> OUT31_R { OUT31_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - 0: tie constantly to zero, 1: tie constantly to 1. 2: high-Z >=3: peripheral outputs (i.e., add 3 to the native peripheral pad index). for OUT30" ]
# [ inline ( always ) ]
pub fn out30 ( & mut self ) -> OUT30_W { OUT30_W { w : self } } # [ doc = "Bits 6:11 - for OUT31" ]
# [ inline ( always ) ]
pub fn out31 ( & mut self ) -> OUT31_W { OUT31_W { w : self } } } } } # [ doc = "Register write enable for all control registers.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [regen](regen) module" ]
pub type REGEN = crate :: Reg < u32 , _REGEN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _REGEN ; # [ doc = "`read()` method returns [regen::R](regen::R) reader structure" ]
impl crate :: Readable for REGEN { } # [ doc = "`write(|w| ..)` method takes [regen::W](regen::W) writer structure" ]
impl crate :: Writable for REGEN { } # [ doc = "Register write enable for all control registers." ]
pub mod regen { # [ doc = "Reader of register REGEN" ]
pub type R = crate :: R < u32 , super :: REGEN > ; # [ doc = "Writer for register REGEN" ]
pub type W = crate :: W < u32 , super :: REGEN > ; # [ doc = "Register REGEN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: REGEN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } # [ doc = "Reader of field `wen`" ]
pub type WEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `wen`" ]
pub struct WEN_W < 'a > { w : & 'a mut W , } impl < 'a > WEN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - When true, all configuration registers can be modified. When false, they become read-only. Defaults true, write zero to clear." ]
# [ inline ( always ) ]
pub fn wen ( & self ) -> WEN_R { WEN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - When true, all configuration registers can be modified. When false, they become read-only. Defaults true, write zero to clear." ]
# [ inline ( always ) ]
pub fn wen ( & mut self ) -> WEN_W { WEN_W { w : self } } } } } # [ doc = "alert_handler" ]
pub struct ALERT_HANDLER { _marker : PhantomData < * const ( ) > } unsafe impl Send for ALERT_HANDLER { } impl ALERT_HANDLER { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const alert_handler :: RegisterBlock { 0x4013_0000 as * const _ } } impl Deref for ALERT_HANDLER { type Target = alert_handler :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * ALERT_HANDLER :: ptr ( ) } } } # [ doc = "alert_handler" ]
pub mod alert_handler { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , # [ doc = "0x0c - Register write enable for all control registers." ]
pub regen : REGEN , _reserved4 : [ u8 ; 4usize ]
, # [ doc = "0x10 - Ping timeout cycle count." ]
pub ping_timeout_cyc : PING_TIMEOUT_CYC , _reserved5 : [ u8 ; 1usize ]
, # [ doc = "0x14 - Enable register for alerts." ]
pub alert_en : ALERT_EN , # [ doc = "0x18 - Class assignment of alerts." ]
pub alert_class : ALERT_CLASS , # [ doc = "0x1c - Alert Cause Register" ]
pub alert_cause : ALERT_CAUSE , # [ doc = "0x20 - Enable register for the aggregated local alerts \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub loc_alert_en : LOC_ALERT_EN , # [ doc = "0x24 - Class assignment of local alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub loc_alert_class : LOC_ALERT_CLASS , # [ doc = "0x28 - Alert Cause Register for Local Alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub loc_alert_cause : LOC_ALERT_CAUSE , # [ doc = "0x2c - Escalation control register for alert Class A. Can not be modified if !!REGEN is false." ]
pub classa_ctrl : CLASSA_CTRL , # [ doc = "0x30 - Clear enable for escalation protocol of Class A alerts." ]
pub classa_clren : CLASSA_CLREN , _reserved13 : [ u8 ; 4usize ]
, # [ doc = "0x34 - Clear for esclation protocol of Class A." ]
pub classa_clr : CLASSA_CLR , _reserved14 : [ u8 ; 4usize ]
, # [ doc = "0x38 - Current accumulation value for alert Class A. Software can clear this register with a write to !!CLASSA_CLR register unless !!CLASSA_CLREN is false." ]
pub classa_accum_cnt : CLASSA_ACCUM_CNT , _reserved15 : [ u8 ; 2usize ]
, # [ doc = "0x3c - Accumulation threshold value for alert Class A." ]
pub classa_accum_thresh : CLASSA_ACCUM_THRESH , _reserved16 : [ u8 ; 2usize ]
, # [ doc = "0x40 - Interrupt timeout in cycles." ]
pub classa_timeout_cyc : CLASSA_TIMEOUT_CYC , # [ doc = "0x44 - Duration of escalation phase 0 for Class A." ]
pub classa_phase0_cyc : CLASSA_PHASE0_CYC , # [ doc = "0x48 - Duration of escalation phase 1 for Class A." ]
pub classa_phase1_cyc : CLASSA_PHASE1_CYC , # [ doc = "0x4c - Duration of escalation phase 2 for Class A." ]
pub classa_phase2_cyc : CLASSA_PHASE2_CYC , # [ doc = "0x50 - Duration of escalation phase 3 for Class A." ]
pub classa_phase3_cyc : CLASSA_PHASE3_CYC , # [ doc = "0x54 - Escalation counter in cycles for Class A." ]
pub classa_esc_cnt : CLASSA_ESC_CNT , # [ doc = "0x58 - Current escalation state of Class A. See also !!CLASSA_ESC_CNT." ]
pub classa_state : CLASSA_STATE , _reserved23 : [ u8 ; 4usize ]
, # [ doc = "0x5c - Escalation control register for alert Class B. Can not be modified if !!REGEN is false." ]
pub classb_ctrl : CLASSB_CTRL , # [ doc = "0x60 - Clear enable for escalation protocol of Class B alerts." ]
pub classb_clren : CLASSB_CLREN , _reserved25 : [ u8 ; 4usize ]
, # [ doc = "0x64 - Clear for esclation protocol of Class B." ]
pub classb_clr : CLASSB_CLR , _reserved26 : [ u8 ; 4usize ]
, # [ doc = "0x68 - Current accumulation value for alert Class B. Software can clear this register with a write to !!CLASSB_CLR register unless !!CLASSB_CLREN is false." ]
pub classb_accum_cnt : CLASSB_ACCUM_CNT , _reserved27 : [ u8 ; 2usize ]
, # [ doc = "0x6c - Accumulation threshold value for alert Class B." ]
pub classb_accum_thresh : CLASSB_ACCUM_THRESH , _reserved28 : [ u8 ; 2usize ]
, # [ doc = "0x70 - Interrupt timeout in cycles." ]
pub classb_timeout_cyc : CLASSB_TIMEOUT_CYC , # [ doc = "0x74 - Duration of escalation phase 0 for Class B." ]
pub classb_phase0_cyc : CLASSB_PHASE0_CYC , # [ doc = "0x78 - Duration of escalation phase 1 for Class B." ]
pub classb_phase1_cyc : CLASSB_PHASE1_CYC , # [ doc = "0x7c - Duration of escalation phase 2 for Class B." ]
pub classb_phase2_cyc : CLASSB_PHASE2_CYC , # [ doc = "0x80 - Duration of escalation phase 3 for Class B." ]
pub classb_phase3_cyc : CLASSB_PHASE3_CYC , # [ doc = "0x84 - Escalation counter in cycles for Class B." ]
pub classb_esc_cnt : CLASSB_ESC_CNT , # [ doc = "0x88 - Current escalation state of Class B. See also !!CLASSB_ESC_CNT." ]
pub classb_state : CLASSB_STATE , _reserved35 : [ u8 ; 4usize ]
, # [ doc = "0x8c - Escalation control register for alert Class C. Can not be modified if !!REGEN is false." ]
pub classc_ctrl : CLASSC_CTRL , # [ doc = "0x90 - Clear enable for escalation protocol of Class C alerts." ]
pub classc_clren : CLASSC_CLREN , _reserved37 : [ u8 ; 4usize ]
, # [ doc = "0x94 - Clear for esclation protocol of Class C." ]
pub classc_clr : CLASSC_CLR , _reserved38 : [ u8 ; 4usize ]
, # [ doc = "0x98 - Current accumulation value for alert Class C. Software can clear this register with a write to !!CLASSC_CLR register unless !!CLASSC_CLREN is false." ]
pub classc_accum_cnt : CLASSC_ACCUM_CNT , _reserved39 : [ u8 ; 2usize ]
, # [ doc = "0x9c - Accumulation threshold value for alert Class C." ]
pub classc_accum_thresh : CLASSC_ACCUM_THRESH , _reserved40 : [ u8 ; 2usize ]
, # [ doc = "0xa0 - Interrupt timeout in cycles." ]
pub classc_timeout_cyc : CLASSC_TIMEOUT_CYC , # [ doc = "0xa4 - Duration of escalation phase 0 for Class C." ]
pub classc_phase0_cyc : CLASSC_PHASE0_CYC , # [ doc = "0xa8 - Duration of escalation phase 1 for Class C." ]
pub classc_phase1_cyc : CLASSC_PHASE1_CYC , # [ doc = "0xac - Duration of escalation phase 2 for Class C." ]
pub classc_phase2_cyc : CLASSC_PHASE2_CYC , # [ doc = "0xb0 - Duration of escalation phase 3 for Class C." ]
pub classc_phase3_cyc : CLASSC_PHASE3_CYC , # [ doc = "0xb4 - Escalation counter in cycles for Class C." ]
pub classc_esc_cnt : CLASSC_ESC_CNT , # [ doc = "0xb8 - Current escalation state of Class C. See also !!CLASSC_ESC_CNT." ]
pub classc_state : CLASSC_STATE , _reserved47 : [ u8 ; 4usize ]
, # [ doc = "0xbc - Escalation control register for alert Class D. Can not be modified if !!REGEN is false." ]
pub classd_ctrl : CLASSD_CTRL , # [ doc = "0xc0 - Clear enable for escalation protocol of Class D alerts." ]
pub classd_clren : CLASSD_CLREN , _reserved49 : [ u8 ; 4usize ]
, # [ doc = "0xc4 - Clear for esclation protocol of Class D." ]
pub classd_clr : CLASSD_CLR , _reserved50 : [ u8 ; 4usize ]
, # [ doc = "0xc8 - Current accumulation value for alert Class D. Software can clear this register with a write to !!CLASSD_CLR register unless !!CLASSD_CLREN is false." ]
pub classd_accum_cnt : CLASSD_ACCUM_CNT , _reserved51 : [ u8 ; 2usize ]
, # [ doc = "0xcc - Accumulation threshold value for alert Class D." ]
pub classd_accum_thresh : CLASSD_ACCUM_THRESH , _reserved52 : [ u8 ; 2usize ]
, # [ doc = "0xd0 - Interrupt timeout in cycles." ]
pub classd_timeout_cyc : CLASSD_TIMEOUT_CYC , # [ doc = "0xd4 - Duration of escalation phase 0 for Class D." ]
pub classd_phase0_cyc : CLASSD_PHASE0_CYC , # [ doc = "0xd8 - Duration of escalation phase 1 for Class D." ]
pub classd_phase1_cyc : CLASSD_PHASE1_CYC , # [ doc = "0xdc - Duration of escalation phase 2 for Class D." ]
pub classd_phase2_cyc : CLASSD_PHASE2_CYC , # [ doc = "0xe0 - Duration of escalation phase 3 for Class D." ]
pub classd_phase3_cyc : CLASSD_PHASE3_CYC , # [ doc = "0xe4 - Escalation counter in cycles for Class D." ]
pub classd_esc_cnt : CLASSD_ESC_CNT , # [ doc = "0xe8 - Current escalation state of Class D. See also !!CLASSD_ESC_CNT." ]
pub classd_state : CLASSD_STATE , } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `classa`" ]
pub type CLASSA_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classa`" ]
pub struct CLASSA_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSA_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `classb`" ]
pub type CLASSB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classb`" ]
pub struct CLASSB_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSB_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `classc`" ]
pub type CLASSC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classc`" ]
pub struct CLASSC_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSC_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `classd`" ]
pub type CLASSD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classd`" ]
pub struct CLASSD_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSD_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Interrupt state bit of Class A. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classa ( & self ) -> CLASSA_R { CLASSA_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Interrupt state bit of Class B. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classb ( & self ) -> CLASSB_R { CLASSB_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Interrupt state bit of Class C. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classc ( & self ) -> CLASSC_R { CLASSC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Interrupt state bit of Class D. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classd ( & self ) -> CLASSD_R { CLASSD_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Interrupt state bit of Class A. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classa ( & mut self ) -> CLASSA_W { CLASSA_W { w : self } } # [ doc = "Bit 1 - Interrupt state bit of Class B. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classb ( & mut self ) -> CLASSB_W { CLASSB_W { w : self } } # [ doc = "Bit 2 - Interrupt state bit of Class C. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classc ( & mut self ) -> CLASSC_W { CLASSC_W { w : self } } # [ doc = "Bit 3 - Interrupt state bit of Class D. Set by HW in case an alert within this class triggered. Defaults true, write one to clear." ]
# [ inline ( always ) ]
pub fn classd ( & mut self ) -> CLASSD_W { CLASSD_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `classa`" ]
pub type CLASSA_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classa`" ]
pub struct CLASSA_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSA_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `classb`" ]
pub type CLASSB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classb`" ]
pub struct CLASSB_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSB_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `classc`" ]
pub type CLASSC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classc`" ]
pub struct CLASSC_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSC_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `classd`" ]
pub type CLASSD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `classd`" ]
pub struct CLASSD_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSD_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.classa is set" ]
# [ inline ( always ) ]
pub fn classa ( & self ) -> CLASSA_R { CLASSA_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.classb is set" ]
# [ inline ( always ) ]
pub fn classb ( & self ) -> CLASSB_R { CLASSB_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.classc is set" ]
# [ inline ( always ) ]
pub fn classc ( & self ) -> CLASSC_R { CLASSC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.classd is set" ]
# [ inline ( always ) ]
pub fn classd ( & self ) -> CLASSD_R { CLASSD_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.classa is set" ]
# [ inline ( always ) ]
pub fn classa ( & mut self ) -> CLASSA_W { CLASSA_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.classb is set" ]
# [ inline ( always ) ]
pub fn classb ( & mut self ) -> CLASSB_W { CLASSB_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.classc is set" ]
# [ inline ( always ) ]
pub fn classc ( & mut self ) -> CLASSC_W { CLASSC_W { w : self } } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.classd is set" ]
# [ inline ( always ) ]
pub fn classd ( & mut self ) -> CLASSD_W { CLASSD_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `classa`" ]
pub struct CLASSA_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSA_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `classb`" ]
pub struct CLASSB_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSB_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `classc`" ]
pub struct CLASSC_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSC_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `classd`" ]
pub struct CLASSD_W < 'a > { w : & 'a mut W , } impl < 'a > CLASSD_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.classa to 1" ]
# [ inline ( always ) ]
pub fn classa ( & mut self ) -> CLASSA_W { CLASSA_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.classb to 1" ]
# [ inline ( always ) ]
pub fn classb ( & mut self ) -> CLASSB_W { CLASSB_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.classc to 1" ]
# [ inline ( always ) ]
pub fn classc ( & mut self ) -> CLASSC_W { CLASSC_W { w : self } } # [ doc = "Bit 3 - Write 1 to force !!INTR_STATE.classd to 1" ]
# [ inline ( always ) ]
pub fn classd ( & mut self ) -> CLASSD_W { CLASSD_W { w : self } } } } # [ doc = "Register write enable for all control registers.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [regen](regen) module" ]
pub type REGEN = crate :: Reg < u8 , _REGEN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _REGEN ; # [ doc = "`read()` method returns [regen::R](regen::R) reader structure" ]
impl crate :: Readable for REGEN { } # [ doc = "`write(|w| ..)` method takes [regen::W](regen::W) writer structure" ]
impl crate :: Writable for REGEN { } # [ doc = "Register write enable for all control registers." ]
pub mod regen { # [ doc = "Reader of register REGEN" ]
pub type R = crate :: R < u8 , super :: REGEN > ; # [ doc = "Writer for register REGEN" ]
pub type W = crate :: W < u8 , super :: REGEN > ; # [ doc = "Register REGEN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: REGEN { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } impl R { } impl W { } } # [ doc = "Ping timeout cycle count.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ping_timeout_cyc](ping_timeout_cyc) module" ]
pub type PING_TIMEOUT_CYC = crate :: Reg < u32 , _PING_TIMEOUT_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PING_TIMEOUT_CYC ; # [ doc = "`read()` method returns [ping_timeout_cyc::R](ping_timeout_cyc::R) reader structure" ]
impl crate :: Readable for PING_TIMEOUT_CYC { } # [ doc = "`write(|w| ..)` method takes [ping_timeout_cyc::W](ping_timeout_cyc::W) writer structure" ]
impl crate :: Writable for PING_TIMEOUT_CYC { } # [ doc = "Ping timeout cycle count." ]
pub mod ping_timeout_cyc { # [ doc = "Reader of register PING_TIMEOUT_CYC" ]
pub type R = crate :: R < u32 , super :: PING_TIMEOUT_CYC > ; # [ doc = "Writer for register PING_TIMEOUT_CYC" ]
pub type W = crate :: W < u32 , super :: PING_TIMEOUT_CYC > ; # [ doc = "Register PING_TIMEOUT_CYC `reset()`'s with value 0x20" ]
impl crate :: ResetValue for super :: PING_TIMEOUT_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x20 } } impl R { } impl W { } } # [ doc = "Enable register for alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alert_en](alert_en) module" ]
pub type ALERT_EN = crate :: Reg < u32 , _ALERT_EN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ALERT_EN ; # [ doc = "`read()` method returns [alert_en::R](alert_en::R) reader structure" ]
impl crate :: Readable for ALERT_EN { } # [ doc = "`write(|w| ..)` method takes [alert_en::W](alert_en::W) writer structure" ]
impl crate :: Writable for ALERT_EN { } # [ doc = "Enable register for alerts." ]
pub mod alert_en { # [ doc = "Reader of register ALERT_EN" ]
pub type R = crate :: R < u32 , super :: ALERT_EN > ; # [ doc = "Writer for register ALERT_EN" ]
pub type W = crate :: W < u32 , super :: ALERT_EN > ; # [ doc = "Register ALERT_EN `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: ALERT_EN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN_A0`" ]
pub type EN_A0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_A0`" ]
pub struct EN_A0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_A0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `EN_A1`" ]
pub type EN_A1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_A1`" ]
pub struct EN_A1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_A1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_A2`" ]
pub type EN_A2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_A2`" ]
pub struct EN_A2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_A2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_A3`" ]
pub type EN_A3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_A3`" ]
pub struct EN_A3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_A3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Alert enable for alert0" ]
# [ inline ( always ) ]
pub fn en_a0 ( & self ) -> EN_A0_R { EN_A0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for alert1" ]
# [ inline ( always ) ]
pub fn en_a1 ( & self ) -> EN_A1_R { EN_A1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for alert2" ]
# [ inline ( always ) ]
pub fn en_a2 ( & self ) -> EN_A2_R { EN_A2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for alert3" ]
# [ inline ( always ) ]
pub fn en_a3 ( & self ) -> EN_A3_R { EN_A3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Alert enable for alert0" ]
# [ inline ( always ) ]
pub fn en_a0 ( & mut self ) -> EN_A0_W { EN_A0_W { w : self } } # [ doc = "Bit 1 - for alert1" ]
# [ inline ( always ) ]
pub fn en_a1 ( & mut self ) -> EN_A1_W { EN_A1_W { w : self } } # [ doc = "Bit 2 - for alert2" ]
# [ inline ( always ) ]
pub fn en_a2 ( & mut self ) -> EN_A2_W { EN_A2_W { w : self } } # [ doc = "Bit 3 - for alert3" ]
# [ inline ( always ) ]
pub fn en_a3 ( & mut self ) -> EN_A3_W { EN_A3_W { w : self } } } } # [ doc = "Class assignment of alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alert_class](alert_class) module" ]
pub type ALERT_CLASS = crate :: Reg < u32 , _ALERT_CLASS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ALERT_CLASS ; # [ doc = "`read()` method returns [alert_class::R](alert_class::R) reader structure" ]
impl crate :: Readable for ALERT_CLASS { } # [ doc = "`write(|w| ..)` method takes [alert_class::W](alert_class::W) writer structure" ]
impl crate :: Writable for ALERT_CLASS { } # [ doc = "Class assignment of alerts." ]
pub mod alert_class { # [ doc = "Reader of register ALERT_CLASS" ]
pub type R = crate :: R < u32 , super :: ALERT_CLASS > ; # [ doc = "Writer for register ALERT_CLASS" ]
pub type W = crate :: W < u32 , super :: ALERT_CLASS > ; # [ doc = "Register ALERT_CLASS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: ALERT_CLASS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CLASS_A0`" ]
pub type CLASS_A0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_A0`" ]
pub struct CLASS_A0_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_A0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } # [ doc = "Reader of field `CLASS_A1`" ]
pub type CLASS_A1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_A1`" ]
pub struct CLASS_A1_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_A1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Reader of field `CLASS_A2`" ]
pub type CLASS_A2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_A2`" ]
pub struct CLASS_A2_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_A2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `CLASS_A3`" ]
pub type CLASS_A3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_A3`" ]
pub struct CLASS_A3_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_A3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } impl R { # [ doc = "Bits 0:1 - Classification for alert0" ]
# [ inline ( always ) ]
pub fn class_a0 ( & self ) -> CLASS_A0_R { CLASS_A0_R :: new ( ( self . bits & 0x03 ) as u8 ) } # [ doc = "Bits 2:3 - for alert1" ]
# [ inline ( always ) ]
pub fn class_a1 ( & self ) -> CLASS_A1_R { CLASS_A1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 4:5 - for alert2" ]
# [ inline ( always ) ]
pub fn class_a2 ( & self ) -> CLASS_A2_R { CLASS_A2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bits 6:7 - for alert3" ]
# [ inline ( always ) ]
pub fn class_a3 ( & self ) -> CLASS_A3_R { CLASS_A3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1 - Classification for alert0" ]
# [ inline ( always ) ]
pub fn class_a0 ( & mut self ) -> CLASS_A0_W { CLASS_A0_W { w : self } } # [ doc = "Bits 2:3 - for alert1" ]
# [ inline ( always ) ]
pub fn class_a1 ( & mut self ) -> CLASS_A1_W { CLASS_A1_W { w : self } } # [ doc = "Bits 4:5 - for alert2" ]
# [ inline ( always ) ]
pub fn class_a2 ( & mut self ) -> CLASS_A2_W { CLASS_A2_W { w : self } } # [ doc = "Bits 6:7 - for alert3" ]
# [ inline ( always ) ]
pub fn class_a3 ( & mut self ) -> CLASS_A3_W { CLASS_A3_W { w : self } } } } # [ doc = "Alert Cause Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alert_cause](alert_cause) module" ]
pub type ALERT_CAUSE = crate :: Reg < u32 , _ALERT_CAUSE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _ALERT_CAUSE ; # [ doc = "`read()` method returns [alert_cause::R](alert_cause::R) reader structure" ]
impl crate :: Readable for ALERT_CAUSE { } # [ doc = "`write(|w| ..)` method takes [alert_cause::W](alert_cause::W) writer structure" ]
impl crate :: Writable for ALERT_CAUSE { } # [ doc = "Alert Cause Register" ]
pub mod alert_cause { # [ doc = "Reader of register ALERT_CAUSE" ]
pub type R = crate :: R < u32 , super :: ALERT_CAUSE > ; # [ doc = "Writer for register ALERT_CAUSE" ]
pub type W = crate :: W < u32 , super :: ALERT_CAUSE > ; # [ doc = "Register ALERT_CAUSE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: ALERT_CAUSE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `A0`" ]
pub type A0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `A0`" ]
pub struct A0_W < 'a > { w : & 'a mut W , } impl < 'a > A0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `A1`" ]
pub type A1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `A1`" ]
pub struct A1_W < 'a > { w : & 'a mut W , } impl < 'a > A1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `A2`" ]
pub type A2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `A2`" ]
pub struct A2_W < 'a > { w : & 'a mut W , } impl < 'a > A2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `A3`" ]
pub type A3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `A3`" ]
pub struct A3_W < 'a > { w : & 'a mut W , } impl < 'a > A3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Cause bit for ALERT0" ]
# [ inline ( always ) ]
pub fn a0 ( & self ) -> A0_R { A0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for ALERT1" ]
# [ inline ( always ) ]
pub fn a1 ( & self ) -> A1_R { A1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for ALERT2" ]
# [ inline ( always ) ]
pub fn a2 ( & self ) -> A2_R { A2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for ALERT3" ]
# [ inline ( always ) ]
pub fn a3 ( & self ) -> A3_R { A3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Cause bit for ALERT0" ]
# [ inline ( always ) ]
pub fn a0 ( & mut self ) -> A0_W { A0_W { w : self } } # [ doc = "Bit 1 - for ALERT1" ]
# [ inline ( always ) ]
pub fn a1 ( & mut self ) -> A1_W { A1_W { w : self } } # [ doc = "Bit 2 - for ALERT2" ]
# [ inline ( always ) ]
pub fn a2 ( & mut self ) -> A2_W { A2_W { w : self } } # [ doc = "Bit 3 - for ALERT3" ]
# [ inline ( always ) ]
pub fn a3 ( & mut self ) -> A3_W { A3_W { w : self } } } } # [ doc = "Enable register for the aggregated local alerts \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3).\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [loc_alert_en](loc_alert_en) module" ]
pub type LOC_ALERT_EN = crate :: Reg < u32 , _LOC_ALERT_EN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LOC_ALERT_EN ; # [ doc = "`read()` method returns [loc_alert_en::R](loc_alert_en::R) reader structure" ]
impl crate :: Readable for LOC_ALERT_EN { } # [ doc = "`write(|w| ..)` method takes [loc_alert_en::W](loc_alert_en::W) writer structure" ]
impl crate :: Writable for LOC_ALERT_EN { } # [ doc = "Enable register for the aggregated local alerts \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub mod loc_alert_en { # [ doc = "Reader of register LOC_ALERT_EN" ]
pub type R = crate :: R < u32 , super :: LOC_ALERT_EN > ; # [ doc = "Writer for register LOC_ALERT_EN" ]
pub type W = crate :: W < u32 , super :: LOC_ALERT_EN > ; # [ doc = "Register LOC_ALERT_EN `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LOC_ALERT_EN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `EN_LA0`" ]
pub type EN_LA0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_LA0`" ]
pub struct EN_LA0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_LA0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `EN_LA1`" ]
pub type EN_LA1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_LA1`" ]
pub struct EN_LA1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_LA1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_LA2`" ]
pub type EN_LA2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_LA2`" ]
pub struct EN_LA2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_LA2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_LA3`" ]
pub type EN_LA3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_LA3`" ]
pub struct EN_LA3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_LA3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Alert enable for local alert0" ]
# [ inline ( always ) ]
pub fn en_la0 ( & self ) -> EN_LA0_R { EN_LA0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for local alert1" ]
# [ inline ( always ) ]
pub fn en_la1 ( & self ) -> EN_LA1_R { EN_LA1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for local alert2" ]
# [ inline ( always ) ]
pub fn en_la2 ( & self ) -> EN_LA2_R { EN_LA2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for local alert3" ]
# [ inline ( always ) ]
pub fn en_la3 ( & self ) -> EN_LA3_R { EN_LA3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Alert enable for local alert0" ]
# [ inline ( always ) ]
pub fn en_la0 ( & mut self ) -> EN_LA0_W { EN_LA0_W { w : self } } # [ doc = "Bit 1 - for local alert1" ]
# [ inline ( always ) ]
pub fn en_la1 ( & mut self ) -> EN_LA1_W { EN_LA1_W { w : self } } # [ doc = "Bit 2 - for local alert2" ]
# [ inline ( always ) ]
pub fn en_la2 ( & mut self ) -> EN_LA2_W { EN_LA2_W { w : self } } # [ doc = "Bit 3 - for local alert3" ]
# [ inline ( always ) ]
pub fn en_la3 ( & mut self ) -> EN_LA3_W { EN_LA3_W { w : self } } } } # [ doc = "Class assignment of local alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3).\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [loc_alert_class](loc_alert_class) module" ]
pub type LOC_ALERT_CLASS = crate :: Reg < u32 , _LOC_ALERT_CLASS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LOC_ALERT_CLASS ; # [ doc = "`read()` method returns [loc_alert_class::R](loc_alert_class::R) reader structure" ]
impl crate :: Readable for LOC_ALERT_CLASS { } # [ doc = "`write(|w| ..)` method takes [loc_alert_class::W](loc_alert_class::W) writer structure" ]
impl crate :: Writable for LOC_ALERT_CLASS { } # [ doc = "Class assignment of local alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub mod loc_alert_class { # [ doc = "Reader of register LOC_ALERT_CLASS" ]
pub type R = crate :: R < u32 , super :: LOC_ALERT_CLASS > ; # [ doc = "Writer for register LOC_ALERT_CLASS" ]
pub type W = crate :: W < u32 , super :: LOC_ALERT_CLASS > ; # [ doc = "Register LOC_ALERT_CLASS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LOC_ALERT_CLASS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CLASS_LA0`" ]
pub type CLASS_LA0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_LA0`" ]
pub struct CLASS_LA0_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_LA0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } # [ doc = "Reader of field `CLASS_LA1`" ]
pub type CLASS_LA1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_LA1`" ]
pub struct CLASS_LA1_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_LA1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Reader of field `CLASS_LA2`" ]
pub type CLASS_LA2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_LA2`" ]
pub struct CLASS_LA2_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_LA2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `CLASS_LA3`" ]
pub type CLASS_LA3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CLASS_LA3`" ]
pub struct CLASS_LA3_W < 'a > { w : & 'a mut W , } impl < 'a > CLASS_LA3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } impl R { # [ doc = "Bits 0:1 - Classification for local alert0" ]
# [ inline ( always ) ]
pub fn class_la0 ( & self ) -> CLASS_LA0_R { CLASS_LA0_R :: new ( ( self . bits & 0x03 ) as u8 ) } # [ doc = "Bits 2:3 - for local alert1" ]
# [ inline ( always ) ]
pub fn class_la1 ( & self ) -> CLASS_LA1_R { CLASS_LA1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 4:5 - for local alert2" ]
# [ inline ( always ) ]
pub fn class_la2 ( & self ) -> CLASS_LA2_R { CLASS_LA2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bits 6:7 - for local alert3" ]
# [ inline ( always ) ]
pub fn class_la3 ( & self ) -> CLASS_LA3_R { CLASS_LA3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1 - Classification for local alert0" ]
# [ inline ( always ) ]
pub fn class_la0 ( & mut self ) -> CLASS_LA0_W { CLASS_LA0_W { w : self } } # [ doc = "Bits 2:3 - for local alert1" ]
# [ inline ( always ) ]
pub fn class_la1 ( & mut self ) -> CLASS_LA1_W { CLASS_LA1_W { w : self } } # [ doc = "Bits 4:5 - for local alert2" ]
# [ inline ( always ) ]
pub fn class_la2 ( & mut self ) -> CLASS_LA2_W { CLASS_LA2_W { w : self } } # [ doc = "Bits 6:7 - for local alert3" ]
# [ inline ( always ) ]
pub fn class_la3 ( & mut self ) -> CLASS_LA3_W { CLASS_LA3_W { w : self } } } } # [ doc = "Alert Cause Register for Local Alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3).\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [loc_alert_cause](loc_alert_cause) module" ]
pub type LOC_ALERT_CAUSE = crate :: Reg < u32 , _LOC_ALERT_CAUSE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LOC_ALERT_CAUSE ; # [ doc = "`read()` method returns [loc_alert_cause::R](loc_alert_cause::R) reader structure" ]
impl crate :: Readable for LOC_ALERT_CAUSE { } # [ doc = "`write(|w| ..)` method takes [loc_alert_cause::W](loc_alert_cause::W) writer structure" ]
impl crate :: Writable for LOC_ALERT_CAUSE { } # [ doc = "Alert Cause Register for Local Alerts. \"alert pingfail\" (0), \"escalation pingfail\" (1), \"alert integfail\" (2) and \"escalation integfail\" (3)." ]
pub mod loc_alert_cause { # [ doc = "Reader of register LOC_ALERT_CAUSE" ]
pub type R = crate :: R < u32 , super :: LOC_ALERT_CAUSE > ; # [ doc = "Writer for register LOC_ALERT_CAUSE" ]
pub type W = crate :: W < u32 , super :: LOC_ALERT_CAUSE > ; # [ doc = "Register LOC_ALERT_CAUSE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LOC_ALERT_CAUSE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `LA0`" ]
pub type LA0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LA0`" ]
pub struct LA0_W < 'a > { w : & 'a mut W , } impl < 'a > LA0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LA1`" ]
pub type LA1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LA1`" ]
pub struct LA1_W < 'a > { w : & 'a mut W , } impl < 'a > LA1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `LA2`" ]
pub type LA2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LA2`" ]
pub struct LA2_W < 'a > { w : & 'a mut W , } impl < 'a > LA2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `LA3`" ]
pub type LA3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LA3`" ]
pub struct LA3_W < 'a > { w : & 'a mut W , } impl < 'a > LA3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Cause bit for LOC_ALERT0" ]
# [ inline ( always ) ]
pub fn la0 ( & self ) -> LA0_R { LA0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - for LOC_ALERT1" ]
# [ inline ( always ) ]
pub fn la1 ( & self ) -> LA1_R { LA1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - for LOC_ALERT2" ]
# [ inline ( always ) ]
pub fn la2 ( & self ) -> LA2_R { LA2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - for LOC_ALERT3" ]
# [ inline ( always ) ]
pub fn la3 ( & self ) -> LA3_R { LA3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Cause bit for LOC_ALERT0" ]
# [ inline ( always ) ]
pub fn la0 ( & mut self ) -> LA0_W { LA0_W { w : self } } # [ doc = "Bit 1 - for LOC_ALERT1" ]
# [ inline ( always ) ]
pub fn la1 ( & mut self ) -> LA1_W { LA1_W { w : self } } # [ doc = "Bit 2 - for LOC_ALERT2" ]
# [ inline ( always ) ]
pub fn la2 ( & mut self ) -> LA2_W { LA2_W { w : self } } # [ doc = "Bit 3 - for LOC_ALERT3" ]
# [ inline ( always ) ]
pub fn la3 ( & mut self ) -> LA3_W { LA3_W { w : self } } } } # [ doc = "Escalation control register for alert Class A. Can not be modified if !!REGEN is false.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_ctrl](classa_ctrl) module" ]
pub type CLASSA_CTRL = crate :: Reg < u32 , _CLASSA_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_CTRL ; # [ doc = "`read()` method returns [classa_ctrl::R](classa_ctrl::R) reader structure" ]
impl crate :: Readable for CLASSA_CTRL { } # [ doc = "`write(|w| ..)` method takes [classa_ctrl::W](classa_ctrl::W) writer structure" ]
impl crate :: Writable for CLASSA_CTRL { } # [ doc = "Escalation control register for alert Class A. Can not be modified if !!REGEN is false." ]
pub mod classa_ctrl { # [ doc = "Reader of register CLASSA_CTRL" ]
pub type R = crate :: R < u32 , super :: CLASSA_CTRL > ; # [ doc = "Writer for register CLASSA_CTRL" ]
pub type W = crate :: W < u32 , super :: CLASSA_CTRL > ; # [ doc = "Register CLASSA_CTRL `reset()`'s with value 0x393c" ]
impl crate :: ResetValue for super :: CLASSA_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x393c } } # [ doc = "Reader of field `EN`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LOCK`" ]
pub type LOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOCK`" ]
pub struct LOCK_W < 'a > { w : & 'a mut W , } impl < 'a > LOCK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_E0`" ]
pub type EN_E0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E0`" ]
pub struct EN_E0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_E1`" ]
pub type EN_E1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E1`" ]
pub struct EN_E1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `EN_E2`" ]
pub type EN_E2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E2`" ]
pub struct EN_E2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `EN_E3`" ]
pub type EN_E3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E3`" ]
pub struct EN_E3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `MAP_E0`" ]
pub type MAP_E0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E0`" ]
pub struct MAP_E0_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } # [ doc = "Reader of field `MAP_E1`" ]
pub type MAP_E1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E1`" ]
pub struct MAP_E1_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MAP_E2`" ]
pub type MAP_E2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E2`" ]
pub struct MAP_E2_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } # [ doc = "Reader of field `MAP_E3`" ]
pub type MAP_E3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E3`" ]
pub struct MAP_E3_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u32 ) & 0x03 ) << 12 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class A. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class A. If true, there is no way to stop the escalation protocol for class A once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable escalation signal 0 for Class A" ]
# [ inline ( always ) ]
pub fn en_e0 ( & self ) -> EN_E0_R { EN_E0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable escalation signal 1 for Class A" ]
# [ inline ( always ) ]
pub fn en_e1 ( & self ) -> EN_E1_R { EN_E1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable escalation signal 2 for Class A" ]
# [ inline ( always ) ]
pub fn en_e2 ( & self ) -> EN_E2_R { EN_E2_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable escalation signal 3 for Class A" ]
# [ inline ( always ) ]
pub fn en_e3 ( & self ) -> EN_E3_R { EN_E3_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & self ) -> MAP_E0_R { MAP_E0_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & self ) -> MAP_E1_R { MAP_E1_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & self ) -> MAP_E2_R { MAP_E2_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & self ) -> MAP_E3_R { MAP_E3_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class A. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class A. If true, there is no way to stop the escalation protocol for class A once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & mut self ) -> LOCK_W { LOCK_W { w : self } } # [ doc = "Bit 2 - Enable escalation signal 0 for Class A" ]
# [ inline ( always ) ]
pub fn en_e0 ( & mut self ) -> EN_E0_W { EN_E0_W { w : self } } # [ doc = "Bit 3 - Enable escalation signal 1 for Class A" ]
# [ inline ( always ) ]
pub fn en_e1 ( & mut self ) -> EN_E1_W { EN_E1_W { w : self } } # [ doc = "Bit 4 - Enable escalation signal 2 for Class A" ]
# [ inline ( always ) ]
pub fn en_e2 ( & mut self ) -> EN_E2_W { EN_E2_W { w : self } } # [ doc = "Bit 5 - Enable escalation signal 3 for Class A" ]
# [ inline ( always ) ]
pub fn en_e3 ( & mut self ) -> EN_E3_W { EN_E3_W { w : self } } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & mut self ) -> MAP_E0_W { MAP_E0_W { w : self } } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & mut self ) -> MAP_E1_W { MAP_E1_W { w : self } } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & mut self ) -> MAP_E2_W { MAP_E2_W { w : self } } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & mut self ) -> MAP_E3_W { MAP_E3_W { w : self } } } } # [ doc = "Clear enable for escalation protocol of Class A alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_clren](classa_clren) module" ]
pub type CLASSA_CLREN = crate :: Reg < u8 , _CLASSA_CLREN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_CLREN ; # [ doc = "`read()` method returns [classa_clren::R](classa_clren::R) reader structure" ]
impl crate :: Readable for CLASSA_CLREN { } # [ doc = "`write(|w| ..)` method takes [classa_clren::W](classa_clren::W) writer structure" ]
impl crate :: Writable for CLASSA_CLREN { } # [ doc = "Clear enable for escalation protocol of Class A alerts." ]
pub mod classa_clren { # [ doc = "Reader of register CLASSA_CLREN" ]
pub type R = crate :: R < u8 , super :: CLASSA_CLREN > ; # [ doc = "Writer for register CLASSA_CLREN" ]
pub type W = crate :: W < u8 , super :: CLASSA_CLREN > ; # [ doc = "Register CLASSA_CLREN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: CLASSA_CLREN { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } impl R { } impl W { } } # [ doc = "Clear for esclation protocol of Class A.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_clr](classa_clr) module" ]
pub type CLASSA_CLR = crate :: Reg < u8 , _CLASSA_CLR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_CLR ; # [ doc = "`write(|w| ..)` method takes [classa_clr::W](classa_clr::W) writer structure" ]
impl crate :: Writable for CLASSA_CLR { } # [ doc = "Clear for esclation protocol of Class A." ]
pub mod classa_clr { # [ doc = "Writer for register CLASSA_CLR" ]
pub type W = crate :: W < u8 , super :: CLASSA_CLR > ; # [ doc = "Register CLASSA_CLR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_CLR { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl W { } } # [ doc = "Current accumulation value for alert Class A. Software can clear this register with a write to !!CLASSA_CLR register unless !!CLASSA_CLREN is false.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_accum_cnt](classa_accum_cnt) module" ]
pub type CLASSA_ACCUM_CNT = crate :: Reg < u16 , _CLASSA_ACCUM_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_ACCUM_CNT ; # [ doc = "`read()` method returns [classa_accum_cnt::R](classa_accum_cnt::R) reader structure" ]
impl crate :: Readable for CLASSA_ACCUM_CNT { } # [ doc = "Current accumulation value for alert Class A. Software can clear this register with a write to !!CLASSA_CLR register unless !!CLASSA_CLREN is false." ]
pub mod classa_accum_cnt { # [ doc = "Reader of register CLASSA_ACCUM_CNT" ]
pub type R = crate :: R < u16 , super :: CLASSA_ACCUM_CNT > ; impl R { } } # [ doc = "Accumulation threshold value for alert Class A.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_accum_thresh](classa_accum_thresh) module" ]
pub type CLASSA_ACCUM_THRESH = crate :: Reg < u16 , _CLASSA_ACCUM_THRESH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_ACCUM_THRESH ; # [ doc = "`read()` method returns [classa_accum_thresh::R](classa_accum_thresh::R) reader structure" ]
impl crate :: Readable for CLASSA_ACCUM_THRESH { } # [ doc = "`write(|w| ..)` method takes [classa_accum_thresh::W](classa_accum_thresh::W) writer structure" ]
impl crate :: Writable for CLASSA_ACCUM_THRESH { } # [ doc = "Accumulation threshold value for alert Class A." ]
pub mod classa_accum_thresh { # [ doc = "Reader of register CLASSA_ACCUM_THRESH" ]
pub type R = crate :: R < u16 , super :: CLASSA_ACCUM_THRESH > ; # [ doc = "Writer for register CLASSA_ACCUM_THRESH" ]
pub type W = crate :: W < u16 , super :: CLASSA_ACCUM_THRESH > ; # [ doc = "Register CLASSA_ACCUM_THRESH `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_ACCUM_THRESH { type Type = u16 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt timeout in cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_timeout_cyc](classa_timeout_cyc) module" ]
pub type CLASSA_TIMEOUT_CYC = crate :: Reg < u32 , _CLASSA_TIMEOUT_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_TIMEOUT_CYC ; # [ doc = "`read()` method returns [classa_timeout_cyc::R](classa_timeout_cyc::R) reader structure" ]
impl crate :: Readable for CLASSA_TIMEOUT_CYC { } # [ doc = "`write(|w| ..)` method takes [classa_timeout_cyc::W](classa_timeout_cyc::W) writer structure" ]
impl crate :: Writable for CLASSA_TIMEOUT_CYC { } # [ doc = "Interrupt timeout in cycles." ]
pub mod classa_timeout_cyc { # [ doc = "Reader of register CLASSA_TIMEOUT_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSA_TIMEOUT_CYC > ; # [ doc = "Writer for register CLASSA_TIMEOUT_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSA_TIMEOUT_CYC > ; # [ doc = "Register CLASSA_TIMEOUT_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_TIMEOUT_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 0 for Class A.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_phase0_cyc](classa_phase0_cyc) module" ]
pub type CLASSA_PHASE0_CYC = crate :: Reg < u32 , _CLASSA_PHASE0_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_PHASE0_CYC ; # [ doc = "`read()` method returns [classa_phase0_cyc::R](classa_phase0_cyc::R) reader structure" ]
impl crate :: Readable for CLASSA_PHASE0_CYC { } # [ doc = "`write(|w| ..)` method takes [classa_phase0_cyc::W](classa_phase0_cyc::W) writer structure" ]
impl crate :: Writable for CLASSA_PHASE0_CYC { } # [ doc = "Duration of escalation phase 0 for Class A." ]
pub mod classa_phase0_cyc { # [ doc = "Reader of register CLASSA_PHASE0_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSA_PHASE0_CYC > ; # [ doc = "Writer for register CLASSA_PHASE0_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSA_PHASE0_CYC > ; # [ doc = "Register CLASSA_PHASE0_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_PHASE0_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 1 for Class A.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_phase1_cyc](classa_phase1_cyc) module" ]
pub type CLASSA_PHASE1_CYC = crate :: Reg < u32 , _CLASSA_PHASE1_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_PHASE1_CYC ; # [ doc = "`read()` method returns [classa_phase1_cyc::R](classa_phase1_cyc::R) reader structure" ]
impl crate :: Readable for CLASSA_PHASE1_CYC { } # [ doc = "`write(|w| ..)` method takes [classa_phase1_cyc::W](classa_phase1_cyc::W) writer structure" ]
impl crate :: Writable for CLASSA_PHASE1_CYC { } # [ doc = "Duration of escalation phase 1 for Class A." ]
pub mod classa_phase1_cyc { # [ doc = "Reader of register CLASSA_PHASE1_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSA_PHASE1_CYC > ; # [ doc = "Writer for register CLASSA_PHASE1_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSA_PHASE1_CYC > ; # [ doc = "Register CLASSA_PHASE1_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_PHASE1_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 2 for Class A.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_phase2_cyc](classa_phase2_cyc) module" ]
pub type CLASSA_PHASE2_CYC = crate :: Reg < u32 , _CLASSA_PHASE2_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_PHASE2_CYC ; # [ doc = "`read()` method returns [classa_phase2_cyc::R](classa_phase2_cyc::R) reader structure" ]
impl crate :: Readable for CLASSA_PHASE2_CYC { } # [ doc = "`write(|w| ..)` method takes [classa_phase2_cyc::W](classa_phase2_cyc::W) writer structure" ]
impl crate :: Writable for CLASSA_PHASE2_CYC { } # [ doc = "Duration of escalation phase 2 for Class A." ]
pub mod classa_phase2_cyc { # [ doc = "Reader of register CLASSA_PHASE2_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSA_PHASE2_CYC > ; # [ doc = "Writer for register CLASSA_PHASE2_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSA_PHASE2_CYC > ; # [ doc = "Register CLASSA_PHASE2_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_PHASE2_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 3 for Class A.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_phase3_cyc](classa_phase3_cyc) module" ]
pub type CLASSA_PHASE3_CYC = crate :: Reg < u32 , _CLASSA_PHASE3_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_PHASE3_CYC ; # [ doc = "`read()` method returns [classa_phase3_cyc::R](classa_phase3_cyc::R) reader structure" ]
impl crate :: Readable for CLASSA_PHASE3_CYC { } # [ doc = "`write(|w| ..)` method takes [classa_phase3_cyc::W](classa_phase3_cyc::W) writer structure" ]
impl crate :: Writable for CLASSA_PHASE3_CYC { } # [ doc = "Duration of escalation phase 3 for Class A." ]
pub mod classa_phase3_cyc { # [ doc = "Reader of register CLASSA_PHASE3_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSA_PHASE3_CYC > ; # [ doc = "Writer for register CLASSA_PHASE3_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSA_PHASE3_CYC > ; # [ doc = "Register CLASSA_PHASE3_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSA_PHASE3_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Escalation counter in cycles for Class A.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_esc_cnt](classa_esc_cnt) module" ]
pub type CLASSA_ESC_CNT = crate :: Reg < u32 , _CLASSA_ESC_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_ESC_CNT ; # [ doc = "`read()` method returns [classa_esc_cnt::R](classa_esc_cnt::R) reader structure" ]
impl crate :: Readable for CLASSA_ESC_CNT { } # [ doc = "Escalation counter in cycles for Class A." ]
pub mod classa_esc_cnt { # [ doc = "Reader of register CLASSA_ESC_CNT" ]
pub type R = crate :: R < u32 , super :: CLASSA_ESC_CNT > ; impl R { } } # [ doc = "Current escalation state of Class A. See also !!CLASSA_ESC_CNT.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classa_state](classa_state) module" ]
pub type CLASSA_STATE = crate :: Reg < u8 , _CLASSA_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSA_STATE ; # [ doc = "`read()` method returns [classa_state::R](classa_state::R) reader structure" ]
impl crate :: Readable for CLASSA_STATE { } # [ doc = "Current escalation state of Class A. See also !!CLASSA_ESC_CNT." ]
pub mod classa_state { # [ doc = "Reader of register CLASSA_STATE" ]
pub type R = crate :: R < u8 , super :: CLASSA_STATE > ; impl R { } } # [ doc = "Escalation control register for alert Class B. Can not be modified if !!REGEN is false.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_ctrl](classb_ctrl) module" ]
pub type CLASSB_CTRL = crate :: Reg < u32 , _CLASSB_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_CTRL ; # [ doc = "`read()` method returns [classb_ctrl::R](classb_ctrl::R) reader structure" ]
impl crate :: Readable for CLASSB_CTRL { } # [ doc = "`write(|w| ..)` method takes [classb_ctrl::W](classb_ctrl::W) writer structure" ]
impl crate :: Writable for CLASSB_CTRL { } # [ doc = "Escalation control register for alert Class B. Can not be modified if !!REGEN is false." ]
pub mod classb_ctrl { # [ doc = "Reader of register CLASSB_CTRL" ]
pub type R = crate :: R < u32 , super :: CLASSB_CTRL > ; # [ doc = "Writer for register CLASSB_CTRL" ]
pub type W = crate :: W < u32 , super :: CLASSB_CTRL > ; # [ doc = "Register CLASSB_CTRL `reset()`'s with value 0x393c" ]
impl crate :: ResetValue for super :: CLASSB_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x393c } } # [ doc = "Reader of field `EN`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LOCK`" ]
pub type LOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOCK`" ]
pub struct LOCK_W < 'a > { w : & 'a mut W , } impl < 'a > LOCK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_E0`" ]
pub type EN_E0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E0`" ]
pub struct EN_E0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_E1`" ]
pub type EN_E1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E1`" ]
pub struct EN_E1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `EN_E2`" ]
pub type EN_E2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E2`" ]
pub struct EN_E2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `EN_E3`" ]
pub type EN_E3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E3`" ]
pub struct EN_E3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `MAP_E0`" ]
pub type MAP_E0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E0`" ]
pub struct MAP_E0_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } # [ doc = "Reader of field `MAP_E1`" ]
pub type MAP_E1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E1`" ]
pub struct MAP_E1_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MAP_E2`" ]
pub type MAP_E2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E2`" ]
pub struct MAP_E2_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } # [ doc = "Reader of field `MAP_E3`" ]
pub type MAP_E3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E3`" ]
pub struct MAP_E3_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u32 ) & 0x03 ) << 12 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class B. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class B. If true, there is no way to stop the escalation protocol for class B once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable escalation signal 0 for Class B" ]
# [ inline ( always ) ]
pub fn en_e0 ( & self ) -> EN_E0_R { EN_E0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable escalation signal 1 for Class B" ]
# [ inline ( always ) ]
pub fn en_e1 ( & self ) -> EN_E1_R { EN_E1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable escalation signal 2 for Class B" ]
# [ inline ( always ) ]
pub fn en_e2 ( & self ) -> EN_E2_R { EN_E2_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable escalation signal 3 for Class B" ]
# [ inline ( always ) ]
pub fn en_e3 ( & self ) -> EN_E3_R { EN_E3_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & self ) -> MAP_E0_R { MAP_E0_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & self ) -> MAP_E1_R { MAP_E1_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & self ) -> MAP_E2_R { MAP_E2_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & self ) -> MAP_E3_R { MAP_E3_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class B. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class B. If true, there is no way to stop the escalation protocol for class B once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & mut self ) -> LOCK_W { LOCK_W { w : self } } # [ doc = "Bit 2 - Enable escalation signal 0 for Class B" ]
# [ inline ( always ) ]
pub fn en_e0 ( & mut self ) -> EN_E0_W { EN_E0_W { w : self } } # [ doc = "Bit 3 - Enable escalation signal 1 for Class B" ]
# [ inline ( always ) ]
pub fn en_e1 ( & mut self ) -> EN_E1_W { EN_E1_W { w : self } } # [ doc = "Bit 4 - Enable escalation signal 2 for Class B" ]
# [ inline ( always ) ]
pub fn en_e2 ( & mut self ) -> EN_E2_W { EN_E2_W { w : self } } # [ doc = "Bit 5 - Enable escalation signal 3 for Class B" ]
# [ inline ( always ) ]
pub fn en_e3 ( & mut self ) -> EN_E3_W { EN_E3_W { w : self } } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & mut self ) -> MAP_E0_W { MAP_E0_W { w : self } } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & mut self ) -> MAP_E1_W { MAP_E1_W { w : self } } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & mut self ) -> MAP_E2_W { MAP_E2_W { w : self } } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & mut self ) -> MAP_E3_W { MAP_E3_W { w : self } } } } # [ doc = "Clear enable for escalation protocol of Class B alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_clren](classb_clren) module" ]
pub type CLASSB_CLREN = crate :: Reg < u8 , _CLASSB_CLREN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_CLREN ; # [ doc = "`read()` method returns [classb_clren::R](classb_clren::R) reader structure" ]
impl crate :: Readable for CLASSB_CLREN { } # [ doc = "`write(|w| ..)` method takes [classb_clren::W](classb_clren::W) writer structure" ]
impl crate :: Writable for CLASSB_CLREN { } # [ doc = "Clear enable for escalation protocol of Class B alerts." ]
pub mod classb_clren { # [ doc = "Reader of register CLASSB_CLREN" ]
pub type R = crate :: R < u8 , super :: CLASSB_CLREN > ; # [ doc = "Writer for register CLASSB_CLREN" ]
pub type W = crate :: W < u8 , super :: CLASSB_CLREN > ; # [ doc = "Register CLASSB_CLREN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: CLASSB_CLREN { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } impl R { } impl W { } } # [ doc = "Clear for esclation protocol of Class B.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_clr](classb_clr) module" ]
pub type CLASSB_CLR = crate :: Reg < u8 , _CLASSB_CLR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_CLR ; # [ doc = "`write(|w| ..)` method takes [classb_clr::W](classb_clr::W) writer structure" ]
impl crate :: Writable for CLASSB_CLR { } # [ doc = "Clear for esclation protocol of Class B." ]
pub mod classb_clr { # [ doc = "Writer for register CLASSB_CLR" ]
pub type W = crate :: W < u8 , super :: CLASSB_CLR > ; # [ doc = "Register CLASSB_CLR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_CLR { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl W { } } # [ doc = "Current accumulation value for alert Class B. Software can clear this register with a write to !!CLASSB_CLR register unless !!CLASSB_CLREN is false.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_accum_cnt](classb_accum_cnt) module" ]
pub type CLASSB_ACCUM_CNT = crate :: Reg < u16 , _CLASSB_ACCUM_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_ACCUM_CNT ; # [ doc = "`read()` method returns [classb_accum_cnt::R](classb_accum_cnt::R) reader structure" ]
impl crate :: Readable for CLASSB_ACCUM_CNT { } # [ doc = "Current accumulation value for alert Class B. Software can clear this register with a write to !!CLASSB_CLR register unless !!CLASSB_CLREN is false." ]
pub mod classb_accum_cnt { # [ doc = "Reader of register CLASSB_ACCUM_CNT" ]
pub type R = crate :: R < u16 , super :: CLASSB_ACCUM_CNT > ; impl R { } } # [ doc = "Accumulation threshold value for alert Class B.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_accum_thresh](classb_accum_thresh) module" ]
pub type CLASSB_ACCUM_THRESH = crate :: Reg < u16 , _CLASSB_ACCUM_THRESH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_ACCUM_THRESH ; # [ doc = "`read()` method returns [classb_accum_thresh::R](classb_accum_thresh::R) reader structure" ]
impl crate :: Readable for CLASSB_ACCUM_THRESH { } # [ doc = "`write(|w| ..)` method takes [classb_accum_thresh::W](classb_accum_thresh::W) writer structure" ]
impl crate :: Writable for CLASSB_ACCUM_THRESH { } # [ doc = "Accumulation threshold value for alert Class B." ]
pub mod classb_accum_thresh { # [ doc = "Reader of register CLASSB_ACCUM_THRESH" ]
pub type R = crate :: R < u16 , super :: CLASSB_ACCUM_THRESH > ; # [ doc = "Writer for register CLASSB_ACCUM_THRESH" ]
pub type W = crate :: W < u16 , super :: CLASSB_ACCUM_THRESH > ; # [ doc = "Register CLASSB_ACCUM_THRESH `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_ACCUM_THRESH { type Type = u16 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt timeout in cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_timeout_cyc](classb_timeout_cyc) module" ]
pub type CLASSB_TIMEOUT_CYC = crate :: Reg < u32 , _CLASSB_TIMEOUT_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_TIMEOUT_CYC ; # [ doc = "`read()` method returns [classb_timeout_cyc::R](classb_timeout_cyc::R) reader structure" ]
impl crate :: Readable for CLASSB_TIMEOUT_CYC { } # [ doc = "`write(|w| ..)` method takes [classb_timeout_cyc::W](classb_timeout_cyc::W) writer structure" ]
impl crate :: Writable for CLASSB_TIMEOUT_CYC { } # [ doc = "Interrupt timeout in cycles." ]
pub mod classb_timeout_cyc { # [ doc = "Reader of register CLASSB_TIMEOUT_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSB_TIMEOUT_CYC > ; # [ doc = "Writer for register CLASSB_TIMEOUT_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSB_TIMEOUT_CYC > ; # [ doc = "Register CLASSB_TIMEOUT_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_TIMEOUT_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 0 for Class B.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_phase0_cyc](classb_phase0_cyc) module" ]
pub type CLASSB_PHASE0_CYC = crate :: Reg < u32 , _CLASSB_PHASE0_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_PHASE0_CYC ; # [ doc = "`read()` method returns [classb_phase0_cyc::R](classb_phase0_cyc::R) reader structure" ]
impl crate :: Readable for CLASSB_PHASE0_CYC { } # [ doc = "`write(|w| ..)` method takes [classb_phase0_cyc::W](classb_phase0_cyc::W) writer structure" ]
impl crate :: Writable for CLASSB_PHASE0_CYC { } # [ doc = "Duration of escalation phase 0 for Class B." ]
pub mod classb_phase0_cyc { # [ doc = "Reader of register CLASSB_PHASE0_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSB_PHASE0_CYC > ; # [ doc = "Writer for register CLASSB_PHASE0_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSB_PHASE0_CYC > ; # [ doc = "Register CLASSB_PHASE0_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_PHASE0_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 1 for Class B.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_phase1_cyc](classb_phase1_cyc) module" ]
pub type CLASSB_PHASE1_CYC = crate :: Reg < u32 , _CLASSB_PHASE1_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_PHASE1_CYC ; # [ doc = "`read()` method returns [classb_phase1_cyc::R](classb_phase1_cyc::R) reader structure" ]
impl crate :: Readable for CLASSB_PHASE1_CYC { } # [ doc = "`write(|w| ..)` method takes [classb_phase1_cyc::W](classb_phase1_cyc::W) writer structure" ]
impl crate :: Writable for CLASSB_PHASE1_CYC { } # [ doc = "Duration of escalation phase 1 for Class B." ]
pub mod classb_phase1_cyc { # [ doc = "Reader of register CLASSB_PHASE1_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSB_PHASE1_CYC > ; # [ doc = "Writer for register CLASSB_PHASE1_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSB_PHASE1_CYC > ; # [ doc = "Register CLASSB_PHASE1_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_PHASE1_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 2 for Class B.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_phase2_cyc](classb_phase2_cyc) module" ]
pub type CLASSB_PHASE2_CYC = crate :: Reg < u32 , _CLASSB_PHASE2_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_PHASE2_CYC ; # [ doc = "`read()` method returns [classb_phase2_cyc::R](classb_phase2_cyc::R) reader structure" ]
impl crate :: Readable for CLASSB_PHASE2_CYC { } # [ doc = "`write(|w| ..)` method takes [classb_phase2_cyc::W](classb_phase2_cyc::W) writer structure" ]
impl crate :: Writable for CLASSB_PHASE2_CYC { } # [ doc = "Duration of escalation phase 2 for Class B." ]
pub mod classb_phase2_cyc { # [ doc = "Reader of register CLASSB_PHASE2_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSB_PHASE2_CYC > ; # [ doc = "Writer for register CLASSB_PHASE2_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSB_PHASE2_CYC > ; # [ doc = "Register CLASSB_PHASE2_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_PHASE2_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 3 for Class B.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_phase3_cyc](classb_phase3_cyc) module" ]
pub type CLASSB_PHASE3_CYC = crate :: Reg < u32 , _CLASSB_PHASE3_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_PHASE3_CYC ; # [ doc = "`read()` method returns [classb_phase3_cyc::R](classb_phase3_cyc::R) reader structure" ]
impl crate :: Readable for CLASSB_PHASE3_CYC { } # [ doc = "`write(|w| ..)` method takes [classb_phase3_cyc::W](classb_phase3_cyc::W) writer structure" ]
impl crate :: Writable for CLASSB_PHASE3_CYC { } # [ doc = "Duration of escalation phase 3 for Class B." ]
pub mod classb_phase3_cyc { # [ doc = "Reader of register CLASSB_PHASE3_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSB_PHASE3_CYC > ; # [ doc = "Writer for register CLASSB_PHASE3_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSB_PHASE3_CYC > ; # [ doc = "Register CLASSB_PHASE3_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSB_PHASE3_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Escalation counter in cycles for Class B.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_esc_cnt](classb_esc_cnt) module" ]
pub type CLASSB_ESC_CNT = crate :: Reg < u32 , _CLASSB_ESC_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_ESC_CNT ; # [ doc = "`read()` method returns [classb_esc_cnt::R](classb_esc_cnt::R) reader structure" ]
impl crate :: Readable for CLASSB_ESC_CNT { } # [ doc = "Escalation counter in cycles for Class B." ]
pub mod classb_esc_cnt { # [ doc = "Reader of register CLASSB_ESC_CNT" ]
pub type R = crate :: R < u32 , super :: CLASSB_ESC_CNT > ; impl R { } } # [ doc = "Current escalation state of Class B. See also !!CLASSB_ESC_CNT.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classb_state](classb_state) module" ]
pub type CLASSB_STATE = crate :: Reg < u8 , _CLASSB_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSB_STATE ; # [ doc = "`read()` method returns [classb_state::R](classb_state::R) reader structure" ]
impl crate :: Readable for CLASSB_STATE { } # [ doc = "Current escalation state of Class B. See also !!CLASSB_ESC_CNT." ]
pub mod classb_state { # [ doc = "Reader of register CLASSB_STATE" ]
pub type R = crate :: R < u8 , super :: CLASSB_STATE > ; impl R { } } # [ doc = "Escalation control register for alert Class C. Can not be modified if !!REGEN is false.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_ctrl](classc_ctrl) module" ]
pub type CLASSC_CTRL = crate :: Reg < u32 , _CLASSC_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_CTRL ; # [ doc = "`read()` method returns [classc_ctrl::R](classc_ctrl::R) reader structure" ]
impl crate :: Readable for CLASSC_CTRL { } # [ doc = "`write(|w| ..)` method takes [classc_ctrl::W](classc_ctrl::W) writer structure" ]
impl crate :: Writable for CLASSC_CTRL { } # [ doc = "Escalation control register for alert Class C. Can not be modified if !!REGEN is false." ]
pub mod classc_ctrl { # [ doc = "Reader of register CLASSC_CTRL" ]
pub type R = crate :: R < u32 , super :: CLASSC_CTRL > ; # [ doc = "Writer for register CLASSC_CTRL" ]
pub type W = crate :: W < u32 , super :: CLASSC_CTRL > ; # [ doc = "Register CLASSC_CTRL `reset()`'s with value 0x393c" ]
impl crate :: ResetValue for super :: CLASSC_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x393c } } # [ doc = "Reader of field `EN`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LOCK`" ]
pub type LOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOCK`" ]
pub struct LOCK_W < 'a > { w : & 'a mut W , } impl < 'a > LOCK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_E0`" ]
pub type EN_E0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E0`" ]
pub struct EN_E0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_E1`" ]
pub type EN_E1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E1`" ]
pub struct EN_E1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `EN_E2`" ]
pub type EN_E2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E2`" ]
pub struct EN_E2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `EN_E3`" ]
pub type EN_E3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E3`" ]
pub struct EN_E3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `MAP_E0`" ]
pub type MAP_E0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E0`" ]
pub struct MAP_E0_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } # [ doc = "Reader of field `MAP_E1`" ]
pub type MAP_E1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E1`" ]
pub struct MAP_E1_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MAP_E2`" ]
pub type MAP_E2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E2`" ]
pub struct MAP_E2_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } # [ doc = "Reader of field `MAP_E3`" ]
pub type MAP_E3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E3`" ]
pub struct MAP_E3_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u32 ) & 0x03 ) << 12 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class C. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class C. If true, there is no way to stop the escalation protocol for class C once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable escalation signal 0 for Class C" ]
# [ inline ( always ) ]
pub fn en_e0 ( & self ) -> EN_E0_R { EN_E0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable escalation signal 1 for Class C" ]
# [ inline ( always ) ]
pub fn en_e1 ( & self ) -> EN_E1_R { EN_E1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable escalation signal 2 for Class C" ]
# [ inline ( always ) ]
pub fn en_e2 ( & self ) -> EN_E2_R { EN_E2_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable escalation signal 3 for Class C" ]
# [ inline ( always ) ]
pub fn en_e3 ( & self ) -> EN_E3_R { EN_E3_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & self ) -> MAP_E0_R { MAP_E0_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & self ) -> MAP_E1_R { MAP_E1_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & self ) -> MAP_E2_R { MAP_E2_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & self ) -> MAP_E3_R { MAP_E3_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class C. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class C. If true, there is no way to stop the escalation protocol for class C once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & mut self ) -> LOCK_W { LOCK_W { w : self } } # [ doc = "Bit 2 - Enable escalation signal 0 for Class C" ]
# [ inline ( always ) ]
pub fn en_e0 ( & mut self ) -> EN_E0_W { EN_E0_W { w : self } } # [ doc = "Bit 3 - Enable escalation signal 1 for Class C" ]
# [ inline ( always ) ]
pub fn en_e1 ( & mut self ) -> EN_E1_W { EN_E1_W { w : self } } # [ doc = "Bit 4 - Enable escalation signal 2 for Class C" ]
# [ inline ( always ) ]
pub fn en_e2 ( & mut self ) -> EN_E2_W { EN_E2_W { w : self } } # [ doc = "Bit 5 - Enable escalation signal 3 for Class C" ]
# [ inline ( always ) ]
pub fn en_e3 ( & mut self ) -> EN_E3_W { EN_E3_W { w : self } } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & mut self ) -> MAP_E0_W { MAP_E0_W { w : self } } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & mut self ) -> MAP_E1_W { MAP_E1_W { w : self } } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & mut self ) -> MAP_E2_W { MAP_E2_W { w : self } } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & mut self ) -> MAP_E3_W { MAP_E3_W { w : self } } } } # [ doc = "Clear enable for escalation protocol of Class C alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_clren](classc_clren) module" ]
pub type CLASSC_CLREN = crate :: Reg < u8 , _CLASSC_CLREN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_CLREN ; # [ doc = "`read()` method returns [classc_clren::R](classc_clren::R) reader structure" ]
impl crate :: Readable for CLASSC_CLREN { } # [ doc = "`write(|w| ..)` method takes [classc_clren::W](classc_clren::W) writer structure" ]
impl crate :: Writable for CLASSC_CLREN { } # [ doc = "Clear enable for escalation protocol of Class C alerts." ]
pub mod classc_clren { # [ doc = "Reader of register CLASSC_CLREN" ]
pub type R = crate :: R < u8 , super :: CLASSC_CLREN > ; # [ doc = "Writer for register CLASSC_CLREN" ]
pub type W = crate :: W < u8 , super :: CLASSC_CLREN > ; # [ doc = "Register CLASSC_CLREN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: CLASSC_CLREN { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } impl R { } impl W { } } # [ doc = "Clear for esclation protocol of Class C.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_clr](classc_clr) module" ]
pub type CLASSC_CLR = crate :: Reg < u8 , _CLASSC_CLR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_CLR ; # [ doc = "`write(|w| ..)` method takes [classc_clr::W](classc_clr::W) writer structure" ]
impl crate :: Writable for CLASSC_CLR { } # [ doc = "Clear for esclation protocol of Class C." ]
pub mod classc_clr { # [ doc = "Writer for register CLASSC_CLR" ]
pub type W = crate :: W < u8 , super :: CLASSC_CLR > ; # [ doc = "Register CLASSC_CLR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_CLR { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl W { } } # [ doc = "Current accumulation value for alert Class C. Software can clear this register with a write to !!CLASSC_CLR register unless !!CLASSC_CLREN is false.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_accum_cnt](classc_accum_cnt) module" ]
pub type CLASSC_ACCUM_CNT = crate :: Reg < u16 , _CLASSC_ACCUM_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_ACCUM_CNT ; # [ doc = "`read()` method returns [classc_accum_cnt::R](classc_accum_cnt::R) reader structure" ]
impl crate :: Readable for CLASSC_ACCUM_CNT { } # [ doc = "Current accumulation value for alert Class C. Software can clear this register with a write to !!CLASSC_CLR register unless !!CLASSC_CLREN is false." ]
pub mod classc_accum_cnt { # [ doc = "Reader of register CLASSC_ACCUM_CNT" ]
pub type R = crate :: R < u16 , super :: CLASSC_ACCUM_CNT > ; impl R { } } # [ doc = "Accumulation threshold value for alert Class C.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_accum_thresh](classc_accum_thresh) module" ]
pub type CLASSC_ACCUM_THRESH = crate :: Reg < u16 , _CLASSC_ACCUM_THRESH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_ACCUM_THRESH ; # [ doc = "`read()` method returns [classc_accum_thresh::R](classc_accum_thresh::R) reader structure" ]
impl crate :: Readable for CLASSC_ACCUM_THRESH { } # [ doc = "`write(|w| ..)` method takes [classc_accum_thresh::W](classc_accum_thresh::W) writer structure" ]
impl crate :: Writable for CLASSC_ACCUM_THRESH { } # [ doc = "Accumulation threshold value for alert Class C." ]
pub mod classc_accum_thresh { # [ doc = "Reader of register CLASSC_ACCUM_THRESH" ]
pub type R = crate :: R < u16 , super :: CLASSC_ACCUM_THRESH > ; # [ doc = "Writer for register CLASSC_ACCUM_THRESH" ]
pub type W = crate :: W < u16 , super :: CLASSC_ACCUM_THRESH > ; # [ doc = "Register CLASSC_ACCUM_THRESH `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_ACCUM_THRESH { type Type = u16 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt timeout in cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_timeout_cyc](classc_timeout_cyc) module" ]
pub type CLASSC_TIMEOUT_CYC = crate :: Reg < u32 , _CLASSC_TIMEOUT_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_TIMEOUT_CYC ; # [ doc = "`read()` method returns [classc_timeout_cyc::R](classc_timeout_cyc::R) reader structure" ]
impl crate :: Readable for CLASSC_TIMEOUT_CYC { } # [ doc = "`write(|w| ..)` method takes [classc_timeout_cyc::W](classc_timeout_cyc::W) writer structure" ]
impl crate :: Writable for CLASSC_TIMEOUT_CYC { } # [ doc = "Interrupt timeout in cycles." ]
pub mod classc_timeout_cyc { # [ doc = "Reader of register CLASSC_TIMEOUT_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSC_TIMEOUT_CYC > ; # [ doc = "Writer for register CLASSC_TIMEOUT_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSC_TIMEOUT_CYC > ; # [ doc = "Register CLASSC_TIMEOUT_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_TIMEOUT_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 0 for Class C.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_phase0_cyc](classc_phase0_cyc) module" ]
pub type CLASSC_PHASE0_CYC = crate :: Reg < u32 , _CLASSC_PHASE0_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_PHASE0_CYC ; # [ doc = "`read()` method returns [classc_phase0_cyc::R](classc_phase0_cyc::R) reader structure" ]
impl crate :: Readable for CLASSC_PHASE0_CYC { } # [ doc = "`write(|w| ..)` method takes [classc_phase0_cyc::W](classc_phase0_cyc::W) writer structure" ]
impl crate :: Writable for CLASSC_PHASE0_CYC { } # [ doc = "Duration of escalation phase 0 for Class C." ]
pub mod classc_phase0_cyc { # [ doc = "Reader of register CLASSC_PHASE0_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSC_PHASE0_CYC > ; # [ doc = "Writer for register CLASSC_PHASE0_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSC_PHASE0_CYC > ; # [ doc = "Register CLASSC_PHASE0_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_PHASE0_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 1 for Class C.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_phase1_cyc](classc_phase1_cyc) module" ]
pub type CLASSC_PHASE1_CYC = crate :: Reg < u32 , _CLASSC_PHASE1_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_PHASE1_CYC ; # [ doc = "`read()` method returns [classc_phase1_cyc::R](classc_phase1_cyc::R) reader structure" ]
impl crate :: Readable for CLASSC_PHASE1_CYC { } # [ doc = "`write(|w| ..)` method takes [classc_phase1_cyc::W](classc_phase1_cyc::W) writer structure" ]
impl crate :: Writable for CLASSC_PHASE1_CYC { } # [ doc = "Duration of escalation phase 1 for Class C." ]
pub mod classc_phase1_cyc { # [ doc = "Reader of register CLASSC_PHASE1_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSC_PHASE1_CYC > ; # [ doc = "Writer for register CLASSC_PHASE1_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSC_PHASE1_CYC > ; # [ doc = "Register CLASSC_PHASE1_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_PHASE1_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 2 for Class C.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_phase2_cyc](classc_phase2_cyc) module" ]
pub type CLASSC_PHASE2_CYC = crate :: Reg < u32 , _CLASSC_PHASE2_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_PHASE2_CYC ; # [ doc = "`read()` method returns [classc_phase2_cyc::R](classc_phase2_cyc::R) reader structure" ]
impl crate :: Readable for CLASSC_PHASE2_CYC { } # [ doc = "`write(|w| ..)` method takes [classc_phase2_cyc::W](classc_phase2_cyc::W) writer structure" ]
impl crate :: Writable for CLASSC_PHASE2_CYC { } # [ doc = "Duration of escalation phase 2 for Class C." ]
pub mod classc_phase2_cyc { # [ doc = "Reader of register CLASSC_PHASE2_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSC_PHASE2_CYC > ; # [ doc = "Writer for register CLASSC_PHASE2_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSC_PHASE2_CYC > ; # [ doc = "Register CLASSC_PHASE2_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_PHASE2_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 3 for Class C.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_phase3_cyc](classc_phase3_cyc) module" ]
pub type CLASSC_PHASE3_CYC = crate :: Reg < u32 , _CLASSC_PHASE3_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_PHASE3_CYC ; # [ doc = "`read()` method returns [classc_phase3_cyc::R](classc_phase3_cyc::R) reader structure" ]
impl crate :: Readable for CLASSC_PHASE3_CYC { } # [ doc = "`write(|w| ..)` method takes [classc_phase3_cyc::W](classc_phase3_cyc::W) writer structure" ]
impl crate :: Writable for CLASSC_PHASE3_CYC { } # [ doc = "Duration of escalation phase 3 for Class C." ]
pub mod classc_phase3_cyc { # [ doc = "Reader of register CLASSC_PHASE3_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSC_PHASE3_CYC > ; # [ doc = "Writer for register CLASSC_PHASE3_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSC_PHASE3_CYC > ; # [ doc = "Register CLASSC_PHASE3_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSC_PHASE3_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Escalation counter in cycles for Class C.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_esc_cnt](classc_esc_cnt) module" ]
pub type CLASSC_ESC_CNT = crate :: Reg < u32 , _CLASSC_ESC_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_ESC_CNT ; # [ doc = "`read()` method returns [classc_esc_cnt::R](classc_esc_cnt::R) reader structure" ]
impl crate :: Readable for CLASSC_ESC_CNT { } # [ doc = "Escalation counter in cycles for Class C." ]
pub mod classc_esc_cnt { # [ doc = "Reader of register CLASSC_ESC_CNT" ]
pub type R = crate :: R < u32 , super :: CLASSC_ESC_CNT > ; impl R { } } # [ doc = "Current escalation state of Class C. See also !!CLASSC_ESC_CNT.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classc_state](classc_state) module" ]
pub type CLASSC_STATE = crate :: Reg < u8 , _CLASSC_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSC_STATE ; # [ doc = "`read()` method returns [classc_state::R](classc_state::R) reader structure" ]
impl crate :: Readable for CLASSC_STATE { } # [ doc = "Current escalation state of Class C. See also !!CLASSC_ESC_CNT." ]
pub mod classc_state { # [ doc = "Reader of register CLASSC_STATE" ]
pub type R = crate :: R < u8 , super :: CLASSC_STATE > ; impl R { } } # [ doc = "Escalation control register for alert Class D. Can not be modified if !!REGEN is false.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_ctrl](classd_ctrl) module" ]
pub type CLASSD_CTRL = crate :: Reg < u32 , _CLASSD_CTRL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_CTRL ; # [ doc = "`read()` method returns [classd_ctrl::R](classd_ctrl::R) reader structure" ]
impl crate :: Readable for CLASSD_CTRL { } # [ doc = "`write(|w| ..)` method takes [classd_ctrl::W](classd_ctrl::W) writer structure" ]
impl crate :: Writable for CLASSD_CTRL { } # [ doc = "Escalation control register for alert Class D. Can not be modified if !!REGEN is false." ]
pub mod classd_ctrl { # [ doc = "Reader of register CLASSD_CTRL" ]
pub type R = crate :: R < u32 , super :: CLASSD_CTRL > ; # [ doc = "Writer for register CLASSD_CTRL" ]
pub type W = crate :: W < u32 , super :: CLASSD_CTRL > ; # [ doc = "Register CLASSD_CTRL `reset()`'s with value 0x393c" ]
impl crate :: ResetValue for super :: CLASSD_CTRL { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x393c } } # [ doc = "Reader of field `EN`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LOCK`" ]
pub type LOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOCK`" ]
pub struct LOCK_W < 'a > { w : & 'a mut W , } impl < 'a > LOCK_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `EN_E0`" ]
pub type EN_E0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E0`" ]
pub struct EN_E0_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `EN_E1`" ]
pub type EN_E1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E1`" ]
pub struct EN_E1_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `EN_E2`" ]
pub type EN_E2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E2`" ]
pub struct EN_E2_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `EN_E3`" ]
pub type EN_E3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `EN_E3`" ]
pub struct EN_E3_W < 'a > { w : & 'a mut W , } impl < 'a > EN_E3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `MAP_E0`" ]
pub type MAP_E0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E0`" ]
pub struct MAP_E0_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E0_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } } # [ doc = "Reader of field `MAP_E1`" ]
pub type MAP_E1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E1`" ]
pub struct MAP_E1_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E1_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MAP_E2`" ]
pub type MAP_E2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E2`" ]
pub struct MAP_E2_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E2_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } # [ doc = "Reader of field `MAP_E3`" ]
pub type MAP_E3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MAP_E3`" ]
pub struct MAP_E3_W < 'a > { w : & 'a mut W , } impl < 'a > MAP_E3_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u32 ) & 0x03 ) << 12 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class D. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class D. If true, there is no way to stop the escalation protocol for class D once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable escalation signal 0 for Class D" ]
# [ inline ( always ) ]
pub fn en_e0 ( & self ) -> EN_E0_R { EN_E0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable escalation signal 1 for Class D" ]
# [ inline ( always ) ]
pub fn en_e1 ( & self ) -> EN_E1_R { EN_E1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Enable escalation signal 2 for Class D" ]
# [ inline ( always ) ]
pub fn en_e2 ( & self ) -> EN_E2_R { EN_E2_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Enable escalation signal 3 for Class D" ]
# [ inline ( always ) ]
pub fn en_e3 ( & self ) -> EN_E3_R { EN_E3_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & self ) -> MAP_E0_R { MAP_E0_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & self ) -> MAP_E1_R { MAP_E1_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & self ) -> MAP_E2_R { MAP_E2_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & self ) -> MAP_E3_R { MAP_E3_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Enable escalation mechanisms (accumulation and interrupt timeout) for Class D. Note that interrupts can fire regardless of whether the escalation mechanisms are enabled for this class or not." ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } # [ doc = "Bit 1 - Enable automatic locking of escalation counter for class D. If true, there is no way to stop the escalation protocol for class D once it has been triggered." ]
# [ inline ( always ) ]
pub fn lock ( & mut self ) -> LOCK_W { LOCK_W { w : self } } # [ doc = "Bit 2 - Enable escalation signal 0 for Class D" ]
# [ inline ( always ) ]
pub fn en_e0 ( & mut self ) -> EN_E0_W { EN_E0_W { w : self } } # [ doc = "Bit 3 - Enable escalation signal 1 for Class D" ]
# [ inline ( always ) ]
pub fn en_e1 ( & mut self ) -> EN_E1_W { EN_E1_W { w : self } } # [ doc = "Bit 4 - Enable escalation signal 2 for Class D" ]
# [ inline ( always ) ]
pub fn en_e2 ( & mut self ) -> EN_E2_W { EN_E2_W { w : self } } # [ doc = "Bit 5 - Enable escalation signal 3 for Class D" ]
# [ inline ( always ) ]
pub fn en_e3 ( & mut self ) -> EN_E3_W { EN_E3_W { w : self } } # [ doc = "Bits 6:7 - Determines in which escalation phase escalation signal 0 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e0 ( & mut self ) -> MAP_E0_W { MAP_E0_W { w : self } } # [ doc = "Bits 8:9 - Determines in which escalation phase escalation signal 1 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e1 ( & mut self ) -> MAP_E1_W { MAP_E1_W { w : self } } # [ doc = "Bits 10:11 - Determine sin which escalation phase escalation signal 2 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e2 ( & mut self ) -> MAP_E2_W { MAP_E2_W { w : self } } # [ doc = "Bits 12:13 - Determines in which escalation phase escalation signal 3 shall be asserted." ]
# [ inline ( always ) ]
pub fn map_e3 ( & mut self ) -> MAP_E3_W { MAP_E3_W { w : self } } } } # [ doc = "Clear enable for escalation protocol of Class D alerts.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_clren](classd_clren) module" ]
pub type CLASSD_CLREN = crate :: Reg < u8 , _CLASSD_CLREN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_CLREN ; # [ doc = "`read()` method returns [classd_clren::R](classd_clren::R) reader structure" ]
impl crate :: Readable for CLASSD_CLREN { } # [ doc = "`write(|w| ..)` method takes [classd_clren::W](classd_clren::W) writer structure" ]
impl crate :: Writable for CLASSD_CLREN { } # [ doc = "Clear enable for escalation protocol of Class D alerts." ]
pub mod classd_clren { # [ doc = "Reader of register CLASSD_CLREN" ]
pub type R = crate :: R < u8 , super :: CLASSD_CLREN > ; # [ doc = "Writer for register CLASSD_CLREN" ]
pub type W = crate :: W < u8 , super :: CLASSD_CLREN > ; # [ doc = "Register CLASSD_CLREN `reset()`'s with value 0x01" ]
impl crate :: ResetValue for super :: CLASSD_CLREN { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x01 } } impl R { } impl W { } } # [ doc = "Clear for esclation protocol of Class D.\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_clr](classd_clr) module" ]
pub type CLASSD_CLR = crate :: Reg < u8 , _CLASSD_CLR > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_CLR ; # [ doc = "`write(|w| ..)` method takes [classd_clr::W](classd_clr::W) writer structure" ]
impl crate :: Writable for CLASSD_CLR { } # [ doc = "Clear for esclation protocol of Class D." ]
pub mod classd_clr { # [ doc = "Writer for register CLASSD_CLR" ]
pub type W = crate :: W < u8 , super :: CLASSD_CLR > ; # [ doc = "Register CLASSD_CLR `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_CLR { type Type = u8 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl W { } } # [ doc = "Current accumulation value for alert Class D. Software can clear this register with a write to !!CLASSD_CLR register unless !!CLASSD_CLREN is false.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_accum_cnt](classd_accum_cnt) module" ]
pub type CLASSD_ACCUM_CNT = crate :: Reg < u16 , _CLASSD_ACCUM_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_ACCUM_CNT ; # [ doc = "`read()` method returns [classd_accum_cnt::R](classd_accum_cnt::R) reader structure" ]
impl crate :: Readable for CLASSD_ACCUM_CNT { } # [ doc = "Current accumulation value for alert Class D. Software can clear this register with a write to !!CLASSD_CLR register unless !!CLASSD_CLREN is false." ]
pub mod classd_accum_cnt { # [ doc = "Reader of register CLASSD_ACCUM_CNT" ]
pub type R = crate :: R < u16 , super :: CLASSD_ACCUM_CNT > ; impl R { } } # [ doc = "Accumulation threshold value for alert Class D.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_accum_thresh](classd_accum_thresh) module" ]
pub type CLASSD_ACCUM_THRESH = crate :: Reg < u16 , _CLASSD_ACCUM_THRESH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_ACCUM_THRESH ; # [ doc = "`read()` method returns [classd_accum_thresh::R](classd_accum_thresh::R) reader structure" ]
impl crate :: Readable for CLASSD_ACCUM_THRESH { } # [ doc = "`write(|w| ..)` method takes [classd_accum_thresh::W](classd_accum_thresh::W) writer structure" ]
impl crate :: Writable for CLASSD_ACCUM_THRESH { } # [ doc = "Accumulation threshold value for alert Class D." ]
pub mod classd_accum_thresh { # [ doc = "Reader of register CLASSD_ACCUM_THRESH" ]
pub type R = crate :: R < u16 , super :: CLASSD_ACCUM_THRESH > ; # [ doc = "Writer for register CLASSD_ACCUM_THRESH" ]
pub type W = crate :: W < u16 , super :: CLASSD_ACCUM_THRESH > ; # [ doc = "Register CLASSD_ACCUM_THRESH `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_ACCUM_THRESH { type Type = u16 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Interrupt timeout in cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_timeout_cyc](classd_timeout_cyc) module" ]
pub type CLASSD_TIMEOUT_CYC = crate :: Reg < u32 , _CLASSD_TIMEOUT_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_TIMEOUT_CYC ; # [ doc = "`read()` method returns [classd_timeout_cyc::R](classd_timeout_cyc::R) reader structure" ]
impl crate :: Readable for CLASSD_TIMEOUT_CYC { } # [ doc = "`write(|w| ..)` method takes [classd_timeout_cyc::W](classd_timeout_cyc::W) writer structure" ]
impl crate :: Writable for CLASSD_TIMEOUT_CYC { } # [ doc = "Interrupt timeout in cycles." ]
pub mod classd_timeout_cyc { # [ doc = "Reader of register CLASSD_TIMEOUT_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSD_TIMEOUT_CYC > ; # [ doc = "Writer for register CLASSD_TIMEOUT_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSD_TIMEOUT_CYC > ; # [ doc = "Register CLASSD_TIMEOUT_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_TIMEOUT_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 0 for Class D.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_phase0_cyc](classd_phase0_cyc) module" ]
pub type CLASSD_PHASE0_CYC = crate :: Reg < u32 , _CLASSD_PHASE0_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_PHASE0_CYC ; # [ doc = "`read()` method returns [classd_phase0_cyc::R](classd_phase0_cyc::R) reader structure" ]
impl crate :: Readable for CLASSD_PHASE0_CYC { } # [ doc = "`write(|w| ..)` method takes [classd_phase0_cyc::W](classd_phase0_cyc::W) writer structure" ]
impl crate :: Writable for CLASSD_PHASE0_CYC { } # [ doc = "Duration of escalation phase 0 for Class D." ]
pub mod classd_phase0_cyc { # [ doc = "Reader of register CLASSD_PHASE0_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSD_PHASE0_CYC > ; # [ doc = "Writer for register CLASSD_PHASE0_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSD_PHASE0_CYC > ; # [ doc = "Register CLASSD_PHASE0_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_PHASE0_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 1 for Class D.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_phase1_cyc](classd_phase1_cyc) module" ]
pub type CLASSD_PHASE1_CYC = crate :: Reg < u32 , _CLASSD_PHASE1_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_PHASE1_CYC ; # [ doc = "`read()` method returns [classd_phase1_cyc::R](classd_phase1_cyc::R) reader structure" ]
impl crate :: Readable for CLASSD_PHASE1_CYC { } # [ doc = "`write(|w| ..)` method takes [classd_phase1_cyc::W](classd_phase1_cyc::W) writer structure" ]
impl crate :: Writable for CLASSD_PHASE1_CYC { } # [ doc = "Duration of escalation phase 1 for Class D." ]
pub mod classd_phase1_cyc { # [ doc = "Reader of register CLASSD_PHASE1_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSD_PHASE1_CYC > ; # [ doc = "Writer for register CLASSD_PHASE1_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSD_PHASE1_CYC > ; # [ doc = "Register CLASSD_PHASE1_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_PHASE1_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 2 for Class D.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_phase2_cyc](classd_phase2_cyc) module" ]
pub type CLASSD_PHASE2_CYC = crate :: Reg < u32 , _CLASSD_PHASE2_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_PHASE2_CYC ; # [ doc = "`read()` method returns [classd_phase2_cyc::R](classd_phase2_cyc::R) reader structure" ]
impl crate :: Readable for CLASSD_PHASE2_CYC { } # [ doc = "`write(|w| ..)` method takes [classd_phase2_cyc::W](classd_phase2_cyc::W) writer structure" ]
impl crate :: Writable for CLASSD_PHASE2_CYC { } # [ doc = "Duration of escalation phase 2 for Class D." ]
pub mod classd_phase2_cyc { # [ doc = "Reader of register CLASSD_PHASE2_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSD_PHASE2_CYC > ; # [ doc = "Writer for register CLASSD_PHASE2_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSD_PHASE2_CYC > ; # [ doc = "Register CLASSD_PHASE2_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_PHASE2_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Duration of escalation phase 3 for Class D.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_phase3_cyc](classd_phase3_cyc) module" ]
pub type CLASSD_PHASE3_CYC = crate :: Reg < u32 , _CLASSD_PHASE3_CYC > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_PHASE3_CYC ; # [ doc = "`read()` method returns [classd_phase3_cyc::R](classd_phase3_cyc::R) reader structure" ]
impl crate :: Readable for CLASSD_PHASE3_CYC { } # [ doc = "`write(|w| ..)` method takes [classd_phase3_cyc::W](classd_phase3_cyc::W) writer structure" ]
impl crate :: Writable for CLASSD_PHASE3_CYC { } # [ doc = "Duration of escalation phase 3 for Class D." ]
pub mod classd_phase3_cyc { # [ doc = "Reader of register CLASSD_PHASE3_CYC" ]
pub type R = crate :: R < u32 , super :: CLASSD_PHASE3_CYC > ; # [ doc = "Writer for register CLASSD_PHASE3_CYC" ]
pub type W = crate :: W < u32 , super :: CLASSD_PHASE3_CYC > ; # [ doc = "Register CLASSD_PHASE3_CYC `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: CLASSD_PHASE3_CYC { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Escalation counter in cycles for Class D.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_esc_cnt](classd_esc_cnt) module" ]
pub type CLASSD_ESC_CNT = crate :: Reg < u32 , _CLASSD_ESC_CNT > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_ESC_CNT ; # [ doc = "`read()` method returns [classd_esc_cnt::R](classd_esc_cnt::R) reader structure" ]
impl crate :: Readable for CLASSD_ESC_CNT { } # [ doc = "Escalation counter in cycles for Class D." ]
pub mod classd_esc_cnt { # [ doc = "Reader of register CLASSD_ESC_CNT" ]
pub type R = crate :: R < u32 , super :: CLASSD_ESC_CNT > ; impl R { } } # [ doc = "Current escalation state of Class D. See also !!CLASSD_ESC_CNT.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [classd_state](classd_state) module" ]
pub type CLASSD_STATE = crate :: Reg < u8 , _CLASSD_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CLASSD_STATE ; # [ doc = "`read()` method returns [classd_state::R](classd_state::R) reader structure" ]
impl crate :: Readable for CLASSD_STATE { } # [ doc = "Current escalation state of Class D. See also !!CLASSD_ESC_CNT." ]
pub mod classd_state { # [ doc = "Reader of register CLASSD_STATE" ]
pub type R = crate :: R < u8 , super :: CLASSD_STATE > ; impl R { } } } # [ doc = "nmi_gen" ]
pub struct NMI_GEN { _marker : PhantomData < * const ( ) > } unsafe impl Send for NMI_GEN { } impl NMI_GEN { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const nmi_gen :: RegisterBlock { 0x4014_0000 as * const _ } } impl Deref for NMI_GEN { type Target = nmi_gen :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * NMI_GEN :: ptr ( ) } } } # [ doc = "nmi_gen" ]
pub mod nmi_gen { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Interrupt State Register" ]
pub intr_state : INTR_STATE , # [ doc = "0x04 - Interrupt Enable Register" ]
pub intr_enable : INTR_ENABLE , # [ doc = "0x08 - Interrupt Test Register" ]
pub intr_test : INTR_TEST , } # [ doc = "Interrupt State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_state](intr_state) module" ]
pub type INTR_STATE = crate :: Reg < u32 , _INTR_STATE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_STATE ; # [ doc = "`read()` method returns [intr_state::R](intr_state::R) reader structure" ]
impl crate :: Readable for INTR_STATE { } # [ doc = "`write(|w| ..)` method takes [intr_state::W](intr_state::W) writer structure" ]
impl crate :: Writable for INTR_STATE { } # [ doc = "Interrupt State Register" ]
pub mod intr_state { # [ doc = "Reader of register INTR_STATE" ]
pub type R = crate :: R < u32 , super :: INTR_STATE > ; # [ doc = "Writer for register INTR_STATE" ]
pub type W = crate :: W < u32 , super :: INTR_STATE > ; # [ doc = "Register INTR_STATE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_STATE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `esc0`" ]
pub type ESC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc0`" ]
pub struct ESC0_W < 'a > { w : & 'a mut W , } impl < 'a > ESC0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `esc1`" ]
pub type ESC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc1`" ]
pub struct ESC1_W < 'a > { w : & 'a mut W , } impl < 'a > ESC1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `esc2`" ]
pub type ESC2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc2`" ]
pub struct ESC2_W < 'a > { w : & 'a mut W , } impl < 'a > ESC2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `esc3`" ]
pub type ESC3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc3`" ]
pub struct ESC3_W < 'a > { w : & 'a mut W , } impl < 'a > ESC3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Escalation interrupt 0" ]
# [ inline ( always ) ]
pub fn esc0 ( & self ) -> ESC0_R { ESC0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Escalation interrupt 1" ]
# [ inline ( always ) ]
pub fn esc1 ( & self ) -> ESC1_R { ESC1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Escalation interrupt 2" ]
# [ inline ( always ) ]
pub fn esc2 ( & self ) -> ESC2_R { ESC2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Escalation interrupt 3" ]
# [ inline ( always ) ]
pub fn esc3 ( & self ) -> ESC3_R { ESC3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Escalation interrupt 0" ]
# [ inline ( always ) ]
pub fn esc0 ( & mut self ) -> ESC0_W { ESC0_W { w : self } } # [ doc = "Bit 1 - Escalation interrupt 1" ]
# [ inline ( always ) ]
pub fn esc1 ( & mut self ) -> ESC1_W { ESC1_W { w : self } } # [ doc = "Bit 2 - Escalation interrupt 2" ]
# [ inline ( always ) ]
pub fn esc2 ( & mut self ) -> ESC2_W { ESC2_W { w : self } } # [ doc = "Bit 3 - Escalation interrupt 3" ]
# [ inline ( always ) ]
pub fn esc3 ( & mut self ) -> ESC3_W { ESC3_W { w : self } } } } # [ doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_enable](intr_enable) module" ]
pub type INTR_ENABLE = crate :: Reg < u32 , _INTR_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_ENABLE ; # [ doc = "`read()` method returns [intr_enable::R](intr_enable::R) reader structure" ]
impl crate :: Readable for INTR_ENABLE { } # [ doc = "`write(|w| ..)` method takes [intr_enable::W](intr_enable::W) writer structure" ]
impl crate :: Writable for INTR_ENABLE { } # [ doc = "Interrupt Enable Register" ]
pub mod intr_enable { # [ doc = "Reader of register INTR_ENABLE" ]
pub type R = crate :: R < u32 , super :: INTR_ENABLE > ; # [ doc = "Writer for register INTR_ENABLE" ]
pub type W = crate :: W < u32 , super :: INTR_ENABLE > ; # [ doc = "Register INTR_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `esc0`" ]
pub type ESC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc0`" ]
pub struct ESC0_W < 'a > { w : & 'a mut W , } impl < 'a > ESC0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `esc1`" ]
pub type ESC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc1`" ]
pub struct ESC1_W < 'a > { w : & 'a mut W , } impl < 'a > ESC1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `esc2`" ]
pub type ESC2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc2`" ]
pub struct ESC2_W < 'a > { w : & 'a mut W , } impl < 'a > ESC2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `esc3`" ]
pub type ESC3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `esc3`" ]
pub struct ESC3_W < 'a > { w : & 'a mut W , } impl < 'a > ESC3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl R { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.esc0 is set" ]
# [ inline ( always ) ]
pub fn esc0 ( & self ) -> ESC0_R { ESC0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.esc1 is set" ]
# [ inline ( always ) ]
pub fn esc1 ( & self ) -> ESC1_R { ESC1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.esc2 is set" ]
# [ inline ( always ) ]
pub fn esc2 ( & self ) -> ESC2_R { ESC2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.esc3 is set" ]
# [ inline ( always ) ]
pub fn esc3 ( & self ) -> ESC3_R { ESC3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Enable interrupt when !!INTR_STATE.esc0 is set" ]
# [ inline ( always ) ]
pub fn esc0 ( & mut self ) -> ESC0_W { ESC0_W { w : self } } # [ doc = "Bit 1 - Enable interrupt when !!INTR_STATE.esc1 is set" ]
# [ inline ( always ) ]
pub fn esc1 ( & mut self ) -> ESC1_W { ESC1_W { w : self } } # [ doc = "Bit 2 - Enable interrupt when !!INTR_STATE.esc2 is set" ]
# [ inline ( always ) ]
pub fn esc2 ( & mut self ) -> ESC2_W { ESC2_W { w : self } } # [ doc = "Bit 3 - Enable interrupt when !!INTR_STATE.esc3 is set" ]
# [ inline ( always ) ]
pub fn esc3 ( & mut self ) -> ESC3_W { ESC3_W { w : self } } } } # [ doc = "Interrupt Test Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_test](intr_test) module" ]
pub type INTR_TEST = crate :: Reg < u32 , _INTR_TEST > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _INTR_TEST ; # [ doc = "`write(|w| ..)` method takes [intr_test::W](intr_test::W) writer structure" ]
impl crate :: Writable for INTR_TEST { } # [ doc = "Interrupt Test Register" ]
pub mod intr_test { # [ doc = "Writer for register INTR_TEST" ]
pub type W = crate :: W < u32 , super :: INTR_TEST > ; # [ doc = "Register INTR_TEST `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: INTR_TEST { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `esc0`" ]
pub struct ESC0_W < 'a > { w : & 'a mut W , } impl < 'a > ESC0_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Write proxy for field `esc1`" ]
pub struct ESC1_W < 'a > { w : & 'a mut W , } impl < 'a > ESC1_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Write proxy for field `esc2`" ]
pub struct ESC2_W < 'a > { w : & 'a mut W , } impl < 'a > ESC2_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Write proxy for field `esc3`" ]
pub struct ESC3_W < 'a > { w : & 'a mut W , } impl < 'a > ESC3_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } impl W { # [ doc = "Bit 0 - Write 1 to force !!INTR_STATE.esc0 to 1" ]
# [ inline ( always ) ]
pub fn esc0 ( & mut self ) -> ESC0_W { ESC0_W { w : self } } # [ doc = "Bit 1 - Write 1 to force !!INTR_STATE.esc1 to 1" ]
# [ inline ( always ) ]
pub fn esc1 ( & mut self ) -> ESC1_W { ESC1_W { w : self } } # [ doc = "Bit 2 - Write 1 to force !!INTR_STATE.esc2 to 1" ]
# [ inline ( always ) ]
pub fn esc2 ( & mut self ) -> ESC2_W { ESC2_W { w : self } } # [ doc = "Bit 3 - Write 1 to force !!INTR_STATE.esc3 to 1" ]
# [ inline ( always ) ]
pub fn esc3 ( & mut self ) -> ESC3_W { ESC3_W { w : self } } } } } # [ no_mangle ]
static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r"All the peripherals" ]
# [ allow ( non_snake_case ) ]
pub struct Peripherals { # [ doc = "UART" ]
pub UART : UART , # [ doc = "GPIO" ]
pub GPIO : GPIO , # [ doc = "SPI_DEVICE" ]
pub SPI_DEVICE : SPI_DEVICE , # [ doc = "FLASH_CTRL" ]
pub FLASH_CTRL : FLASH_CTRL , # [ doc = "RV_TIMER" ]
pub RV_TIMER : RV_TIMER , # [ doc = "AES" ]
pub AES : AES , # [ doc = "HMAC" ]
pub HMAC : HMAC , # [ doc = "RV_PLIC" ]
pub RV_PLIC : RV_PLIC , # [ doc = "PINMUX" ]
pub PINMUX : PINMUX , # [ doc = "ALERT_HANDLER" ]
pub ALERT_HANDLER : ALERT_HANDLER , # [ doc = "NMI_GEN" ]
pub NMI_GEN : NMI_GEN , } impl Peripherals { # [ doc = r"Returns all the peripherals *once*" ]
# [ inline ]
pub fn take ( ) -> Option < Self > { riscv :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r"Unchecked version of `Peripherals::take`" ]
# [ inline ]
pub unsafe fn steal ( ) -> Self { DEVICE_PERIPHERALS = true ; Peripherals { UART : UART { _marker : PhantomData } , GPIO : GPIO { _marker : PhantomData } , SPI_DEVICE : SPI_DEVICE { _marker : PhantomData } , FLASH_CTRL : FLASH_CTRL { _marker : PhantomData } , RV_TIMER : RV_TIMER { _marker : PhantomData } , AES : AES { _marker : PhantomData } , HMAC : HMAC { _marker : PhantomData } , RV_PLIC : RV_PLIC { _marker : PhantomData } , PINMUX : PINMUX { _marker : PhantomData } , ALERT_HANDLER : ALERT_HANDLER { _marker : PhantomData } , NMI_GEN : NMI_GEN { _marker : PhantomData } , } } }